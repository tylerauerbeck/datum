// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphapi

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/datumforge/datum/internal/ent/generated"
	"github.com/datumforge/datum/internal/ent/generated/entitlement"
	"github.com/datumforge/datum/internal/ent/generated/groupsetting"
	"github.com/datumforge/datum/internal/ent/generated/usersetting"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	OauthProvider() OauthProviderResolver
	Query() QueryResolver
	CreateOauthProviderInput() CreateOauthProviderInputResolver
	OauthProviderWhereInput() OauthProviderWhereInputResolver
	UpdateOauthProviderInput() UpdateOauthProviderInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Entitlement struct {
		Cancelled              func(childComplexity int) int
		CreatedAt              func(childComplexity int) int
		CreatedBy              func(childComplexity int) int
		DeletedAt              func(childComplexity int) int
		DeletedBy              func(childComplexity int) int
		Expires                func(childComplexity int) int
		ExpiresAt              func(childComplexity int) int
		ExternalCustomerID     func(childComplexity int) int
		ExternalSubscriptionID func(childComplexity int) int
		ID                     func(childComplexity int) int
		Owner                  func(childComplexity int) int
		Tier                   func(childComplexity int) int
		UpdatedAt              func(childComplexity int) int
		UpdatedBy              func(childComplexity int) int
	}

	EntitlementConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EntitlementCreatePayload struct {
		Entitlement func(childComplexity int) int
	}

	EntitlementDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	EntitlementEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	EntitlementUpdatePayload struct {
		Entitlement func(childComplexity int) int
	}

	Group struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		DeletedBy       func(childComplexity int) int
		Description     func(childComplexity int) int
		DisplayName     func(childComplexity int) int
		GravatarLogoURL func(childComplexity int) int
		ID              func(childComplexity int) int
		LogoURL         func(childComplexity int) int
		Name            func(childComplexity int) int
		Owner           func(childComplexity int) int
		Setting         func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		Users           func(childComplexity int) int
	}

	GroupConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GroupCreatePayload struct {
		Group func(childComplexity int) int
	}

	GroupDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	GroupEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GroupSetting struct {
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		DeletedBy    func(childComplexity int) int
		Group        func(childComplexity int) int
		ID           func(childComplexity int) int
		JoinPolicy   func(childComplexity int) int
		SyncToGithub func(childComplexity int) int
		SyncToSlack  func(childComplexity int) int
		Tags         func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		UpdatedBy    func(childComplexity int) int
		Visibility   func(childComplexity int) int
	}

	GroupSettingConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	GroupSettingCreatePayload struct {
		GroupSetting func(childComplexity int) int
	}

	GroupSettingDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	GroupSettingEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GroupSettingUpdatePayload struct {
		GroupSetting func(childComplexity int) int
	}

	GroupUpdatePayload struct {
		Group func(childComplexity int) int
	}

	Integration struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		DeletedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Kind        func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		SecretName  func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	IntegrationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IntegrationCreatePayload struct {
		Integration func(childComplexity int) int
	}

	IntegrationDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	IntegrationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	IntegrationUpdatePayload struct {
		Integration func(childComplexity int) int
	}

	Mutation struct {
		CreateEntitlement         func(childComplexity int, input generated.CreateEntitlementInput) int
		CreateGroup               func(childComplexity int, input generated.CreateGroupInput) int
		CreateGroupSetting        func(childComplexity int, input generated.CreateGroupSettingInput) int
		CreateIntegration         func(childComplexity int, input generated.CreateIntegrationInput) int
		CreateOauthProvider       func(childComplexity int, input generated.CreateOauthProviderInput) int
		CreateOhAuthTooToken      func(childComplexity int, input generated.CreateOhAuthTooTokenInput) int
		CreateOrganization        func(childComplexity int, input generated.CreateOrganizationInput) int
		CreateOrganizationSetting func(childComplexity int, input generated.CreateOrganizationSettingInput) int
		CreatePersonalAccessToken func(childComplexity int, input generated.CreatePersonalAccessTokenInput) int
		CreateSession             func(childComplexity int, input generated.CreateSessionInput) int
		CreateUser                func(childComplexity int, input generated.CreateUserInput) int
		CreateUserSetting         func(childComplexity int, input generated.CreateUserSettingInput) int
		DeleteEntitlement         func(childComplexity int, id string) int
		DeleteGroup               func(childComplexity int, id string) int
		DeleteGroupSetting        func(childComplexity int, id string) int
		DeleteIntegration         func(childComplexity int, id string) int
		DeleteOauthProvider       func(childComplexity int, id string) int
		DeleteOhAuthTooToken      func(childComplexity int, id string) int
		DeleteOrganization        func(childComplexity int, id string) int
		DeleteOrganizationSetting func(childComplexity int, id string) int
		DeletePersonalAccessToken func(childComplexity int, id string) int
		DeleteSession             func(childComplexity int, id string) int
		DeleteUser                func(childComplexity int, id string) int
		DeleteUserSetting         func(childComplexity int, id string) int
		UpdateEntitlement         func(childComplexity int, id string, input generated.UpdateEntitlementInput) int
		UpdateGroup               func(childComplexity int, id string, input generated.UpdateGroupInput) int
		UpdateGroupSetting        func(childComplexity int, id string, input generated.UpdateGroupSettingInput) int
		UpdateIntegration         func(childComplexity int, id string, input generated.UpdateIntegrationInput) int
		UpdateOauthProvider       func(childComplexity int, id string, input generated.UpdateOauthProviderInput) int
		UpdateOhAuthTooToken      func(childComplexity int, id string, input generated.UpdateOhAuthTooTokenInput) int
		UpdateOrganization        func(childComplexity int, id string, input generated.UpdateOrganizationInput) int
		UpdateOrganizationSetting func(childComplexity int, id string, input generated.UpdateOrganizationSettingInput) int
		UpdatePersonalAccessToken func(childComplexity int, id string, input generated.UpdatePersonalAccessTokenInput) int
		UpdateSession             func(childComplexity int, id string, input generated.UpdateSessionInput) int
		UpdateUser                func(childComplexity int, id string, input generated.UpdateUserInput) int
		UpdateUserSetting         func(childComplexity int, id string, input generated.UpdateUserSettingInput) int
	}

	OauthProvider struct {
		AuthStyle    func(childComplexity int) int
		AuthURL      func(childComplexity int) int
		ClientID     func(childComplexity int) int
		ClientSecret func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		DeletedBy    func(childComplexity int) int
		ID           func(childComplexity int) int
		InfoURL      func(childComplexity int) int
		Name         func(childComplexity int) int
		Owner        func(childComplexity int) int
		RedirectURL  func(childComplexity int) int
		Scopes       func(childComplexity int) int
		TokenURL     func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		UpdatedBy    func(childComplexity int) int
	}

	OauthProviderConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OauthProviderCreatePayload struct {
		OauthProvider func(childComplexity int) int
	}

	OauthProviderDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	OauthProviderEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OauthProviderUpdatePayload struct {
		OauthProvider func(childComplexity int) int
	}

	OhAuthTooToken struct {
		ClaimsEmail             func(childComplexity int) int
		ClaimsEmailVerified     func(childComplexity int) int
		ClaimsGroups            func(childComplexity int) int
		ClaimsPreferredUsername func(childComplexity int) int
		ClaimsUserID            func(childComplexity int) int
		ClaimsUsername          func(childComplexity int) int
		ClientID                func(childComplexity int) int
		ConnectorData           func(childComplexity int) int
		ConnectorID             func(childComplexity int) int
		ID                      func(childComplexity int) int
		LastUsed                func(childComplexity int) int
		Nonce                   func(childComplexity int) int
		Scopes                  func(childComplexity int) int
	}

	OhAuthTooTokenConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OhAuthTooTokenCreatePayload struct {
		OhAuthTooToken func(childComplexity int) int
	}

	OhAuthTooTokenDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	OhAuthTooTokenEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OhAuthTooTokenUpdatePayload struct {
		OhAuthTooToken func(childComplexity int) int
	}

	Organization struct {
		Children      func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.OrganizationOrder, where *generated.OrganizationWhereInput) int
		CreatedAt     func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		DeletedBy     func(childComplexity int) int
		Description   func(childComplexity int) int
		DisplayName   func(childComplexity int) int
		Entitlements  func(childComplexity int) int
		Groups        func(childComplexity int) int
		ID            func(childComplexity int) int
		Integrations  func(childComplexity int) int
		Name          func(childComplexity int) int
		Oauthprovider func(childComplexity int) int
		Parent        func(childComplexity int) int
		PersonalOrg   func(childComplexity int) int
		Setting       func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UpdatedBy     func(childComplexity int) int
		Users         func(childComplexity int) int
	}

	OrganizationConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OrganizationCreatePayload struct {
		Organization func(childComplexity int) int
	}

	OrganizationDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	OrganizationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OrganizationSetting struct {
		BillingAddress func(childComplexity int) int
		BillingContact func(childComplexity int) int
		BillingEmail   func(childComplexity int) int
		BillingPhone   func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		CreatedBy      func(childComplexity int) int
		DeletedAt      func(childComplexity int) int
		DeletedBy      func(childComplexity int) int
		Domains        func(childComplexity int) int
		ID             func(childComplexity int) int
		Organization   func(childComplexity int) int
		SSOCert        func(childComplexity int) int
		SSOEntrypoint  func(childComplexity int) int
		SSOIssuer      func(childComplexity int) int
		Tags           func(childComplexity int) int
		TaxIdentifier  func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UpdatedBy      func(childComplexity int) int
	}

	OrganizationSettingConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	OrganizationSettingCreatePayload struct {
		OrganizationSetting func(childComplexity int) int
	}

	OrganizationSettingDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	OrganizationSettingEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	OrganizationSettingUpdatePayload struct {
		OrganizationSetting func(childComplexity int) int
	}

	OrganizationUpdatePayload struct {
		Organization func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PersonalAccessToken struct {
		Abilities   func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		DeletedBy   func(childComplexity int) int
		Description func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		LastUsedAt  func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UpdatedBy   func(childComplexity int) int
	}

	PersonalAccessTokenConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PersonalAccessTokenCreatePayload struct {
		PersonalAccessToken func(childComplexity int) int
	}

	PersonalAccessTokenDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	PersonalAccessTokenEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PersonalAccessTokenUpdatePayload struct {
		PersonalAccessToken func(childComplexity int) int
	}

	Query struct {
		Entitlement          func(childComplexity int, id string) int
		Entitlements         func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.EntitlementWhereInput) int
		Group                func(childComplexity int, id string) int
		GroupSetting         func(childComplexity int, id string) int
		GroupSettings        func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.GroupSettingWhereInput) int
		Groups               func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.GroupOrder, where *generated.GroupWhereInput) int
		Integration          func(childComplexity int, id string) int
		Integrations         func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.IntegrationOrder, where *generated.IntegrationWhereInput) int
		Node                 func(childComplexity int, id string) int
		Nodes                func(childComplexity int, ids []string) int
		OauthProvider        func(childComplexity int, id string) int
		OauthProviders       func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.OauthProviderWhereInput) int
		OhAuthTooToken       func(childComplexity int, id string) int
		OhAuthTooTokens      func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.OhAuthTooTokenWhereInput) int
		Organization         func(childComplexity int, id string) int
		OrganizationSetting  func(childComplexity int, id string) int
		OrganizationSettings func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.OrganizationSettingWhereInput) int
		Organizations        func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.OrganizationOrder, where *generated.OrganizationWhereInput) int
		PersonalAccessToken  func(childComplexity int, id string) int
		PersonalAccessTokens func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.PersonalAccessTokenWhereInput) int
		Session              func(childComplexity int, id string) int
		Sessions             func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.SessionWhereInput) int
		User                 func(childComplexity int, id string) int
		UserSetting          func(childComplexity int, id string) int
		UserSettings         func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.UserSettingWhereInput) int
		Users                func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.UserOrder, where *generated.UserWhereInput) int
	}

	Session struct {
		CreatedAt      func(childComplexity int) int
		CreatedBy      func(childComplexity int) int
		ExpiresAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		IssuedAt       func(childComplexity int) int
		OrganizationID func(childComplexity int) int
		Owner          func(childComplexity int) int
		SessionToken   func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UpdatedBy      func(childComplexity int) int
		UserID         func(childComplexity int) int
	}

	SessionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SessionCreatePayload struct {
		Session func(childComplexity int) int
	}

	SessionDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	SessionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SessionUpdatePayload struct {
		Session func(childComplexity int) int
	}

	User struct {
		AvatarLocalFile      func(childComplexity int) int
		AvatarRemoteURL      func(childComplexity int) int
		AvatarUpdatedAt      func(childComplexity int) int
		CreatedAt            func(childComplexity int) int
		CreatedBy            func(childComplexity int) int
		DeletedAt            func(childComplexity int) int
		DeletedBy            func(childComplexity int) int
		DisplayName          func(childComplexity int) int
		Email                func(childComplexity int) int
		FirstName            func(childComplexity int) int
		Groups               func(childComplexity int) int
		ID                   func(childComplexity int) int
		LastName             func(childComplexity int) int
		LastSeen             func(childComplexity int) int
		Oauth                func(childComplexity int) int
		Organizations        func(childComplexity int) int
		Password             func(childComplexity int) int
		PersonalAccessTokens func(childComplexity int) int
		Sessions             func(childComplexity int) int
		Setting              func(childComplexity int) int
		Sub                  func(childComplexity int) int
		UpdatedAt            func(childComplexity int) int
		UpdatedBy            func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserCreatePayload struct {
		User func(childComplexity int) int
	}

	UserDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserSetting struct {
		CreatedAt      func(childComplexity int) int
		CreatedBy      func(childComplexity int) int
		DeletedAt      func(childComplexity int) int
		DeletedBy      func(childComplexity int) int
		EmailConfirmed func(childComplexity int) int
		ID             func(childComplexity int) int
		Locked         func(childComplexity int) int
		Permissions    func(childComplexity int) int
		Role           func(childComplexity int) int
		SilencedAt     func(childComplexity int) int
		Status         func(childComplexity int) int
		SuspendedAt    func(childComplexity int) int
		Tags           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UpdatedBy      func(childComplexity int) int
		User           func(childComplexity int) int
	}

	UserSettingConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserSettingCreatePayload struct {
		UserSetting func(childComplexity int) int
	}

	UserSettingDeletePayload struct {
		DeletedID func(childComplexity int) int
	}

	UserSettingEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserSettingUpdatePayload struct {
		UserSetting func(childComplexity int) int
	}

	UserUpdatePayload struct {
		User func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateEntitlement(ctx context.Context, input generated.CreateEntitlementInput) (*EntitlementCreatePayload, error)
	UpdateEntitlement(ctx context.Context, id string, input generated.UpdateEntitlementInput) (*EntitlementUpdatePayload, error)
	DeleteEntitlement(ctx context.Context, id string) (*EntitlementDeletePayload, error)
	CreateGroup(ctx context.Context, input generated.CreateGroupInput) (*GroupCreatePayload, error)
	UpdateGroup(ctx context.Context, id string, input generated.UpdateGroupInput) (*GroupUpdatePayload, error)
	DeleteGroup(ctx context.Context, id string) (*GroupDeletePayload, error)
	CreateGroupSetting(ctx context.Context, input generated.CreateGroupSettingInput) (*GroupSettingCreatePayload, error)
	UpdateGroupSetting(ctx context.Context, id string, input generated.UpdateGroupSettingInput) (*GroupSettingUpdatePayload, error)
	DeleteGroupSetting(ctx context.Context, id string) (*GroupSettingDeletePayload, error)
	CreateIntegration(ctx context.Context, input generated.CreateIntegrationInput) (*IntegrationCreatePayload, error)
	UpdateIntegration(ctx context.Context, id string, input generated.UpdateIntegrationInput) (*IntegrationUpdatePayload, error)
	DeleteIntegration(ctx context.Context, id string) (*IntegrationDeletePayload, error)
	CreateOauthProvider(ctx context.Context, input generated.CreateOauthProviderInput) (*OauthProviderCreatePayload, error)
	UpdateOauthProvider(ctx context.Context, id string, input generated.UpdateOauthProviderInput) (*OauthProviderUpdatePayload, error)
	DeleteOauthProvider(ctx context.Context, id string) (*OauthProviderDeletePayload, error)
	CreateOhAuthTooToken(ctx context.Context, input generated.CreateOhAuthTooTokenInput) (*OhAuthTooTokenCreatePayload, error)
	UpdateOhAuthTooToken(ctx context.Context, id string, input generated.UpdateOhAuthTooTokenInput) (*OhAuthTooTokenUpdatePayload, error)
	DeleteOhAuthTooToken(ctx context.Context, id string) (*OhAuthTooTokenDeletePayload, error)
	CreateOrganization(ctx context.Context, input generated.CreateOrganizationInput) (*OrganizationCreatePayload, error)
	UpdateOrganization(ctx context.Context, id string, input generated.UpdateOrganizationInput) (*OrganizationUpdatePayload, error)
	DeleteOrganization(ctx context.Context, id string) (*OrganizationDeletePayload, error)
	CreateOrganizationSetting(ctx context.Context, input generated.CreateOrganizationSettingInput) (*OrganizationSettingCreatePayload, error)
	UpdateOrganizationSetting(ctx context.Context, id string, input generated.UpdateOrganizationSettingInput) (*OrganizationSettingUpdatePayload, error)
	DeleteOrganizationSetting(ctx context.Context, id string) (*OrganizationSettingDeletePayload, error)
	CreatePersonalAccessToken(ctx context.Context, input generated.CreatePersonalAccessTokenInput) (*PersonalAccessTokenCreatePayload, error)
	UpdatePersonalAccessToken(ctx context.Context, id string, input generated.UpdatePersonalAccessTokenInput) (*PersonalAccessTokenUpdatePayload, error)
	DeletePersonalAccessToken(ctx context.Context, id string) (*PersonalAccessTokenDeletePayload, error)
	CreateSession(ctx context.Context, input generated.CreateSessionInput) (*SessionCreatePayload, error)
	UpdateSession(ctx context.Context, id string, input generated.UpdateSessionInput) (*SessionUpdatePayload, error)
	DeleteSession(ctx context.Context, id string) (*SessionDeletePayload, error)
	CreateUser(ctx context.Context, input generated.CreateUserInput) (*UserCreatePayload, error)
	UpdateUser(ctx context.Context, id string, input generated.UpdateUserInput) (*UserUpdatePayload, error)
	DeleteUser(ctx context.Context, id string) (*UserDeletePayload, error)
	CreateUserSetting(ctx context.Context, input generated.CreateUserSettingInput) (*UserSettingCreatePayload, error)
	UpdateUserSetting(ctx context.Context, id string, input generated.UpdateUserSettingInput) (*UserSettingUpdatePayload, error)
	DeleteUserSetting(ctx context.Context, id string) (*UserSettingDeletePayload, error)
}
type OauthProviderResolver interface {
	AuthStyle(ctx context.Context, obj *generated.OauthProvider) (int, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id string) (generated.Noder, error)
	Nodes(ctx context.Context, ids []string) ([]generated.Noder, error)
	Entitlements(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.EntitlementWhereInput) (*generated.EntitlementConnection, error)
	Groups(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.GroupOrder, where *generated.GroupWhereInput) (*generated.GroupConnection, error)
	GroupSettings(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.GroupSettingWhereInput) (*generated.GroupSettingConnection, error)
	Integrations(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.IntegrationOrder, where *generated.IntegrationWhereInput) (*generated.IntegrationConnection, error)
	OauthProviders(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.OauthProviderWhereInput) (*generated.OauthProviderConnection, error)
	OhAuthTooTokens(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.OhAuthTooTokenWhereInput) (*generated.OhAuthTooTokenConnection, error)
	Organizations(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.OrganizationOrder, where *generated.OrganizationWhereInput) (*generated.OrganizationConnection, error)
	OrganizationSettings(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.OrganizationSettingWhereInput) (*generated.OrganizationSettingConnection, error)
	PersonalAccessTokens(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.PersonalAccessTokenWhereInput) (*generated.PersonalAccessTokenConnection, error)
	Sessions(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.SessionWhereInput) (*generated.SessionConnection, error)
	Users(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *generated.UserOrder, where *generated.UserWhereInput) (*generated.UserConnection, error)
	UserSettings(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *generated.UserSettingWhereInput) (*generated.UserSettingConnection, error)
	Entitlement(ctx context.Context, id string) (*generated.Entitlement, error)
	Group(ctx context.Context, id string) (*generated.Group, error)
	GroupSetting(ctx context.Context, id string) (*generated.GroupSetting, error)
	Integration(ctx context.Context, id string) (*generated.Integration, error)
	OauthProvider(ctx context.Context, id string) (*generated.OauthProvider, error)
	OhAuthTooToken(ctx context.Context, id string) (*generated.OhAuthTooToken, error)
	Organization(ctx context.Context, id string) (*generated.Organization, error)
	OrganizationSetting(ctx context.Context, id string) (*generated.OrganizationSetting, error)
	PersonalAccessToken(ctx context.Context, id string) (*generated.PersonalAccessToken, error)
	Session(ctx context.Context, id string) (*generated.Session, error)
	User(ctx context.Context, id string) (*generated.User, error)
	UserSetting(ctx context.Context, id string) (*generated.UserSetting, error)
}

type CreateOauthProviderInputResolver interface {
	AuthStyle(ctx context.Context, obj *generated.CreateOauthProviderInput, data int) error
}
type OauthProviderWhereInputResolver interface {
	AuthStyle(ctx context.Context, obj *generated.OauthProviderWhereInput, data *int) error
	AuthStyleNeq(ctx context.Context, obj *generated.OauthProviderWhereInput, data *int) error
	AuthStyleIn(ctx context.Context, obj *generated.OauthProviderWhereInput, data []int) error
	AuthStyleNotIn(ctx context.Context, obj *generated.OauthProviderWhereInput, data []int) error
	AuthStyleGt(ctx context.Context, obj *generated.OauthProviderWhereInput, data *int) error
	AuthStyleGte(ctx context.Context, obj *generated.OauthProviderWhereInput, data *int) error
	AuthStyleLt(ctx context.Context, obj *generated.OauthProviderWhereInput, data *int) error
	AuthStyleLte(ctx context.Context, obj *generated.OauthProviderWhereInput, data *int) error
}
type UpdateOauthProviderInputResolver interface {
	AuthStyle(ctx context.Context, obj *generated.UpdateOauthProviderInput, data *int) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Entitlement.cancelled":
		if e.complexity.Entitlement.Cancelled == nil {
			break
		}

		return e.complexity.Entitlement.Cancelled(childComplexity), true

	case "Entitlement.createdAt":
		if e.complexity.Entitlement.CreatedAt == nil {
			break
		}

		return e.complexity.Entitlement.CreatedAt(childComplexity), true

	case "Entitlement.createdBy":
		if e.complexity.Entitlement.CreatedBy == nil {
			break
		}

		return e.complexity.Entitlement.CreatedBy(childComplexity), true

	case "Entitlement.deletedAt":
		if e.complexity.Entitlement.DeletedAt == nil {
			break
		}

		return e.complexity.Entitlement.DeletedAt(childComplexity), true

	case "Entitlement.deletedBy":
		if e.complexity.Entitlement.DeletedBy == nil {
			break
		}

		return e.complexity.Entitlement.DeletedBy(childComplexity), true

	case "Entitlement.expires":
		if e.complexity.Entitlement.Expires == nil {
			break
		}

		return e.complexity.Entitlement.Expires(childComplexity), true

	case "Entitlement.expiresAt":
		if e.complexity.Entitlement.ExpiresAt == nil {
			break
		}

		return e.complexity.Entitlement.ExpiresAt(childComplexity), true

	case "Entitlement.externalCustomerID":
		if e.complexity.Entitlement.ExternalCustomerID == nil {
			break
		}

		return e.complexity.Entitlement.ExternalCustomerID(childComplexity), true

	case "Entitlement.externalSubscriptionID":
		if e.complexity.Entitlement.ExternalSubscriptionID == nil {
			break
		}

		return e.complexity.Entitlement.ExternalSubscriptionID(childComplexity), true

	case "Entitlement.id":
		if e.complexity.Entitlement.ID == nil {
			break
		}

		return e.complexity.Entitlement.ID(childComplexity), true

	case "Entitlement.owner":
		if e.complexity.Entitlement.Owner == nil {
			break
		}

		return e.complexity.Entitlement.Owner(childComplexity), true

	case "Entitlement.tier":
		if e.complexity.Entitlement.Tier == nil {
			break
		}

		return e.complexity.Entitlement.Tier(childComplexity), true

	case "Entitlement.updatedAt":
		if e.complexity.Entitlement.UpdatedAt == nil {
			break
		}

		return e.complexity.Entitlement.UpdatedAt(childComplexity), true

	case "Entitlement.updatedBy":
		if e.complexity.Entitlement.UpdatedBy == nil {
			break
		}

		return e.complexity.Entitlement.UpdatedBy(childComplexity), true

	case "EntitlementConnection.edges":
		if e.complexity.EntitlementConnection.Edges == nil {
			break
		}

		return e.complexity.EntitlementConnection.Edges(childComplexity), true

	case "EntitlementConnection.pageInfo":
		if e.complexity.EntitlementConnection.PageInfo == nil {
			break
		}

		return e.complexity.EntitlementConnection.PageInfo(childComplexity), true

	case "EntitlementConnection.totalCount":
		if e.complexity.EntitlementConnection.TotalCount == nil {
			break
		}

		return e.complexity.EntitlementConnection.TotalCount(childComplexity), true

	case "EntitlementCreatePayload.entitlement":
		if e.complexity.EntitlementCreatePayload.Entitlement == nil {
			break
		}

		return e.complexity.EntitlementCreatePayload.Entitlement(childComplexity), true

	case "EntitlementDeletePayload.deletedID":
		if e.complexity.EntitlementDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.EntitlementDeletePayload.DeletedID(childComplexity), true

	case "EntitlementEdge.cursor":
		if e.complexity.EntitlementEdge.Cursor == nil {
			break
		}

		return e.complexity.EntitlementEdge.Cursor(childComplexity), true

	case "EntitlementEdge.node":
		if e.complexity.EntitlementEdge.Node == nil {
			break
		}

		return e.complexity.EntitlementEdge.Node(childComplexity), true

	case "EntitlementUpdatePayload.entitlement":
		if e.complexity.EntitlementUpdatePayload.Entitlement == nil {
			break
		}

		return e.complexity.EntitlementUpdatePayload.Entitlement(childComplexity), true

	case "Group.createdAt":
		if e.complexity.Group.CreatedAt == nil {
			break
		}

		return e.complexity.Group.CreatedAt(childComplexity), true

	case "Group.createdBy":
		if e.complexity.Group.CreatedBy == nil {
			break
		}

		return e.complexity.Group.CreatedBy(childComplexity), true

	case "Group.deletedAt":
		if e.complexity.Group.DeletedAt == nil {
			break
		}

		return e.complexity.Group.DeletedAt(childComplexity), true

	case "Group.deletedBy":
		if e.complexity.Group.DeletedBy == nil {
			break
		}

		return e.complexity.Group.DeletedBy(childComplexity), true

	case "Group.description":
		if e.complexity.Group.Description == nil {
			break
		}

		return e.complexity.Group.Description(childComplexity), true

	case "Group.displayName":
		if e.complexity.Group.DisplayName == nil {
			break
		}

		return e.complexity.Group.DisplayName(childComplexity), true

	case "Group.gravatarLogoURL":
		if e.complexity.Group.GravatarLogoURL == nil {
			break
		}

		return e.complexity.Group.GravatarLogoURL(childComplexity), true

	case "Group.id":
		if e.complexity.Group.ID == nil {
			break
		}

		return e.complexity.Group.ID(childComplexity), true

	case "Group.logoURL":
		if e.complexity.Group.LogoURL == nil {
			break
		}

		return e.complexity.Group.LogoURL(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "Group.owner":
		if e.complexity.Group.Owner == nil {
			break
		}

		return e.complexity.Group.Owner(childComplexity), true

	case "Group.setting":
		if e.complexity.Group.Setting == nil {
			break
		}

		return e.complexity.Group.Setting(childComplexity), true

	case "Group.updatedAt":
		if e.complexity.Group.UpdatedAt == nil {
			break
		}

		return e.complexity.Group.UpdatedAt(childComplexity), true

	case "Group.updatedBy":
		if e.complexity.Group.UpdatedBy == nil {
			break
		}

		return e.complexity.Group.UpdatedBy(childComplexity), true

	case "Group.users":
		if e.complexity.Group.Users == nil {
			break
		}

		return e.complexity.Group.Users(childComplexity), true

	case "GroupConnection.edges":
		if e.complexity.GroupConnection.Edges == nil {
			break
		}

		return e.complexity.GroupConnection.Edges(childComplexity), true

	case "GroupConnection.pageInfo":
		if e.complexity.GroupConnection.PageInfo == nil {
			break
		}

		return e.complexity.GroupConnection.PageInfo(childComplexity), true

	case "GroupConnection.totalCount":
		if e.complexity.GroupConnection.TotalCount == nil {
			break
		}

		return e.complexity.GroupConnection.TotalCount(childComplexity), true

	case "GroupCreatePayload.group":
		if e.complexity.GroupCreatePayload.Group == nil {
			break
		}

		return e.complexity.GroupCreatePayload.Group(childComplexity), true

	case "GroupDeletePayload.deletedID":
		if e.complexity.GroupDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.GroupDeletePayload.DeletedID(childComplexity), true

	case "GroupEdge.cursor":
		if e.complexity.GroupEdge.Cursor == nil {
			break
		}

		return e.complexity.GroupEdge.Cursor(childComplexity), true

	case "GroupEdge.node":
		if e.complexity.GroupEdge.Node == nil {
			break
		}

		return e.complexity.GroupEdge.Node(childComplexity), true

	case "GroupSetting.createdAt":
		if e.complexity.GroupSetting.CreatedAt == nil {
			break
		}

		return e.complexity.GroupSetting.CreatedAt(childComplexity), true

	case "GroupSetting.createdBy":
		if e.complexity.GroupSetting.CreatedBy == nil {
			break
		}

		return e.complexity.GroupSetting.CreatedBy(childComplexity), true

	case "GroupSetting.deletedAt":
		if e.complexity.GroupSetting.DeletedAt == nil {
			break
		}

		return e.complexity.GroupSetting.DeletedAt(childComplexity), true

	case "GroupSetting.deletedBy":
		if e.complexity.GroupSetting.DeletedBy == nil {
			break
		}

		return e.complexity.GroupSetting.DeletedBy(childComplexity), true

	case "GroupSetting.group":
		if e.complexity.GroupSetting.Group == nil {
			break
		}

		return e.complexity.GroupSetting.Group(childComplexity), true

	case "GroupSetting.id":
		if e.complexity.GroupSetting.ID == nil {
			break
		}

		return e.complexity.GroupSetting.ID(childComplexity), true

	case "GroupSetting.joinPolicy":
		if e.complexity.GroupSetting.JoinPolicy == nil {
			break
		}

		return e.complexity.GroupSetting.JoinPolicy(childComplexity), true

	case "GroupSetting.syncToGithub":
		if e.complexity.GroupSetting.SyncToGithub == nil {
			break
		}

		return e.complexity.GroupSetting.SyncToGithub(childComplexity), true

	case "GroupSetting.syncToSlack":
		if e.complexity.GroupSetting.SyncToSlack == nil {
			break
		}

		return e.complexity.GroupSetting.SyncToSlack(childComplexity), true

	case "GroupSetting.tags":
		if e.complexity.GroupSetting.Tags == nil {
			break
		}

		return e.complexity.GroupSetting.Tags(childComplexity), true

	case "GroupSetting.updatedAt":
		if e.complexity.GroupSetting.UpdatedAt == nil {
			break
		}

		return e.complexity.GroupSetting.UpdatedAt(childComplexity), true

	case "GroupSetting.updatedBy":
		if e.complexity.GroupSetting.UpdatedBy == nil {
			break
		}

		return e.complexity.GroupSetting.UpdatedBy(childComplexity), true

	case "GroupSetting.visibility":
		if e.complexity.GroupSetting.Visibility == nil {
			break
		}

		return e.complexity.GroupSetting.Visibility(childComplexity), true

	case "GroupSettingConnection.edges":
		if e.complexity.GroupSettingConnection.Edges == nil {
			break
		}

		return e.complexity.GroupSettingConnection.Edges(childComplexity), true

	case "GroupSettingConnection.pageInfo":
		if e.complexity.GroupSettingConnection.PageInfo == nil {
			break
		}

		return e.complexity.GroupSettingConnection.PageInfo(childComplexity), true

	case "GroupSettingConnection.totalCount":
		if e.complexity.GroupSettingConnection.TotalCount == nil {
			break
		}

		return e.complexity.GroupSettingConnection.TotalCount(childComplexity), true

	case "GroupSettingCreatePayload.groupSetting":
		if e.complexity.GroupSettingCreatePayload.GroupSetting == nil {
			break
		}

		return e.complexity.GroupSettingCreatePayload.GroupSetting(childComplexity), true

	case "GroupSettingDeletePayload.deletedID":
		if e.complexity.GroupSettingDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.GroupSettingDeletePayload.DeletedID(childComplexity), true

	case "GroupSettingEdge.cursor":
		if e.complexity.GroupSettingEdge.Cursor == nil {
			break
		}

		return e.complexity.GroupSettingEdge.Cursor(childComplexity), true

	case "GroupSettingEdge.node":
		if e.complexity.GroupSettingEdge.Node == nil {
			break
		}

		return e.complexity.GroupSettingEdge.Node(childComplexity), true

	case "GroupSettingUpdatePayload.groupSetting":
		if e.complexity.GroupSettingUpdatePayload.GroupSetting == nil {
			break
		}

		return e.complexity.GroupSettingUpdatePayload.GroupSetting(childComplexity), true

	case "GroupUpdatePayload.group":
		if e.complexity.GroupUpdatePayload.Group == nil {
			break
		}

		return e.complexity.GroupUpdatePayload.Group(childComplexity), true

	case "Integration.createdAt":
		if e.complexity.Integration.CreatedAt == nil {
			break
		}

		return e.complexity.Integration.CreatedAt(childComplexity), true

	case "Integration.createdBy":
		if e.complexity.Integration.CreatedBy == nil {
			break
		}

		return e.complexity.Integration.CreatedBy(childComplexity), true

	case "Integration.deletedAt":
		if e.complexity.Integration.DeletedAt == nil {
			break
		}

		return e.complexity.Integration.DeletedAt(childComplexity), true

	case "Integration.deletedBy":
		if e.complexity.Integration.DeletedBy == nil {
			break
		}

		return e.complexity.Integration.DeletedBy(childComplexity), true

	case "Integration.description":
		if e.complexity.Integration.Description == nil {
			break
		}

		return e.complexity.Integration.Description(childComplexity), true

	case "Integration.id":
		if e.complexity.Integration.ID == nil {
			break
		}

		return e.complexity.Integration.ID(childComplexity), true

	case "Integration.kind":
		if e.complexity.Integration.Kind == nil {
			break
		}

		return e.complexity.Integration.Kind(childComplexity), true

	case "Integration.name":
		if e.complexity.Integration.Name == nil {
			break
		}

		return e.complexity.Integration.Name(childComplexity), true

	case "Integration.owner":
		if e.complexity.Integration.Owner == nil {
			break
		}

		return e.complexity.Integration.Owner(childComplexity), true

	case "Integration.secretName":
		if e.complexity.Integration.SecretName == nil {
			break
		}

		return e.complexity.Integration.SecretName(childComplexity), true

	case "Integration.updatedAt":
		if e.complexity.Integration.UpdatedAt == nil {
			break
		}

		return e.complexity.Integration.UpdatedAt(childComplexity), true

	case "Integration.updatedBy":
		if e.complexity.Integration.UpdatedBy == nil {
			break
		}

		return e.complexity.Integration.UpdatedBy(childComplexity), true

	case "IntegrationConnection.edges":
		if e.complexity.IntegrationConnection.Edges == nil {
			break
		}

		return e.complexity.IntegrationConnection.Edges(childComplexity), true

	case "IntegrationConnection.pageInfo":
		if e.complexity.IntegrationConnection.PageInfo == nil {
			break
		}

		return e.complexity.IntegrationConnection.PageInfo(childComplexity), true

	case "IntegrationConnection.totalCount":
		if e.complexity.IntegrationConnection.TotalCount == nil {
			break
		}

		return e.complexity.IntegrationConnection.TotalCount(childComplexity), true

	case "IntegrationCreatePayload.integration":
		if e.complexity.IntegrationCreatePayload.Integration == nil {
			break
		}

		return e.complexity.IntegrationCreatePayload.Integration(childComplexity), true

	case "IntegrationDeletePayload.deletedID":
		if e.complexity.IntegrationDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.IntegrationDeletePayload.DeletedID(childComplexity), true

	case "IntegrationEdge.cursor":
		if e.complexity.IntegrationEdge.Cursor == nil {
			break
		}

		return e.complexity.IntegrationEdge.Cursor(childComplexity), true

	case "IntegrationEdge.node":
		if e.complexity.IntegrationEdge.Node == nil {
			break
		}

		return e.complexity.IntegrationEdge.Node(childComplexity), true

	case "IntegrationUpdatePayload.integration":
		if e.complexity.IntegrationUpdatePayload.Integration == nil {
			break
		}

		return e.complexity.IntegrationUpdatePayload.Integration(childComplexity), true

	case "Mutation.createEntitlement":
		if e.complexity.Mutation.CreateEntitlement == nil {
			break
		}

		args, err := ec.field_Mutation_createEntitlement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEntitlement(childComplexity, args["input"].(generated.CreateEntitlementInput)), true

	case "Mutation.createGroup":
		if e.complexity.Mutation.CreateGroup == nil {
			break
		}

		args, err := ec.field_Mutation_createGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGroup(childComplexity, args["input"].(generated.CreateGroupInput)), true

	case "Mutation.createGroupSetting":
		if e.complexity.Mutation.CreateGroupSetting == nil {
			break
		}

		args, err := ec.field_Mutation_createGroupSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateGroupSetting(childComplexity, args["input"].(generated.CreateGroupSettingInput)), true

	case "Mutation.createIntegration":
		if e.complexity.Mutation.CreateIntegration == nil {
			break
		}

		args, err := ec.field_Mutation_createIntegration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateIntegration(childComplexity, args["input"].(generated.CreateIntegrationInput)), true

	case "Mutation.createOauthProvider":
		if e.complexity.Mutation.CreateOauthProvider == nil {
			break
		}

		args, err := ec.field_Mutation_createOauthProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOauthProvider(childComplexity, args["input"].(generated.CreateOauthProviderInput)), true

	case "Mutation.createOhAuthTooToken":
		if e.complexity.Mutation.CreateOhAuthTooToken == nil {
			break
		}

		args, err := ec.field_Mutation_createOhAuthTooToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOhAuthTooToken(childComplexity, args["input"].(generated.CreateOhAuthTooTokenInput)), true

	case "Mutation.createOrganization":
		if e.complexity.Mutation.CreateOrganization == nil {
			break
		}

		args, err := ec.field_Mutation_createOrganization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrganization(childComplexity, args["input"].(generated.CreateOrganizationInput)), true

	case "Mutation.createOrganizationSetting":
		if e.complexity.Mutation.CreateOrganizationSetting == nil {
			break
		}

		args, err := ec.field_Mutation_createOrganizationSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrganizationSetting(childComplexity, args["input"].(generated.CreateOrganizationSettingInput)), true

	case "Mutation.createPersonalAccessToken":
		if e.complexity.Mutation.CreatePersonalAccessToken == nil {
			break
		}

		args, err := ec.field_Mutation_createPersonalAccessToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePersonalAccessToken(childComplexity, args["input"].(generated.CreatePersonalAccessTokenInput)), true

	case "Mutation.createSession":
		if e.complexity.Mutation.CreateSession == nil {
			break
		}

		args, err := ec.field_Mutation_createSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSession(childComplexity, args["input"].(generated.CreateSessionInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(generated.CreateUserInput)), true

	case "Mutation.createUserSetting":
		if e.complexity.Mutation.CreateUserSetting == nil {
			break
		}

		args, err := ec.field_Mutation_createUserSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserSetting(childComplexity, args["input"].(generated.CreateUserSettingInput)), true

	case "Mutation.deleteEntitlement":
		if e.complexity.Mutation.DeleteEntitlement == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEntitlement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEntitlement(childComplexity, args["id"].(string)), true

	case "Mutation.deleteGroup":
		if e.complexity.Mutation.DeleteGroup == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGroup(childComplexity, args["id"].(string)), true

	case "Mutation.deleteGroupSetting":
		if e.complexity.Mutation.DeleteGroupSetting == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGroupSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGroupSetting(childComplexity, args["id"].(string)), true

	case "Mutation.deleteIntegration":
		if e.complexity.Mutation.DeleteIntegration == nil {
			break
		}

		args, err := ec.field_Mutation_deleteIntegration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteIntegration(childComplexity, args["id"].(string)), true

	case "Mutation.deleteOauthProvider":
		if e.complexity.Mutation.DeleteOauthProvider == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOauthProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOauthProvider(childComplexity, args["id"].(string)), true

	case "Mutation.deleteOhAuthTooToken":
		if e.complexity.Mutation.DeleteOhAuthTooToken == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOhAuthTooToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOhAuthTooToken(childComplexity, args["id"].(string)), true

	case "Mutation.deleteOrganization":
		if e.complexity.Mutation.DeleteOrganization == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOrganization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOrganization(childComplexity, args["id"].(string)), true

	case "Mutation.deleteOrganizationSetting":
		if e.complexity.Mutation.DeleteOrganizationSetting == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOrganizationSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOrganizationSetting(childComplexity, args["id"].(string)), true

	case "Mutation.deletePersonalAccessToken":
		if e.complexity.Mutation.DeletePersonalAccessToken == nil {
			break
		}

		args, err := ec.field_Mutation_deletePersonalAccessToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePersonalAccessToken(childComplexity, args["id"].(string)), true

	case "Mutation.deleteSession":
		if e.complexity.Mutation.DeleteSession == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSession(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUserSetting":
		if e.complexity.Mutation.DeleteUserSetting == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUserSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUserSetting(childComplexity, args["id"].(string)), true

	case "Mutation.updateEntitlement":
		if e.complexity.Mutation.UpdateEntitlement == nil {
			break
		}

		args, err := ec.field_Mutation_updateEntitlement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEntitlement(childComplexity, args["id"].(string), args["input"].(generated.UpdateEntitlementInput)), true

	case "Mutation.updateGroup":
		if e.complexity.Mutation.UpdateGroup == nil {
			break
		}

		args, err := ec.field_Mutation_updateGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGroup(childComplexity, args["id"].(string), args["input"].(generated.UpdateGroupInput)), true

	case "Mutation.updateGroupSetting":
		if e.complexity.Mutation.UpdateGroupSetting == nil {
			break
		}

		args, err := ec.field_Mutation_updateGroupSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateGroupSetting(childComplexity, args["id"].(string), args["input"].(generated.UpdateGroupSettingInput)), true

	case "Mutation.updateIntegration":
		if e.complexity.Mutation.UpdateIntegration == nil {
			break
		}

		args, err := ec.field_Mutation_updateIntegration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateIntegration(childComplexity, args["id"].(string), args["input"].(generated.UpdateIntegrationInput)), true

	case "Mutation.updateOauthProvider":
		if e.complexity.Mutation.UpdateOauthProvider == nil {
			break
		}

		args, err := ec.field_Mutation_updateOauthProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOauthProvider(childComplexity, args["id"].(string), args["input"].(generated.UpdateOauthProviderInput)), true

	case "Mutation.updateOhAuthTooToken":
		if e.complexity.Mutation.UpdateOhAuthTooToken == nil {
			break
		}

		args, err := ec.field_Mutation_updateOhAuthTooToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOhAuthTooToken(childComplexity, args["id"].(string), args["input"].(generated.UpdateOhAuthTooTokenInput)), true

	case "Mutation.updateOrganization":
		if e.complexity.Mutation.UpdateOrganization == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrganization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrganization(childComplexity, args["id"].(string), args["input"].(generated.UpdateOrganizationInput)), true

	case "Mutation.updateOrganizationSetting":
		if e.complexity.Mutation.UpdateOrganizationSetting == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrganizationSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrganizationSetting(childComplexity, args["id"].(string), args["input"].(generated.UpdateOrganizationSettingInput)), true

	case "Mutation.updatePersonalAccessToken":
		if e.complexity.Mutation.UpdatePersonalAccessToken == nil {
			break
		}

		args, err := ec.field_Mutation_updatePersonalAccessToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePersonalAccessToken(childComplexity, args["id"].(string), args["input"].(generated.UpdatePersonalAccessTokenInput)), true

	case "Mutation.updateSession":
		if e.complexity.Mutation.UpdateSession == nil {
			break
		}

		args, err := ec.field_Mutation_updateSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSession(childComplexity, args["id"].(string), args["input"].(generated.UpdateSessionInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(string), args["input"].(generated.UpdateUserInput)), true

	case "Mutation.updateUserSetting":
		if e.complexity.Mutation.UpdateUserSetting == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserSetting(childComplexity, args["id"].(string), args["input"].(generated.UpdateUserSettingInput)), true

	case "OauthProvider.authStyle":
		if e.complexity.OauthProvider.AuthStyle == nil {
			break
		}

		return e.complexity.OauthProvider.AuthStyle(childComplexity), true

	case "OauthProvider.authURL":
		if e.complexity.OauthProvider.AuthURL == nil {
			break
		}

		return e.complexity.OauthProvider.AuthURL(childComplexity), true

	case "OauthProvider.clientID":
		if e.complexity.OauthProvider.ClientID == nil {
			break
		}

		return e.complexity.OauthProvider.ClientID(childComplexity), true

	case "OauthProvider.clientSecret":
		if e.complexity.OauthProvider.ClientSecret == nil {
			break
		}

		return e.complexity.OauthProvider.ClientSecret(childComplexity), true

	case "OauthProvider.createdAt":
		if e.complexity.OauthProvider.CreatedAt == nil {
			break
		}

		return e.complexity.OauthProvider.CreatedAt(childComplexity), true

	case "OauthProvider.createdBy":
		if e.complexity.OauthProvider.CreatedBy == nil {
			break
		}

		return e.complexity.OauthProvider.CreatedBy(childComplexity), true

	case "OauthProvider.deletedAt":
		if e.complexity.OauthProvider.DeletedAt == nil {
			break
		}

		return e.complexity.OauthProvider.DeletedAt(childComplexity), true

	case "OauthProvider.deletedBy":
		if e.complexity.OauthProvider.DeletedBy == nil {
			break
		}

		return e.complexity.OauthProvider.DeletedBy(childComplexity), true

	case "OauthProvider.id":
		if e.complexity.OauthProvider.ID == nil {
			break
		}

		return e.complexity.OauthProvider.ID(childComplexity), true

	case "OauthProvider.infoURL":
		if e.complexity.OauthProvider.InfoURL == nil {
			break
		}

		return e.complexity.OauthProvider.InfoURL(childComplexity), true

	case "OauthProvider.name":
		if e.complexity.OauthProvider.Name == nil {
			break
		}

		return e.complexity.OauthProvider.Name(childComplexity), true

	case "OauthProvider.owner":
		if e.complexity.OauthProvider.Owner == nil {
			break
		}

		return e.complexity.OauthProvider.Owner(childComplexity), true

	case "OauthProvider.redirectURL":
		if e.complexity.OauthProvider.RedirectURL == nil {
			break
		}

		return e.complexity.OauthProvider.RedirectURL(childComplexity), true

	case "OauthProvider.scopes":
		if e.complexity.OauthProvider.Scopes == nil {
			break
		}

		return e.complexity.OauthProvider.Scopes(childComplexity), true

	case "OauthProvider.tokenURL":
		if e.complexity.OauthProvider.TokenURL == nil {
			break
		}

		return e.complexity.OauthProvider.TokenURL(childComplexity), true

	case "OauthProvider.updatedAt":
		if e.complexity.OauthProvider.UpdatedAt == nil {
			break
		}

		return e.complexity.OauthProvider.UpdatedAt(childComplexity), true

	case "OauthProvider.updatedBy":
		if e.complexity.OauthProvider.UpdatedBy == nil {
			break
		}

		return e.complexity.OauthProvider.UpdatedBy(childComplexity), true

	case "OauthProviderConnection.edges":
		if e.complexity.OauthProviderConnection.Edges == nil {
			break
		}

		return e.complexity.OauthProviderConnection.Edges(childComplexity), true

	case "OauthProviderConnection.pageInfo":
		if e.complexity.OauthProviderConnection.PageInfo == nil {
			break
		}

		return e.complexity.OauthProviderConnection.PageInfo(childComplexity), true

	case "OauthProviderConnection.totalCount":
		if e.complexity.OauthProviderConnection.TotalCount == nil {
			break
		}

		return e.complexity.OauthProviderConnection.TotalCount(childComplexity), true

	case "OauthProviderCreatePayload.OauthProvider":
		if e.complexity.OauthProviderCreatePayload.OauthProvider == nil {
			break
		}

		return e.complexity.OauthProviderCreatePayload.OauthProvider(childComplexity), true

	case "OauthProviderDeletePayload.deletedID":
		if e.complexity.OauthProviderDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.OauthProviderDeletePayload.DeletedID(childComplexity), true

	case "OauthProviderEdge.cursor":
		if e.complexity.OauthProviderEdge.Cursor == nil {
			break
		}

		return e.complexity.OauthProviderEdge.Cursor(childComplexity), true

	case "OauthProviderEdge.node":
		if e.complexity.OauthProviderEdge.Node == nil {
			break
		}

		return e.complexity.OauthProviderEdge.Node(childComplexity), true

	case "OauthProviderUpdatePayload.OauthProvider":
		if e.complexity.OauthProviderUpdatePayload.OauthProvider == nil {
			break
		}

		return e.complexity.OauthProviderUpdatePayload.OauthProvider(childComplexity), true

	case "OhAuthTooToken.claimsEmail":
		if e.complexity.OhAuthTooToken.ClaimsEmail == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClaimsEmail(childComplexity), true

	case "OhAuthTooToken.claimsEmailVerified":
		if e.complexity.OhAuthTooToken.ClaimsEmailVerified == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClaimsEmailVerified(childComplexity), true

	case "OhAuthTooToken.claimsGroups":
		if e.complexity.OhAuthTooToken.ClaimsGroups == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClaimsGroups(childComplexity), true

	case "OhAuthTooToken.claimsPreferredUsername":
		if e.complexity.OhAuthTooToken.ClaimsPreferredUsername == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClaimsPreferredUsername(childComplexity), true

	case "OhAuthTooToken.claimsUserID":
		if e.complexity.OhAuthTooToken.ClaimsUserID == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClaimsUserID(childComplexity), true

	case "OhAuthTooToken.claimsUsername":
		if e.complexity.OhAuthTooToken.ClaimsUsername == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClaimsUsername(childComplexity), true

	case "OhAuthTooToken.clientID":
		if e.complexity.OhAuthTooToken.ClientID == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ClientID(childComplexity), true

	case "OhAuthTooToken.connectorData":
		if e.complexity.OhAuthTooToken.ConnectorData == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ConnectorData(childComplexity), true

	case "OhAuthTooToken.connectorID":
		if e.complexity.OhAuthTooToken.ConnectorID == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ConnectorID(childComplexity), true

	case "OhAuthTooToken.id":
		if e.complexity.OhAuthTooToken.ID == nil {
			break
		}

		return e.complexity.OhAuthTooToken.ID(childComplexity), true

	case "OhAuthTooToken.lastUsed":
		if e.complexity.OhAuthTooToken.LastUsed == nil {
			break
		}

		return e.complexity.OhAuthTooToken.LastUsed(childComplexity), true

	case "OhAuthTooToken.nonce":
		if e.complexity.OhAuthTooToken.Nonce == nil {
			break
		}

		return e.complexity.OhAuthTooToken.Nonce(childComplexity), true

	case "OhAuthTooToken.scopes":
		if e.complexity.OhAuthTooToken.Scopes == nil {
			break
		}

		return e.complexity.OhAuthTooToken.Scopes(childComplexity), true

	case "OhAuthTooTokenConnection.edges":
		if e.complexity.OhAuthTooTokenConnection.Edges == nil {
			break
		}

		return e.complexity.OhAuthTooTokenConnection.Edges(childComplexity), true

	case "OhAuthTooTokenConnection.pageInfo":
		if e.complexity.OhAuthTooTokenConnection.PageInfo == nil {
			break
		}

		return e.complexity.OhAuthTooTokenConnection.PageInfo(childComplexity), true

	case "OhAuthTooTokenConnection.totalCount":
		if e.complexity.OhAuthTooTokenConnection.TotalCount == nil {
			break
		}

		return e.complexity.OhAuthTooTokenConnection.TotalCount(childComplexity), true

	case "OhAuthTooTokenCreatePayload.ohAuthTooToken":
		if e.complexity.OhAuthTooTokenCreatePayload.OhAuthTooToken == nil {
			break
		}

		return e.complexity.OhAuthTooTokenCreatePayload.OhAuthTooToken(childComplexity), true

	case "OhAuthTooTokenDeletePayload.deletedID":
		if e.complexity.OhAuthTooTokenDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.OhAuthTooTokenDeletePayload.DeletedID(childComplexity), true

	case "OhAuthTooTokenEdge.cursor":
		if e.complexity.OhAuthTooTokenEdge.Cursor == nil {
			break
		}

		return e.complexity.OhAuthTooTokenEdge.Cursor(childComplexity), true

	case "OhAuthTooTokenEdge.node":
		if e.complexity.OhAuthTooTokenEdge.Node == nil {
			break
		}

		return e.complexity.OhAuthTooTokenEdge.Node(childComplexity), true

	case "OhAuthTooTokenUpdatePayload.ohAuthTooToken":
		if e.complexity.OhAuthTooTokenUpdatePayload.OhAuthTooToken == nil {
			break
		}

		return e.complexity.OhAuthTooTokenUpdatePayload.OhAuthTooToken(childComplexity), true

	case "Organization.children":
		if e.complexity.Organization.Children == nil {
			break
		}

		args, err := ec.field_Organization_children_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Organization.Children(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*generated.OrganizationOrder), args["where"].(*generated.OrganizationWhereInput)), true

	case "Organization.createdAt":
		if e.complexity.Organization.CreatedAt == nil {
			break
		}

		return e.complexity.Organization.CreatedAt(childComplexity), true

	case "Organization.createdBy":
		if e.complexity.Organization.CreatedBy == nil {
			break
		}

		return e.complexity.Organization.CreatedBy(childComplexity), true

	case "Organization.deletedAt":
		if e.complexity.Organization.DeletedAt == nil {
			break
		}

		return e.complexity.Organization.DeletedAt(childComplexity), true

	case "Organization.deletedBy":
		if e.complexity.Organization.DeletedBy == nil {
			break
		}

		return e.complexity.Organization.DeletedBy(childComplexity), true

	case "Organization.description":
		if e.complexity.Organization.Description == nil {
			break
		}

		return e.complexity.Organization.Description(childComplexity), true

	case "Organization.displayName":
		if e.complexity.Organization.DisplayName == nil {
			break
		}

		return e.complexity.Organization.DisplayName(childComplexity), true

	case "Organization.entitlements":
		if e.complexity.Organization.Entitlements == nil {
			break
		}

		return e.complexity.Organization.Entitlements(childComplexity), true

	case "Organization.groups":
		if e.complexity.Organization.Groups == nil {
			break
		}

		return e.complexity.Organization.Groups(childComplexity), true

	case "Organization.id":
		if e.complexity.Organization.ID == nil {
			break
		}

		return e.complexity.Organization.ID(childComplexity), true

	case "Organization.integrations":
		if e.complexity.Organization.Integrations == nil {
			break
		}

		return e.complexity.Organization.Integrations(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Organization.oauthprovider":
		if e.complexity.Organization.Oauthprovider == nil {
			break
		}

		return e.complexity.Organization.Oauthprovider(childComplexity), true

	case "Organization.parent":
		if e.complexity.Organization.Parent == nil {
			break
		}

		return e.complexity.Organization.Parent(childComplexity), true

	case "Organization.personalOrg":
		if e.complexity.Organization.PersonalOrg == nil {
			break
		}

		return e.complexity.Organization.PersonalOrg(childComplexity), true

	case "Organization.setting":
		if e.complexity.Organization.Setting == nil {
			break
		}

		return e.complexity.Organization.Setting(childComplexity), true

	case "Organization.updatedAt":
		if e.complexity.Organization.UpdatedAt == nil {
			break
		}

		return e.complexity.Organization.UpdatedAt(childComplexity), true

	case "Organization.updatedBy":
		if e.complexity.Organization.UpdatedBy == nil {
			break
		}

		return e.complexity.Organization.UpdatedBy(childComplexity), true

	case "Organization.users":
		if e.complexity.Organization.Users == nil {
			break
		}

		return e.complexity.Organization.Users(childComplexity), true

	case "OrganizationConnection.edges":
		if e.complexity.OrganizationConnection.Edges == nil {
			break
		}

		return e.complexity.OrganizationConnection.Edges(childComplexity), true

	case "OrganizationConnection.pageInfo":
		if e.complexity.OrganizationConnection.PageInfo == nil {
			break
		}

		return e.complexity.OrganizationConnection.PageInfo(childComplexity), true

	case "OrganizationConnection.totalCount":
		if e.complexity.OrganizationConnection.TotalCount == nil {
			break
		}

		return e.complexity.OrganizationConnection.TotalCount(childComplexity), true

	case "OrganizationCreatePayload.organization":
		if e.complexity.OrganizationCreatePayload.Organization == nil {
			break
		}

		return e.complexity.OrganizationCreatePayload.Organization(childComplexity), true

	case "OrganizationDeletePayload.deletedID":
		if e.complexity.OrganizationDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.OrganizationDeletePayload.DeletedID(childComplexity), true

	case "OrganizationEdge.cursor":
		if e.complexity.OrganizationEdge.Cursor == nil {
			break
		}

		return e.complexity.OrganizationEdge.Cursor(childComplexity), true

	case "OrganizationEdge.node":
		if e.complexity.OrganizationEdge.Node == nil {
			break
		}

		return e.complexity.OrganizationEdge.Node(childComplexity), true

	case "OrganizationSetting.billingAddress":
		if e.complexity.OrganizationSetting.BillingAddress == nil {
			break
		}

		return e.complexity.OrganizationSetting.BillingAddress(childComplexity), true

	case "OrganizationSetting.billingContact":
		if e.complexity.OrganizationSetting.BillingContact == nil {
			break
		}

		return e.complexity.OrganizationSetting.BillingContact(childComplexity), true

	case "OrganizationSetting.billingEmail":
		if e.complexity.OrganizationSetting.BillingEmail == nil {
			break
		}

		return e.complexity.OrganizationSetting.BillingEmail(childComplexity), true

	case "OrganizationSetting.billingPhone":
		if e.complexity.OrganizationSetting.BillingPhone == nil {
			break
		}

		return e.complexity.OrganizationSetting.BillingPhone(childComplexity), true

	case "OrganizationSetting.createdAt":
		if e.complexity.OrganizationSetting.CreatedAt == nil {
			break
		}

		return e.complexity.OrganizationSetting.CreatedAt(childComplexity), true

	case "OrganizationSetting.createdBy":
		if e.complexity.OrganizationSetting.CreatedBy == nil {
			break
		}

		return e.complexity.OrganizationSetting.CreatedBy(childComplexity), true

	case "OrganizationSetting.deletedAt":
		if e.complexity.OrganizationSetting.DeletedAt == nil {
			break
		}

		return e.complexity.OrganizationSetting.DeletedAt(childComplexity), true

	case "OrganizationSetting.deletedBy":
		if e.complexity.OrganizationSetting.DeletedBy == nil {
			break
		}

		return e.complexity.OrganizationSetting.DeletedBy(childComplexity), true

	case "OrganizationSetting.domains":
		if e.complexity.OrganizationSetting.Domains == nil {
			break
		}

		return e.complexity.OrganizationSetting.Domains(childComplexity), true

	case "OrganizationSetting.id":
		if e.complexity.OrganizationSetting.ID == nil {
			break
		}

		return e.complexity.OrganizationSetting.ID(childComplexity), true

	case "OrganizationSetting.organization":
		if e.complexity.OrganizationSetting.Organization == nil {
			break
		}

		return e.complexity.OrganizationSetting.Organization(childComplexity), true

	case "OrganizationSetting.ssoCert":
		if e.complexity.OrganizationSetting.SSOCert == nil {
			break
		}

		return e.complexity.OrganizationSetting.SSOCert(childComplexity), true

	case "OrganizationSetting.ssoEntrypoint":
		if e.complexity.OrganizationSetting.SSOEntrypoint == nil {
			break
		}

		return e.complexity.OrganizationSetting.SSOEntrypoint(childComplexity), true

	case "OrganizationSetting.ssoIssuer":
		if e.complexity.OrganizationSetting.SSOIssuer == nil {
			break
		}

		return e.complexity.OrganizationSetting.SSOIssuer(childComplexity), true

	case "OrganizationSetting.tags":
		if e.complexity.OrganizationSetting.Tags == nil {
			break
		}

		return e.complexity.OrganizationSetting.Tags(childComplexity), true

	case "OrganizationSetting.taxIdentifier":
		if e.complexity.OrganizationSetting.TaxIdentifier == nil {
			break
		}

		return e.complexity.OrganizationSetting.TaxIdentifier(childComplexity), true

	case "OrganizationSetting.updatedAt":
		if e.complexity.OrganizationSetting.UpdatedAt == nil {
			break
		}

		return e.complexity.OrganizationSetting.UpdatedAt(childComplexity), true

	case "OrganizationSetting.updatedBy":
		if e.complexity.OrganizationSetting.UpdatedBy == nil {
			break
		}

		return e.complexity.OrganizationSetting.UpdatedBy(childComplexity), true

	case "OrganizationSettingConnection.edges":
		if e.complexity.OrganizationSettingConnection.Edges == nil {
			break
		}

		return e.complexity.OrganizationSettingConnection.Edges(childComplexity), true

	case "OrganizationSettingConnection.pageInfo":
		if e.complexity.OrganizationSettingConnection.PageInfo == nil {
			break
		}

		return e.complexity.OrganizationSettingConnection.PageInfo(childComplexity), true

	case "OrganizationSettingConnection.totalCount":
		if e.complexity.OrganizationSettingConnection.TotalCount == nil {
			break
		}

		return e.complexity.OrganizationSettingConnection.TotalCount(childComplexity), true

	case "OrganizationSettingCreatePayload.organizationSetting":
		if e.complexity.OrganizationSettingCreatePayload.OrganizationSetting == nil {
			break
		}

		return e.complexity.OrganizationSettingCreatePayload.OrganizationSetting(childComplexity), true

	case "OrganizationSettingDeletePayload.deletedID":
		if e.complexity.OrganizationSettingDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.OrganizationSettingDeletePayload.DeletedID(childComplexity), true

	case "OrganizationSettingEdge.cursor":
		if e.complexity.OrganizationSettingEdge.Cursor == nil {
			break
		}

		return e.complexity.OrganizationSettingEdge.Cursor(childComplexity), true

	case "OrganizationSettingEdge.node":
		if e.complexity.OrganizationSettingEdge.Node == nil {
			break
		}

		return e.complexity.OrganizationSettingEdge.Node(childComplexity), true

	case "OrganizationSettingUpdatePayload.organizationSetting":
		if e.complexity.OrganizationSettingUpdatePayload.OrganizationSetting == nil {
			break
		}

		return e.complexity.OrganizationSettingUpdatePayload.OrganizationSetting(childComplexity), true

	case "OrganizationUpdatePayload.organization":
		if e.complexity.OrganizationUpdatePayload.Organization == nil {
			break
		}

		return e.complexity.OrganizationUpdatePayload.Organization(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PersonalAccessToken.abilities":
		if e.complexity.PersonalAccessToken.Abilities == nil {
			break
		}

		return e.complexity.PersonalAccessToken.Abilities(childComplexity), true

	case "PersonalAccessToken.createdAt":
		if e.complexity.PersonalAccessToken.CreatedAt == nil {
			break
		}

		return e.complexity.PersonalAccessToken.CreatedAt(childComplexity), true

	case "PersonalAccessToken.createdBy":
		if e.complexity.PersonalAccessToken.CreatedBy == nil {
			break
		}

		return e.complexity.PersonalAccessToken.CreatedBy(childComplexity), true

	case "PersonalAccessToken.deletedAt":
		if e.complexity.PersonalAccessToken.DeletedAt == nil {
			break
		}

		return e.complexity.PersonalAccessToken.DeletedAt(childComplexity), true

	case "PersonalAccessToken.deletedBy":
		if e.complexity.PersonalAccessToken.DeletedBy == nil {
			break
		}

		return e.complexity.PersonalAccessToken.DeletedBy(childComplexity), true

	case "PersonalAccessToken.description":
		if e.complexity.PersonalAccessToken.Description == nil {
			break
		}

		return e.complexity.PersonalAccessToken.Description(childComplexity), true

	case "PersonalAccessToken.expiresAt":
		if e.complexity.PersonalAccessToken.ExpiresAt == nil {
			break
		}

		return e.complexity.PersonalAccessToken.ExpiresAt(childComplexity), true

	case "PersonalAccessToken.id":
		if e.complexity.PersonalAccessToken.ID == nil {
			break
		}

		return e.complexity.PersonalAccessToken.ID(childComplexity), true

	case "PersonalAccessToken.lastUsedAt":
		if e.complexity.PersonalAccessToken.LastUsedAt == nil {
			break
		}

		return e.complexity.PersonalAccessToken.LastUsedAt(childComplexity), true

	case "PersonalAccessToken.name":
		if e.complexity.PersonalAccessToken.Name == nil {
			break
		}

		return e.complexity.PersonalAccessToken.Name(childComplexity), true

	case "PersonalAccessToken.owner":
		if e.complexity.PersonalAccessToken.Owner == nil {
			break
		}

		return e.complexity.PersonalAccessToken.Owner(childComplexity), true

	case "PersonalAccessToken.updatedAt":
		if e.complexity.PersonalAccessToken.UpdatedAt == nil {
			break
		}

		return e.complexity.PersonalAccessToken.UpdatedAt(childComplexity), true

	case "PersonalAccessToken.updatedBy":
		if e.complexity.PersonalAccessToken.UpdatedBy == nil {
			break
		}

		return e.complexity.PersonalAccessToken.UpdatedBy(childComplexity), true

	case "PersonalAccessTokenConnection.edges":
		if e.complexity.PersonalAccessTokenConnection.Edges == nil {
			break
		}

		return e.complexity.PersonalAccessTokenConnection.Edges(childComplexity), true

	case "PersonalAccessTokenConnection.pageInfo":
		if e.complexity.PersonalAccessTokenConnection.PageInfo == nil {
			break
		}

		return e.complexity.PersonalAccessTokenConnection.PageInfo(childComplexity), true

	case "PersonalAccessTokenConnection.totalCount":
		if e.complexity.PersonalAccessTokenConnection.TotalCount == nil {
			break
		}

		return e.complexity.PersonalAccessTokenConnection.TotalCount(childComplexity), true

	case "PersonalAccessTokenCreatePayload.PersonalAccessToken":
		if e.complexity.PersonalAccessTokenCreatePayload.PersonalAccessToken == nil {
			break
		}

		return e.complexity.PersonalAccessTokenCreatePayload.PersonalAccessToken(childComplexity), true

	case "PersonalAccessTokenDeletePayload.deletedID":
		if e.complexity.PersonalAccessTokenDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.PersonalAccessTokenDeletePayload.DeletedID(childComplexity), true

	case "PersonalAccessTokenEdge.cursor":
		if e.complexity.PersonalAccessTokenEdge.Cursor == nil {
			break
		}

		return e.complexity.PersonalAccessTokenEdge.Cursor(childComplexity), true

	case "PersonalAccessTokenEdge.node":
		if e.complexity.PersonalAccessTokenEdge.Node == nil {
			break
		}

		return e.complexity.PersonalAccessTokenEdge.Node(childComplexity), true

	case "PersonalAccessTokenUpdatePayload.PersonalAccessToken":
		if e.complexity.PersonalAccessTokenUpdatePayload.PersonalAccessToken == nil {
			break
		}

		return e.complexity.PersonalAccessTokenUpdatePayload.PersonalAccessToken(childComplexity), true

	case "Query.entitlement":
		if e.complexity.Query.Entitlement == nil {
			break
		}

		args, err := ec.field_Query_entitlement_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Entitlement(childComplexity, args["id"].(string)), true

	case "Query.entitlements":
		if e.complexity.Query.Entitlements == nil {
			break
		}

		args, err := ec.field_Query_entitlements_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Entitlements(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.EntitlementWhereInput)), true

	case "Query.group":
		if e.complexity.Query.Group == nil {
			break
		}

		args, err := ec.field_Query_group_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Group(childComplexity, args["id"].(string)), true

	case "Query.groupSetting":
		if e.complexity.Query.GroupSetting == nil {
			break
		}

		args, err := ec.field_Query_groupSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GroupSetting(childComplexity, args["id"].(string)), true

	case "Query.groupSettings":
		if e.complexity.Query.GroupSettings == nil {
			break
		}

		args, err := ec.field_Query_groupSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GroupSettings(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.GroupSettingWhereInput)), true

	case "Query.groups":
		if e.complexity.Query.Groups == nil {
			break
		}

		args, err := ec.field_Query_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Groups(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*generated.GroupOrder), args["where"].(*generated.GroupWhereInput)), true

	case "Query.integration":
		if e.complexity.Query.Integration == nil {
			break
		}

		args, err := ec.field_Query_integration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Integration(childComplexity, args["id"].(string)), true

	case "Query.integrations":
		if e.complexity.Query.Integrations == nil {
			break
		}

		args, err := ec.field_Query_integrations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Integrations(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*generated.IntegrationOrder), args["where"].(*generated.IntegrationWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Query.oauthProvider":
		if e.complexity.Query.OauthProvider == nil {
			break
		}

		args, err := ec.field_Query_oauthProvider_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OauthProvider(childComplexity, args["id"].(string)), true

	case "Query.oauthProviders":
		if e.complexity.Query.OauthProviders == nil {
			break
		}

		args, err := ec.field_Query_oauthProviders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OauthProviders(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.OauthProviderWhereInput)), true

	case "Query.ohAuthTooToken":
		if e.complexity.Query.OhAuthTooToken == nil {
			break
		}

		args, err := ec.field_Query_ohAuthTooToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OhAuthTooToken(childComplexity, args["id"].(string)), true

	case "Query.ohAuthTooTokens":
		if e.complexity.Query.OhAuthTooTokens == nil {
			break
		}

		args, err := ec.field_Query_ohAuthTooTokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OhAuthTooTokens(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.OhAuthTooTokenWhereInput)), true

	case "Query.organization":
		if e.complexity.Query.Organization == nil {
			break
		}

		args, err := ec.field_Query_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organization(childComplexity, args["id"].(string)), true

	case "Query.organizationSetting":
		if e.complexity.Query.OrganizationSetting == nil {
			break
		}

		args, err := ec.field_Query_organizationSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OrganizationSetting(childComplexity, args["id"].(string)), true

	case "Query.organizationSettings":
		if e.complexity.Query.OrganizationSettings == nil {
			break
		}

		args, err := ec.field_Query_organizationSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OrganizationSettings(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.OrganizationSettingWhereInput)), true

	case "Query.organizations":
		if e.complexity.Query.Organizations == nil {
			break
		}

		args, err := ec.field_Query_organizations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organizations(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*generated.OrganizationOrder), args["where"].(*generated.OrganizationWhereInput)), true

	case "Query.personalAccessToken":
		if e.complexity.Query.PersonalAccessToken == nil {
			break
		}

		args, err := ec.field_Query_personalAccessToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PersonalAccessToken(childComplexity, args["id"].(string)), true

	case "Query.personalAccessTokens":
		if e.complexity.Query.PersonalAccessTokens == nil {
			break
		}

		args, err := ec.field_Query_personalAccessTokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PersonalAccessTokens(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.PersonalAccessTokenWhereInput)), true

	case "Query.session":
		if e.complexity.Query.Session == nil {
			break
		}

		args, err := ec.field_Query_session_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Session(childComplexity, args["id"].(string)), true

	case "Query.sessions":
		if e.complexity.Query.Sessions == nil {
			break
		}

		args, err := ec.field_Query_sessions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sessions(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.SessionWhereInput)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query.userSetting":
		if e.complexity.Query.UserSetting == nil {
			break
		}

		args, err := ec.field_Query_userSetting_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserSetting(childComplexity, args["id"].(string)), true

	case "Query.userSettings":
		if e.complexity.Query.UserSettings == nil {
			break
		}

		args, err := ec.field_Query_userSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserSettings(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*generated.UserSettingWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*generated.UserOrder), args["where"].(*generated.UserWhereInput)), true

	case "Session.createdAt":
		if e.complexity.Session.CreatedAt == nil {
			break
		}

		return e.complexity.Session.CreatedAt(childComplexity), true

	case "Session.createdBy":
		if e.complexity.Session.CreatedBy == nil {
			break
		}

		return e.complexity.Session.CreatedBy(childComplexity), true

	case "Session.expiresAt":
		if e.complexity.Session.ExpiresAt == nil {
			break
		}

		return e.complexity.Session.ExpiresAt(childComplexity), true

	case "Session.id":
		if e.complexity.Session.ID == nil {
			break
		}

		return e.complexity.Session.ID(childComplexity), true

	case "Session.issuedAt":
		if e.complexity.Session.IssuedAt == nil {
			break
		}

		return e.complexity.Session.IssuedAt(childComplexity), true

	case "Session.organizationID":
		if e.complexity.Session.OrganizationID == nil {
			break
		}

		return e.complexity.Session.OrganizationID(childComplexity), true

	case "Session.owner":
		if e.complexity.Session.Owner == nil {
			break
		}

		return e.complexity.Session.Owner(childComplexity), true

	case "Session.sessionToken":
		if e.complexity.Session.SessionToken == nil {
			break
		}

		return e.complexity.Session.SessionToken(childComplexity), true

	case "Session.updatedAt":
		if e.complexity.Session.UpdatedAt == nil {
			break
		}

		return e.complexity.Session.UpdatedAt(childComplexity), true

	case "Session.updatedBy":
		if e.complexity.Session.UpdatedBy == nil {
			break
		}

		return e.complexity.Session.UpdatedBy(childComplexity), true

	case "Session.userID":
		if e.complexity.Session.UserID == nil {
			break
		}

		return e.complexity.Session.UserID(childComplexity), true

	case "SessionConnection.edges":
		if e.complexity.SessionConnection.Edges == nil {
			break
		}

		return e.complexity.SessionConnection.Edges(childComplexity), true

	case "SessionConnection.pageInfo":
		if e.complexity.SessionConnection.PageInfo == nil {
			break
		}

		return e.complexity.SessionConnection.PageInfo(childComplexity), true

	case "SessionConnection.totalCount":
		if e.complexity.SessionConnection.TotalCount == nil {
			break
		}

		return e.complexity.SessionConnection.TotalCount(childComplexity), true

	case "SessionCreatePayload.session":
		if e.complexity.SessionCreatePayload.Session == nil {
			break
		}

		return e.complexity.SessionCreatePayload.Session(childComplexity), true

	case "SessionDeletePayload.deletedID":
		if e.complexity.SessionDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.SessionDeletePayload.DeletedID(childComplexity), true

	case "SessionEdge.cursor":
		if e.complexity.SessionEdge.Cursor == nil {
			break
		}

		return e.complexity.SessionEdge.Cursor(childComplexity), true

	case "SessionEdge.node":
		if e.complexity.SessionEdge.Node == nil {
			break
		}

		return e.complexity.SessionEdge.Node(childComplexity), true

	case "SessionUpdatePayload.session":
		if e.complexity.SessionUpdatePayload.Session == nil {
			break
		}

		return e.complexity.SessionUpdatePayload.Session(childComplexity), true

	case "User.avatarLocalFile":
		if e.complexity.User.AvatarLocalFile == nil {
			break
		}

		return e.complexity.User.AvatarLocalFile(childComplexity), true

	case "User.avatarRemoteURL":
		if e.complexity.User.AvatarRemoteURL == nil {
			break
		}

		return e.complexity.User.AvatarRemoteURL(childComplexity), true

	case "User.avatarUpdatedAt":
		if e.complexity.User.AvatarUpdatedAt == nil {
			break
		}

		return e.complexity.User.AvatarUpdatedAt(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.createdBy":
		if e.complexity.User.CreatedBy == nil {
			break
		}

		return e.complexity.User.CreatedBy(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.deletedBy":
		if e.complexity.User.DeletedBy == nil {
			break
		}

		return e.complexity.User.DeletedBy(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.firstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.groups":
		if e.complexity.User.Groups == nil {
			break
		}

		return e.complexity.User.Groups(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.lastSeen":
		if e.complexity.User.LastSeen == nil {
			break
		}

		return e.complexity.User.LastSeen(childComplexity), true

	case "User.oauth":
		if e.complexity.User.Oauth == nil {
			break
		}

		return e.complexity.User.Oauth(childComplexity), true

	case "User.organizations":
		if e.complexity.User.Organizations == nil {
			break
		}

		return e.complexity.User.Organizations(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.personalAccessTokens":
		if e.complexity.User.PersonalAccessTokens == nil {
			break
		}

		return e.complexity.User.PersonalAccessTokens(childComplexity), true

	case "User.sessions":
		if e.complexity.User.Sessions == nil {
			break
		}

		return e.complexity.User.Sessions(childComplexity), true

	case "User.setting":
		if e.complexity.User.Setting == nil {
			break
		}

		return e.complexity.User.Setting(childComplexity), true

	case "User.sub":
		if e.complexity.User.Sub == nil {
			break
		}

		return e.complexity.User.Sub(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.updatedBy":
		if e.complexity.User.UpdatedBy == nil {
			break
		}

		return e.complexity.User.UpdatedBy(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserCreatePayload.user":
		if e.complexity.UserCreatePayload.User == nil {
			break
		}

		return e.complexity.UserCreatePayload.User(childComplexity), true

	case "UserDeletePayload.deletedID":
		if e.complexity.UserDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.UserDeletePayload.DeletedID(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserSetting.createdAt":
		if e.complexity.UserSetting.CreatedAt == nil {
			break
		}

		return e.complexity.UserSetting.CreatedAt(childComplexity), true

	case "UserSetting.createdBy":
		if e.complexity.UserSetting.CreatedBy == nil {
			break
		}

		return e.complexity.UserSetting.CreatedBy(childComplexity), true

	case "UserSetting.deletedAt":
		if e.complexity.UserSetting.DeletedAt == nil {
			break
		}

		return e.complexity.UserSetting.DeletedAt(childComplexity), true

	case "UserSetting.deletedBy":
		if e.complexity.UserSetting.DeletedBy == nil {
			break
		}

		return e.complexity.UserSetting.DeletedBy(childComplexity), true

	case "UserSetting.emailConfirmed":
		if e.complexity.UserSetting.EmailConfirmed == nil {
			break
		}

		return e.complexity.UserSetting.EmailConfirmed(childComplexity), true

	case "UserSetting.id":
		if e.complexity.UserSetting.ID == nil {
			break
		}

		return e.complexity.UserSetting.ID(childComplexity), true

	case "UserSetting.locked":
		if e.complexity.UserSetting.Locked == nil {
			break
		}

		return e.complexity.UserSetting.Locked(childComplexity), true

	case "UserSetting.permissions":
		if e.complexity.UserSetting.Permissions == nil {
			break
		}

		return e.complexity.UserSetting.Permissions(childComplexity), true

	case "UserSetting.role":
		if e.complexity.UserSetting.Role == nil {
			break
		}

		return e.complexity.UserSetting.Role(childComplexity), true

	case "UserSetting.silencedAt":
		if e.complexity.UserSetting.SilencedAt == nil {
			break
		}

		return e.complexity.UserSetting.SilencedAt(childComplexity), true

	case "UserSetting.status":
		if e.complexity.UserSetting.Status == nil {
			break
		}

		return e.complexity.UserSetting.Status(childComplexity), true

	case "UserSetting.suspendedAt":
		if e.complexity.UserSetting.SuspendedAt == nil {
			break
		}

		return e.complexity.UserSetting.SuspendedAt(childComplexity), true

	case "UserSetting.tags":
		if e.complexity.UserSetting.Tags == nil {
			break
		}

		return e.complexity.UserSetting.Tags(childComplexity), true

	case "UserSetting.updatedAt":
		if e.complexity.UserSetting.UpdatedAt == nil {
			break
		}

		return e.complexity.UserSetting.UpdatedAt(childComplexity), true

	case "UserSetting.updatedBy":
		if e.complexity.UserSetting.UpdatedBy == nil {
			break
		}

		return e.complexity.UserSetting.UpdatedBy(childComplexity), true

	case "UserSetting.user":
		if e.complexity.UserSetting.User == nil {
			break
		}

		return e.complexity.UserSetting.User(childComplexity), true

	case "UserSettingConnection.edges":
		if e.complexity.UserSettingConnection.Edges == nil {
			break
		}

		return e.complexity.UserSettingConnection.Edges(childComplexity), true

	case "UserSettingConnection.pageInfo":
		if e.complexity.UserSettingConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserSettingConnection.PageInfo(childComplexity), true

	case "UserSettingConnection.totalCount":
		if e.complexity.UserSettingConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserSettingConnection.TotalCount(childComplexity), true

	case "UserSettingCreatePayload.UserSetting":
		if e.complexity.UserSettingCreatePayload.UserSetting == nil {
			break
		}

		return e.complexity.UserSettingCreatePayload.UserSetting(childComplexity), true

	case "UserSettingDeletePayload.deletedID":
		if e.complexity.UserSettingDeletePayload.DeletedID == nil {
			break
		}

		return e.complexity.UserSettingDeletePayload.DeletedID(childComplexity), true

	case "UserSettingEdge.cursor":
		if e.complexity.UserSettingEdge.Cursor == nil {
			break
		}

		return e.complexity.UserSettingEdge.Cursor(childComplexity), true

	case "UserSettingEdge.node":
		if e.complexity.UserSettingEdge.Node == nil {
			break
		}

		return e.complexity.UserSettingEdge.Node(childComplexity), true

	case "UserSettingUpdatePayload.UserSetting":
		if e.complexity.UserSettingUpdatePayload.UserSetting == nil {
			break
		}

		return e.complexity.UserSettingUpdatePayload.UserSetting(childComplexity), true

	case "UserUpdatePayload.user":
		if e.complexity.UserUpdatePayload.User == nil {
			break
		}

		return e.complexity.UserUpdatePayload.User(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateEntitlementInput,
		ec.unmarshalInputCreateGroupInput,
		ec.unmarshalInputCreateGroupSettingInput,
		ec.unmarshalInputCreateIntegrationInput,
		ec.unmarshalInputCreateOauthProviderInput,
		ec.unmarshalInputCreateOhAuthTooTokenInput,
		ec.unmarshalInputCreateOrganizationInput,
		ec.unmarshalInputCreateOrganizationSettingInput,
		ec.unmarshalInputCreatePersonalAccessTokenInput,
		ec.unmarshalInputCreateSessionInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputCreateUserSettingInput,
		ec.unmarshalInputEntitlementWhereInput,
		ec.unmarshalInputGroupOrder,
		ec.unmarshalInputGroupSettingWhereInput,
		ec.unmarshalInputGroupWhereInput,
		ec.unmarshalInputIntegrationOrder,
		ec.unmarshalInputIntegrationWhereInput,
		ec.unmarshalInputOauthProviderWhereInput,
		ec.unmarshalInputOhAuthTooTokenWhereInput,
		ec.unmarshalInputOrganizationOrder,
		ec.unmarshalInputOrganizationSettingWhereInput,
		ec.unmarshalInputOrganizationWhereInput,
		ec.unmarshalInputPersonalAccessTokenWhereInput,
		ec.unmarshalInputSessionWhereInput,
		ec.unmarshalInputUpdateEntitlementInput,
		ec.unmarshalInputUpdateGroupInput,
		ec.unmarshalInputUpdateGroupSettingInput,
		ec.unmarshalInputUpdateIntegrationInput,
		ec.unmarshalInputUpdateOauthProviderInput,
		ec.unmarshalInputUpdateOhAuthTooTokenInput,
		ec.unmarshalInputUpdateOrganizationInput,
		ec.unmarshalInputUpdateOrganizationSettingInput,
		ec.unmarshalInputUpdatePersonalAccessTokenInput,
		ec.unmarshalInputUpdateSessionInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUpdateUserSettingInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserSettingWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreateEntitlementInput is used for create Entitlement object.
Input was generated by ent.
"""
input CreateEntitlementInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  tier: EntitlementTier
  """used to store references to external systems, e.g. Stripe"""
  externalCustomerID: String
  """used to store references to external systems, e.g. Stripe"""
  externalSubscriptionID: String
  """whether or not the customers entitlement expires - expires_at will show the time"""
  expires: Boolean
  """the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month"""
  expiresAt: Time
  """whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at"""
  cancelled: Boolean
  ownerID: ID
}
"""
CreateGroupInput is used for create Group object.
Input was generated by ent.
"""
input CreateGroupInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """the name of the group - must be unique within the organization"""
  name: String!
  """the groups description"""
  description: String
  """the URL to an auto generated gravatar image for the group"""
  gravatarLogoURL: String
  """the URL to an image uploaded by the customer for the groups avatar image"""
  logoURL: String
  """The group's displayed 'friendly' name"""
  displayName: String
  settingID: ID!
  userIDs: [ID!]
  ownerID: ID!
}
"""
CreateGroupSettingInput is used for create GroupSetting object.
Input was generated by ent.
"""
input CreateGroupSettingInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization"""
  visibility: GroupSettingVisibility
  """the policy governing ability to freely join a group, whether it requires an invitation, application, or either"""
  joinPolicy: GroupSettingJoinPolicy
  """tags associated with the object"""
  tags: [String!]
  syncToSlack: Boolean
  syncToGithub: Boolean
  groupID: ID
}
"""
CreateIntegrationInput is used for create Integration object.
Input was generated by ent.
"""
input CreateIntegrationInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """the name of the integration - must be unique within the organization"""
  name: String!
  """a description of the integration"""
  description: String
  kind: String
  secretName: String!
  ownerID: ID
}
"""
CreateOauthProviderInput is used for create OauthProvider object.
Input was generated by ent.
"""
input CreateOauthProviderInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """the oauth provider's name"""
  name: String!
  """the client id for the oauth provider"""
  clientID: String!
  """the client secret"""
  clientSecret: String!
  """the redirect url"""
  redirectURL: String!
  """the scopes"""
  scopes: String!
  """the auth url of the provider"""
  authURL: String!
  """the token url of the provider"""
  tokenURL: String!
  """the auth style, 0: auto detect 1: third party log in 2: log in with username and password"""
  authStyle: Int!
  """the URL to request user information by token"""
  infoURL: String!
  ownerID: ID
}
"""
CreateOhAuthTooTokenInput is used for create OhAuthTooToken object.
Input was generated by ent.
"""
input CreateOhAuthTooTokenInput {
  clientID: String!
  scopes: [String!]
  nonce: String!
  claimsUserID: String!
  claimsUsername: String!
  claimsEmail: String!
  claimsEmailVerified: Boolean!
  claimsGroups: [String!]
  claimsPreferredUsername: String!
  connectorID: String!
  connectorData: [String!]
  lastUsed: Time
}
"""
CreateOrganizationInput is used for create Organization object.
Input was generated by ent.
"""
input CreateOrganizationInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """the name of the organization"""
  name: String!
  """The organization's displayed 'friendly' name"""
  displayName: String
  """An optional description of the organization"""
  description: String
  """orgs directly associated with a user"""
  personalOrg: Boolean
  parentID: ID
  userIDs: [ID!]
  groupIDs: [ID!]
  integrationIDs: [ID!]
  settingID: ID
  entitlementIDs: [ID!]
  oauthproviderIDs: [ID!]
}
"""
CreateOrganizationSettingInput is used for create OrganizationSetting object.
Input was generated by ent.
"""
input CreateOrganizationSettingInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """domains associated with the organization"""
  domains: [String!]
  ssoCert: String
  ssoEntrypoint: String
  ssoIssuer: String
  """Name of the person to contact for billing"""
  billingContact: String
  billingEmail: String
  billingPhone: String
  billingAddress: String
  """Usually government-issued tax ID or business ID such as ABN in Australia"""
  taxIdentifier: String
  """tags associated with the object"""
  tags: [String!]
  organizationID: ID
}
"""
CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
Input was generated by ent.
"""
input CreatePersonalAccessTokenInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """the name associated with the token"""
  name: String!
  token: String
  """what abilites the token should have"""
  abilities: [String!]
  """when the token expires"""
  expiresAt: Time!
  """a description of the token's purpose"""
  description: String
  lastUsedAt: Time
  ownerID: ID!
}
"""
CreateSessionInput is used for create Session object.
Input was generated by ent.
"""
input CreateSessionInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """token is a string token issued to users that has a limited lifetime"""
  sessionToken: String!
  issuedAt: Time!
  expiresAt: Time!
  """organization ID of the organization the user is accessing"""
  organizationID: String!
  ownerID: ID!
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  email: String!
  firstName: String!
  lastName: String!
  """The user's displayed 'friendly' name"""
  displayName: String
  """URL of the user's remote avatar"""
  avatarRemoteURL: String
  """The user's local avatar file"""
  avatarLocalFile: String
  """The time the user's (local) avatar was last updated"""
  avatarUpdatedAt: Time
  """the time the user was last seen"""
  lastSeen: Time
  """user password hash"""
  password: String
  """the Subject of the user JWT"""
  sub: String
  """whether the user uses oauth for login or not"""
  oauth: Boolean
  organizationIDs: [ID!]
  sessionIDs: [ID!]
  groupIDs: [ID!]
  personalAccessTokenIDs: [ID!]
  settingID: ID!
  emailVerificationTokenIDs: [ID!]
  resetTokenIDs: [ID!]
}
"""
CreateUserSettingInput is used for create UserSetting object.
Input was generated by ent.
"""
input CreateUserSettingInput {
  createdAt: Time
  updatedAt: Time
  createdBy: String
  updatedBy: String
  """user account is locked if unconfirmed or explicitly locked"""
  locked: Boolean
  """The time notifications regarding the user were silenced"""
  silencedAt: Time
  """The time the user was suspended"""
  suspendedAt: Time
  """local user password recovery code generated during account creation - does not exist for oauth'd users"""
  recoveryCode: String
  status: UserSettingStatus
  role: UserSettingRole
  permissions: [String!]
  emailConfirmed: Boolean
  """tags associated with the object"""
  tags: [String!]
  userID: ID
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Entitlement implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  tier: EntitlementTier!
  """used to store references to external systems, e.g. Stripe"""
  externalCustomerID: String
  """used to store references to external systems, e.g. Stripe"""
  externalSubscriptionID: String
  """whether or not the customers entitlement expires - expires_at will show the time"""
  expires: Boolean!
  """the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month"""
  expiresAt: Time
  """whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at"""
  cancelled: Boolean!
  owner: Organization
}
"""A connection to a list of items."""
type EntitlementConnection {
  """A list of edges."""
  edges: [EntitlementEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type EntitlementEdge {
  """The item at the end of the edge."""
  node: Entitlement
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""EntitlementTier is enum for the field tier"""
enum EntitlementTier @goModel(model: "github.com/datumforge/datum/internal/ent/generated/entitlement.Tier") {
  free
  pro
  enterprise
}
"""
EntitlementWhereInput is used for filtering Entitlement objects.
Input was generated by ent.
"""
input EntitlementWhereInput {
  not: EntitlementWhereInput
  and: [EntitlementWhereInput!]
  or: [EntitlementWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """tier field predicates"""
  tier: EntitlementTier
  tierNEQ: EntitlementTier
  tierIn: [EntitlementTier!]
  tierNotIn: [EntitlementTier!]
  """external_customer_id field predicates"""
  externalCustomerID: String
  externalCustomerIDNEQ: String
  externalCustomerIDIn: [String!]
  externalCustomerIDNotIn: [String!]
  externalCustomerIDGT: String
  externalCustomerIDGTE: String
  externalCustomerIDLT: String
  externalCustomerIDLTE: String
  externalCustomerIDContains: String
  externalCustomerIDHasPrefix: String
  externalCustomerIDHasSuffix: String
  externalCustomerIDIsNil: Boolean
  externalCustomerIDNotNil: Boolean
  externalCustomerIDEqualFold: String
  externalCustomerIDContainsFold: String
  """external_subscription_id field predicates"""
  externalSubscriptionID: String
  externalSubscriptionIDNEQ: String
  externalSubscriptionIDIn: [String!]
  externalSubscriptionIDNotIn: [String!]
  externalSubscriptionIDGT: String
  externalSubscriptionIDGTE: String
  externalSubscriptionIDLT: String
  externalSubscriptionIDLTE: String
  externalSubscriptionIDContains: String
  externalSubscriptionIDHasPrefix: String
  externalSubscriptionIDHasSuffix: String
  externalSubscriptionIDIsNil: Boolean
  externalSubscriptionIDNotNil: Boolean
  externalSubscriptionIDEqualFold: String
  externalSubscriptionIDContainsFold: String
  """expires field predicates"""
  expires: Boolean
  expiresNEQ: Boolean
  """expires_at field predicates"""
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  expiresAtIsNil: Boolean
  expiresAtNotNil: Boolean
  """cancelled field predicates"""
  cancelled: Boolean
  cancelledNEQ: Boolean
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [OrganizationWhereInput!]
}
type Group implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """the name of the group - must be unique within the organization"""
  name: String!
  """the groups description"""
  description: String
  """the URL to an auto generated gravatar image for the group"""
  gravatarLogoURL: String
  """the URL to an image uploaded by the customer for the groups avatar image"""
  logoURL: String
  """The group's displayed 'friendly' name"""
  displayName: String!
  setting: GroupSetting!
  users: [User!]
  owner: Organization!
}
"""A connection to a list of items."""
type GroupConnection {
  """A list of edges."""
  edges: [GroupEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GroupEdge {
  """The item at the end of the edge."""
  node: Group
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Group connections"""
input GroupOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Groups."""
  field: GroupOrderField!
}
"""Properties by which Group connections can be ordered."""
enum GroupOrderField {
  name
  display_name
}
type GroupSetting implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization"""
  visibility: GroupSettingVisibility!
  """the policy governing ability to freely join a group, whether it requires an invitation, application, or either"""
  joinPolicy: GroupSettingJoinPolicy!
  """tags associated with the object"""
  tags: [String!]!
  syncToSlack: Boolean!
  syncToGithub: Boolean!
  group: Group
}
"""A connection to a list of items."""
type GroupSettingConnection {
  """A list of edges."""
  edges: [GroupSettingEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type GroupSettingEdge {
  """The item at the end of the edge."""
  node: GroupSetting
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""GroupSettingJoinPolicy is enum for the field join_policy"""
enum GroupSettingJoinPolicy @goModel(model: "github.com/datumforge/datum/internal/ent/generated/groupsetting.JoinPolicy") {
  OPEN
  INVITE_ONLY
  APPLICATION_ONLY
  INVITE_OR_APPLICATION
}
"""GroupSettingVisibility is enum for the field visibility"""
enum GroupSettingVisibility @goModel(model: "github.com/datumforge/datum/internal/ent/generated/groupsetting.Visibility") {
  PUBLIC
  PRIVATE
}
"""
GroupSettingWhereInput is used for filtering GroupSetting objects.
Input was generated by ent.
"""
input GroupSettingWhereInput {
  not: GroupSettingWhereInput
  and: [GroupSettingWhereInput!]
  or: [GroupSettingWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """visibility field predicates"""
  visibility: GroupSettingVisibility
  visibilityNEQ: GroupSettingVisibility
  visibilityIn: [GroupSettingVisibility!]
  visibilityNotIn: [GroupSettingVisibility!]
  """join_policy field predicates"""
  joinPolicy: GroupSettingJoinPolicy
  joinPolicyNEQ: GroupSettingJoinPolicy
  joinPolicyIn: [GroupSettingJoinPolicy!]
  joinPolicyNotIn: [GroupSettingJoinPolicy!]
  """sync_to_slack field predicates"""
  syncToSlack: Boolean
  syncToSlackNEQ: Boolean
  """sync_to_github field predicates"""
  syncToGithub: Boolean
  syncToGithubNEQ: Boolean
  """group edge predicates"""
  hasGroup: Boolean
  hasGroupWith: [GroupWhereInput!]
}
"""
GroupWhereInput is used for filtering Group objects.
Input was generated by ent.
"""
input GroupWhereInput {
  not: GroupWhereInput
  and: [GroupWhereInput!]
  or: [GroupWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """display_name field predicates"""
  displayName: String
  displayNameNEQ: String
  displayNameIn: [String!]
  displayNameNotIn: [String!]
  displayNameGT: String
  displayNameGTE: String
  displayNameLT: String
  displayNameLTE: String
  displayNameContains: String
  displayNameHasPrefix: String
  displayNameHasSuffix: String
  displayNameEqualFold: String
  displayNameContainsFold: String
  """setting edge predicates"""
  hasSetting: Boolean
  hasSettingWith: [GroupSettingWhereInput!]
  """users edge predicates"""
  hasUsers: Boolean
  hasUsersWith: [UserWhereInput!]
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [OrganizationWhereInput!]
}
type Integration implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """the name of the integration - must be unique within the organization"""
  name: String!
  """a description of the integration"""
  description: String
  kind: String
  secretName: String!
  owner: Organization
}
"""A connection to a list of items."""
type IntegrationConnection {
  """A list of edges."""
  edges: [IntegrationEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type IntegrationEdge {
  """The item at the end of the edge."""
  node: Integration
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Integration connections"""
input IntegrationOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Integrations."""
  field: IntegrationOrderField!
}
"""Properties by which Integration connections can be ordered."""
enum IntegrationOrderField {
  name
  kind
}
"""
IntegrationWhereInput is used for filtering Integration objects.
Input was generated by ent.
"""
input IntegrationWhereInput {
  not: IntegrationWhereInput
  and: [IntegrationWhereInput!]
  or: [IntegrationWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """kind field predicates"""
  kind: String
  kindNEQ: String
  kindIn: [String!]
  kindNotIn: [String!]
  kindGT: String
  kindGTE: String
  kindLT: String
  kindLTE: String
  kindContains: String
  kindHasPrefix: String
  kindHasSuffix: String
  kindIsNil: Boolean
  kindNotNil: Boolean
  kindEqualFold: String
  kindContainsFold: String
  """secret_name field predicates"""
  secretName: String
  secretNameNEQ: String
  secretNameIn: [String!]
  secretNameNotIn: [String!]
  secretNameGT: String
  secretNameGTE: String
  secretNameLT: String
  secretNameLTE: String
  secretNameContains: String
  secretNameHasPrefix: String
  secretNameHasSuffix: String
  secretNameEqualFold: String
  secretNameContainsFold: String
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [OrganizationWhereInput!]
}
"""A valid JSON string."""
scalar JSON
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/datumforge/datum/internal/ent/generated.Noder") {
  """The id of the object."""
  id: ID!
}
type OauthProvider implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """the oauth provider's name"""
  name: String!
  """the client id for the oauth provider"""
  clientID: String!
  """the client secret"""
  clientSecret: String!
  """the redirect url"""
  redirectURL: String!
  """the scopes"""
  scopes: String!
  """the auth url of the provider"""
  authURL: String!
  """the token url of the provider"""
  tokenURL: String!
  """the auth style, 0: auto detect 1: third party log in 2: log in with username and password"""
  authStyle: Int!
  """the URL to request user information by token"""
  infoURL: String!
  owner: Organization
}
"""A connection to a list of items."""
type OauthProviderConnection {
  """A list of edges."""
  edges: [OauthProviderEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type OauthProviderEdge {
  """The item at the end of the edge."""
  node: OauthProvider
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
OauthProviderWhereInput is used for filtering OauthProvider objects.
Input was generated by ent.
"""
input OauthProviderWhereInput {
  not: OauthProviderWhereInput
  and: [OauthProviderWhereInput!]
  or: [OauthProviderWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """client_id field predicates"""
  clientID: String
  clientIDNEQ: String
  clientIDIn: [String!]
  clientIDNotIn: [String!]
  clientIDGT: String
  clientIDGTE: String
  clientIDLT: String
  clientIDLTE: String
  clientIDContains: String
  clientIDHasPrefix: String
  clientIDHasSuffix: String
  clientIDEqualFold: String
  clientIDContainsFold: String
  """client_secret field predicates"""
  clientSecret: String
  clientSecretNEQ: String
  clientSecretIn: [String!]
  clientSecretNotIn: [String!]
  clientSecretGT: String
  clientSecretGTE: String
  clientSecretLT: String
  clientSecretLTE: String
  clientSecretContains: String
  clientSecretHasPrefix: String
  clientSecretHasSuffix: String
  clientSecretEqualFold: String
  clientSecretContainsFold: String
  """redirect_url field predicates"""
  redirectURL: String
  redirectURLNEQ: String
  redirectURLIn: [String!]
  redirectURLNotIn: [String!]
  redirectURLGT: String
  redirectURLGTE: String
  redirectURLLT: String
  redirectURLLTE: String
  redirectURLContains: String
  redirectURLHasPrefix: String
  redirectURLHasSuffix: String
  redirectURLEqualFold: String
  redirectURLContainsFold: String
  """scopes field predicates"""
  scopes: String
  scopesNEQ: String
  scopesIn: [String!]
  scopesNotIn: [String!]
  scopesGT: String
  scopesGTE: String
  scopesLT: String
  scopesLTE: String
  scopesContains: String
  scopesHasPrefix: String
  scopesHasSuffix: String
  scopesEqualFold: String
  scopesContainsFold: String
  """auth_url field predicates"""
  authURL: String
  authURLNEQ: String
  authURLIn: [String!]
  authURLNotIn: [String!]
  authURLGT: String
  authURLGTE: String
  authURLLT: String
  authURLLTE: String
  authURLContains: String
  authURLHasPrefix: String
  authURLHasSuffix: String
  authURLEqualFold: String
  authURLContainsFold: String
  """token_url field predicates"""
  tokenURL: String
  tokenURLNEQ: String
  tokenURLIn: [String!]
  tokenURLNotIn: [String!]
  tokenURLGT: String
  tokenURLGTE: String
  tokenURLLT: String
  tokenURLLTE: String
  tokenURLContains: String
  tokenURLHasPrefix: String
  tokenURLHasSuffix: String
  tokenURLEqualFold: String
  tokenURLContainsFold: String
  """auth_style field predicates"""
  authStyle: Int
  authStyleNEQ: Int
  authStyleIn: [Int!]
  authStyleNotIn: [Int!]
  authStyleGT: Int
  authStyleGTE: Int
  authStyleLT: Int
  authStyleLTE: Int
  """info_url field predicates"""
  infoURL: String
  infoURLNEQ: String
  infoURLIn: [String!]
  infoURLNotIn: [String!]
  infoURLGT: String
  infoURLGTE: String
  infoURLLT: String
  infoURLLTE: String
  infoURLContains: String
  infoURLHasPrefix: String
  infoURLHasSuffix: String
  infoURLEqualFold: String
  infoURLContainsFold: String
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [OrganizationWhereInput!]
}
type OhAuthTooToken implements Node {
  id: ID!
  clientID: String!
  scopes: [String!]
  nonce: String!
  claimsUserID: String!
  claimsUsername: String!
  claimsEmail: String!
  claimsEmailVerified: Boolean!
  claimsGroups: [String!]
  claimsPreferredUsername: String!
  connectorID: String!
  connectorData: [String!]
  lastUsed: Time!
}
"""A connection to a list of items."""
type OhAuthTooTokenConnection {
  """A list of edges."""
  edges: [OhAuthTooTokenEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type OhAuthTooTokenEdge {
  """The item at the end of the edge."""
  node: OhAuthTooToken
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
OhAuthTooTokenWhereInput is used for filtering OhAuthTooToken objects.
Input was generated by ent.
"""
input OhAuthTooTokenWhereInput {
  not: OhAuthTooTokenWhereInput
  and: [OhAuthTooTokenWhereInput!]
  or: [OhAuthTooTokenWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """client_id field predicates"""
  clientID: String
  clientIDNEQ: String
  clientIDIn: [String!]
  clientIDNotIn: [String!]
  clientIDGT: String
  clientIDGTE: String
  clientIDLT: String
  clientIDLTE: String
  clientIDContains: String
  clientIDHasPrefix: String
  clientIDHasSuffix: String
  clientIDEqualFold: String
  clientIDContainsFold: String
  """nonce field predicates"""
  nonce: String
  nonceNEQ: String
  nonceIn: [String!]
  nonceNotIn: [String!]
  nonceGT: String
  nonceGTE: String
  nonceLT: String
  nonceLTE: String
  nonceContains: String
  nonceHasPrefix: String
  nonceHasSuffix: String
  nonceEqualFold: String
  nonceContainsFold: String
  """claims_user_id field predicates"""
  claimsUserID: String
  claimsUserIDNEQ: String
  claimsUserIDIn: [String!]
  claimsUserIDNotIn: [String!]
  claimsUserIDGT: String
  claimsUserIDGTE: String
  claimsUserIDLT: String
  claimsUserIDLTE: String
  claimsUserIDContains: String
  claimsUserIDHasPrefix: String
  claimsUserIDHasSuffix: String
  claimsUserIDEqualFold: String
  claimsUserIDContainsFold: String
  """claims_username field predicates"""
  claimsUsername: String
  claimsUsernameNEQ: String
  claimsUsernameIn: [String!]
  claimsUsernameNotIn: [String!]
  claimsUsernameGT: String
  claimsUsernameGTE: String
  claimsUsernameLT: String
  claimsUsernameLTE: String
  claimsUsernameContains: String
  claimsUsernameHasPrefix: String
  claimsUsernameHasSuffix: String
  claimsUsernameEqualFold: String
  claimsUsernameContainsFold: String
  """claims_email field predicates"""
  claimsEmail: String
  claimsEmailNEQ: String
  claimsEmailIn: [String!]
  claimsEmailNotIn: [String!]
  claimsEmailGT: String
  claimsEmailGTE: String
  claimsEmailLT: String
  claimsEmailLTE: String
  claimsEmailContains: String
  claimsEmailHasPrefix: String
  claimsEmailHasSuffix: String
  claimsEmailEqualFold: String
  claimsEmailContainsFold: String
  """claims_email_verified field predicates"""
  claimsEmailVerified: Boolean
  claimsEmailVerifiedNEQ: Boolean
  """claims_preferred_username field predicates"""
  claimsPreferredUsername: String
  claimsPreferredUsernameNEQ: String
  claimsPreferredUsernameIn: [String!]
  claimsPreferredUsernameNotIn: [String!]
  claimsPreferredUsernameGT: String
  claimsPreferredUsernameGTE: String
  claimsPreferredUsernameLT: String
  claimsPreferredUsernameLTE: String
  claimsPreferredUsernameContains: String
  claimsPreferredUsernameHasPrefix: String
  claimsPreferredUsernameHasSuffix: String
  claimsPreferredUsernameEqualFold: String
  claimsPreferredUsernameContainsFold: String
  """connector_id field predicates"""
  connectorID: String
  connectorIDNEQ: String
  connectorIDIn: [String!]
  connectorIDNotIn: [String!]
  connectorIDGT: String
  connectorIDGTE: String
  connectorIDLT: String
  connectorIDLTE: String
  connectorIDContains: String
  connectorIDHasPrefix: String
  connectorIDHasSuffix: String
  connectorIDEqualFold: String
  connectorIDContainsFold: String
  """last_used field predicates"""
  lastUsed: Time
  lastUsedNEQ: Time
  lastUsedIn: [Time!]
  lastUsedNotIn: [Time!]
  lastUsedGT: Time
  lastUsedGTE: Time
  lastUsedLT: Time
  lastUsedLTE: Time
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
type Organization implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """the name of the organization"""
  name: String!
  """The organization's displayed 'friendly' name"""
  displayName: String!
  """An optional description of the organization"""
  description: String
  """orgs directly associated with a user"""
  personalOrg: Boolean!
  parent: Organization
  children(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Organizations returned from the connection."""
    orderBy: OrganizationOrder

    """Filtering options for Organizations returned from the connection."""
    where: OrganizationWhereInput
  ): OrganizationConnection!
  users: [User!]
  groups: [Group!]
  integrations: [Integration!]
  setting: OrganizationSetting
  entitlements: [Entitlement!]
  oauthprovider: [OauthProvider!]
}
"""A connection to a list of items."""
type OrganizationConnection {
  """A list of edges."""
  edges: [OrganizationEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type OrganizationEdge {
  """The item at the end of the edge."""
  node: Organization
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Organization connections"""
input OrganizationOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Organizations."""
  field: OrganizationOrderField!
}
"""Properties by which Organization connections can be ordered."""
enum OrganizationOrderField {
  name
  display_name
}
type OrganizationSetting implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """domains associated with the organization"""
  domains: [String!]
  ssoCert: String
  ssoEntrypoint: String
  ssoIssuer: String
  """Name of the person to contact for billing"""
  billingContact: String
  billingEmail: String
  billingPhone: String
  billingAddress: String
  """Usually government-issued tax ID or business ID such as ABN in Australia"""
  taxIdentifier: String
  """tags associated with the object"""
  tags: [String!]
  organization: Organization
}
"""A connection to a list of items."""
type OrganizationSettingConnection {
  """A list of edges."""
  edges: [OrganizationSettingEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type OrganizationSettingEdge {
  """The item at the end of the edge."""
  node: OrganizationSetting
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
Input was generated by ent.
"""
input OrganizationSettingWhereInput {
  not: OrganizationSettingWhereInput
  and: [OrganizationSettingWhereInput!]
  or: [OrganizationSettingWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """sso_cert field predicates"""
  ssoCert: String
  ssoCertNEQ: String
  ssoCertIn: [String!]
  ssoCertNotIn: [String!]
  ssoCertGT: String
  ssoCertGTE: String
  ssoCertLT: String
  ssoCertLTE: String
  ssoCertContains: String
  ssoCertHasPrefix: String
  ssoCertHasSuffix: String
  ssoCertIsNil: Boolean
  ssoCertNotNil: Boolean
  ssoCertEqualFold: String
  ssoCertContainsFold: String
  """sso_entrypoint field predicates"""
  ssoEntrypoint: String
  ssoEntrypointNEQ: String
  ssoEntrypointIn: [String!]
  ssoEntrypointNotIn: [String!]
  ssoEntrypointGT: String
  ssoEntrypointGTE: String
  ssoEntrypointLT: String
  ssoEntrypointLTE: String
  ssoEntrypointContains: String
  ssoEntrypointHasPrefix: String
  ssoEntrypointHasSuffix: String
  ssoEntrypointIsNil: Boolean
  ssoEntrypointNotNil: Boolean
  ssoEntrypointEqualFold: String
  ssoEntrypointContainsFold: String
  """sso_issuer field predicates"""
  ssoIssuer: String
  ssoIssuerNEQ: String
  ssoIssuerIn: [String!]
  ssoIssuerNotIn: [String!]
  ssoIssuerGT: String
  ssoIssuerGTE: String
  ssoIssuerLT: String
  ssoIssuerLTE: String
  ssoIssuerContains: String
  ssoIssuerHasPrefix: String
  ssoIssuerHasSuffix: String
  ssoIssuerIsNil: Boolean
  ssoIssuerNotNil: Boolean
  ssoIssuerEqualFold: String
  ssoIssuerContainsFold: String
  """billing_contact field predicates"""
  billingContact: String
  billingContactNEQ: String
  billingContactIn: [String!]
  billingContactNotIn: [String!]
  billingContactGT: String
  billingContactGTE: String
  billingContactLT: String
  billingContactLTE: String
  billingContactContains: String
  billingContactHasPrefix: String
  billingContactHasSuffix: String
  billingContactIsNil: Boolean
  billingContactNotNil: Boolean
  billingContactEqualFold: String
  billingContactContainsFold: String
  """billing_email field predicates"""
  billingEmail: String
  billingEmailNEQ: String
  billingEmailIn: [String!]
  billingEmailNotIn: [String!]
  billingEmailGT: String
  billingEmailGTE: String
  billingEmailLT: String
  billingEmailLTE: String
  billingEmailContains: String
  billingEmailHasPrefix: String
  billingEmailHasSuffix: String
  billingEmailIsNil: Boolean
  billingEmailNotNil: Boolean
  billingEmailEqualFold: String
  billingEmailContainsFold: String
  """billing_phone field predicates"""
  billingPhone: String
  billingPhoneNEQ: String
  billingPhoneIn: [String!]
  billingPhoneNotIn: [String!]
  billingPhoneGT: String
  billingPhoneGTE: String
  billingPhoneLT: String
  billingPhoneLTE: String
  billingPhoneContains: String
  billingPhoneHasPrefix: String
  billingPhoneHasSuffix: String
  billingPhoneIsNil: Boolean
  billingPhoneNotNil: Boolean
  billingPhoneEqualFold: String
  billingPhoneContainsFold: String
  """billing_address field predicates"""
  billingAddress: String
  billingAddressNEQ: String
  billingAddressIn: [String!]
  billingAddressNotIn: [String!]
  billingAddressGT: String
  billingAddressGTE: String
  billingAddressLT: String
  billingAddressLTE: String
  billingAddressContains: String
  billingAddressHasPrefix: String
  billingAddressHasSuffix: String
  billingAddressIsNil: Boolean
  billingAddressNotNil: Boolean
  billingAddressEqualFold: String
  billingAddressContainsFold: String
  """tax_identifier field predicates"""
  taxIdentifier: String
  taxIdentifierNEQ: String
  taxIdentifierIn: [String!]
  taxIdentifierNotIn: [String!]
  taxIdentifierGT: String
  taxIdentifierGTE: String
  taxIdentifierLT: String
  taxIdentifierLTE: String
  taxIdentifierContains: String
  taxIdentifierHasPrefix: String
  taxIdentifierHasSuffix: String
  taxIdentifierIsNil: Boolean
  taxIdentifierNotNil: Boolean
  taxIdentifierEqualFold: String
  taxIdentifierContainsFold: String
  """organization edge predicates"""
  hasOrganization: Boolean
  hasOrganizationWith: [OrganizationWhereInput!]
}
"""
OrganizationWhereInput is used for filtering Organization objects.
Input was generated by ent.
"""
input OrganizationWhereInput {
  not: OrganizationWhereInput
  and: [OrganizationWhereInput!]
  or: [OrganizationWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """display_name field predicates"""
  displayName: String
  displayNameNEQ: String
  displayNameIn: [String!]
  displayNameNotIn: [String!]
  displayNameGT: String
  displayNameGTE: String
  displayNameLT: String
  displayNameLTE: String
  displayNameContains: String
  displayNameHasPrefix: String
  displayNameHasSuffix: String
  displayNameEqualFold: String
  displayNameContainsFold: String
  """parent_organization_id field predicates"""
  parentOrganizationID: ID
  parentOrganizationIDNEQ: ID
  parentOrganizationIDIn: [ID!]
  parentOrganizationIDNotIn: [ID!]
  parentOrganizationIDGT: ID
  parentOrganizationIDGTE: ID
  parentOrganizationIDLT: ID
  parentOrganizationIDLTE: ID
  parentOrganizationIDContains: ID
  parentOrganizationIDHasPrefix: ID
  parentOrganizationIDHasSuffix: ID
  parentOrganizationIDIsNil: Boolean
  parentOrganizationIDNotNil: Boolean
  parentOrganizationIDEqualFold: ID
  parentOrganizationIDContainsFold: ID
  """personal_org field predicates"""
  personalOrg: Boolean
  personalOrgNEQ: Boolean
  """parent edge predicates"""
  hasParent: Boolean
  hasParentWith: [OrganizationWhereInput!]
  """children edge predicates"""
  hasChildren: Boolean
  hasChildrenWith: [OrganizationWhereInput!]
  """users edge predicates"""
  hasUsers: Boolean
  hasUsersWith: [UserWhereInput!]
  """groups edge predicates"""
  hasGroups: Boolean
  hasGroupsWith: [GroupWhereInput!]
  """integrations edge predicates"""
  hasIntegrations: Boolean
  hasIntegrationsWith: [IntegrationWhereInput!]
  """setting edge predicates"""
  hasSetting: Boolean
  hasSettingWith: [OrganizationSettingWhereInput!]
  """entitlements edge predicates"""
  hasEntitlements: Boolean
  hasEntitlementsWith: [EntitlementWhereInput!]
  """oauthprovider edge predicates"""
  hasOauthprovider: Boolean
  hasOauthproviderWith: [OauthProviderWhereInput!]
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type PersonalAccessToken implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """the name associated with the token"""
  name: String!
  """what abilites the token should have"""
  abilities: [String!]
  """when the token expires"""
  expiresAt: Time!
  """a description of the token's purpose"""
  description: String
  lastUsedAt: Time
  owner: User!
}
"""A connection to a list of items."""
type PersonalAccessTokenConnection {
  """A list of edges."""
  edges: [PersonalAccessTokenEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PersonalAccessTokenEdge {
  """The item at the end of the edge."""
  node: PersonalAccessToken
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
Input was generated by ent.
"""
input PersonalAccessTokenWhereInput {
  not: PersonalAccessTokenWhereInput
  and: [PersonalAccessTokenWhereInput!]
  or: [PersonalAccessTokenWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """expires_at field predicates"""
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  """last_used_at field predicates"""
  lastUsedAt: Time
  lastUsedAtNEQ: Time
  lastUsedAtIn: [Time!]
  lastUsedAtNotIn: [Time!]
  lastUsedAtGT: Time
  lastUsedAtGTE: Time
  lastUsedAtLT: Time
  lastUsedAtLTE: Time
  lastUsedAtIsNil: Boolean
  lastUsedAtNotNil: Boolean
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  entitlements(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for Entitlements returned from the connection."""
    where: EntitlementWhereInput
  ): EntitlementConnection!
  groups(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Groups returned from the connection."""
    orderBy: GroupOrder

    """Filtering options for Groups returned from the connection."""
    where: GroupWhereInput
  ): GroupConnection!
  groupSettings(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for GroupSettings returned from the connection."""
    where: GroupSettingWhereInput
  ): GroupSettingConnection!
  integrations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Integrations returned from the connection."""
    orderBy: IntegrationOrder

    """Filtering options for Integrations returned from the connection."""
    where: IntegrationWhereInput
  ): IntegrationConnection!
  oauthProviders(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for OauthProviders returned from the connection."""
    where: OauthProviderWhereInput
  ): OauthProviderConnection!
  ohAuthTooTokens(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for OhAuthTooTokens returned from the connection."""
    where: OhAuthTooTokenWhereInput
  ): OhAuthTooTokenConnection!
  organizations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Organizations returned from the connection."""
    orderBy: OrganizationOrder

    """Filtering options for Organizations returned from the connection."""
    where: OrganizationWhereInput
  ): OrganizationConnection!
  organizationSettings(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for OrganizationSettings returned from the connection."""
    where: OrganizationSettingWhereInput
  ): OrganizationSettingConnection!
  personalAccessTokens(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for PersonalAccessTokens returned from the connection."""
    where: PersonalAccessTokenWhereInput
  ): PersonalAccessTokenConnection!
  sessions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for Sessions returned from the connection."""
    where: SessionWhereInput
  ): SessionConnection!
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Users returned from the connection."""
    orderBy: UserOrder

    """Filtering options for Users returned from the connection."""
    where: UserWhereInput
  ): UserConnection!
  userSettings(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filtering options for UserSettings returned from the connection."""
    where: UserSettingWhereInput
  ): UserSettingConnection!
}
type Session implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  """token is a string token issued to users that has a limited lifetime"""
  sessionToken: String!
  issuedAt: Time!
  expiresAt: Time!
  """organization ID of the organization the user is accessing"""
  organizationID: String!
  """the user the session is associated with"""
  userID: ID!
  """Sessions belong to users"""
  owner: User!
}
"""A connection to a list of items."""
type SessionConnection {
  """A list of edges."""
  edges: [SessionEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type SessionEdge {
  """The item at the end of the edge."""
  node: Session
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""
SessionWhereInput is used for filtering Session objects.
Input was generated by ent.
"""
input SessionWhereInput {
  not: SessionWhereInput
  and: [SessionWhereInput!]
  or: [SessionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """session_token field predicates"""
  sessionToken: String
  sessionTokenNEQ: String
  sessionTokenIn: [String!]
  sessionTokenNotIn: [String!]
  sessionTokenGT: String
  sessionTokenGTE: String
  sessionTokenLT: String
  sessionTokenLTE: String
  sessionTokenContains: String
  sessionTokenHasPrefix: String
  sessionTokenHasSuffix: String
  sessionTokenEqualFold: String
  sessionTokenContainsFold: String
  """issued_at field predicates"""
  issuedAt: Time
  issuedAtNEQ: Time
  issuedAtIn: [Time!]
  issuedAtNotIn: [Time!]
  issuedAtGT: Time
  issuedAtGTE: Time
  issuedAtLT: Time
  issuedAtLTE: Time
  """expires_at field predicates"""
  expiresAt: Time
  expiresAtNEQ: Time
  expiresAtIn: [Time!]
  expiresAtNotIn: [Time!]
  expiresAtGT: Time
  expiresAtGTE: Time
  expiresAtLT: Time
  expiresAtLTE: Time
  """organization_id field predicates"""
  organizationID: String
  organizationIDNEQ: String
  organizationIDIn: [String!]
  organizationIDNotIn: [String!]
  organizationIDGT: String
  organizationIDGTE: String
  organizationIDLT: String
  organizationIDLTE: String
  organizationIDContains: String
  organizationIDHasPrefix: String
  organizationIDHasSuffix: String
  organizationIDEqualFold: String
  organizationIDContainsFold: String
  """user_id field predicates"""
  userID: ID
  userIDNEQ: ID
  userIDIn: [ID!]
  userIDNotIn: [ID!]
  userIDGT: ID
  userIDGTE: ID
  userIDLT: ID
  userIDLTE: ID
  userIDContains: ID
  userIDHasPrefix: ID
  userIDHasSuffix: ID
  userIDEqualFold: ID
  userIDContainsFold: ID
  """owner edge predicates"""
  hasOwner: Boolean
  hasOwnerWith: [UserWhereInput!]
}
"""The builtin Time type"""
scalar Time
"""
UpdateEntitlementInput is used for update Entitlement object.
Input was generated by ent.
"""
input UpdateEntitlementInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  tier: EntitlementTier
  """used to store references to external systems, e.g. Stripe"""
  externalCustomerID: String
  clearExternalCustomerID: Boolean
  """used to store references to external systems, e.g. Stripe"""
  externalSubscriptionID: String
  clearExternalSubscriptionID: Boolean
  """whether or not the customers entitlement expires - expires_at will show the time"""
  expires: Boolean
  """the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month"""
  expiresAt: Time
  clearExpiresAt: Boolean
  """whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at"""
  cancelled: Boolean
  ownerID: ID
  clearOwner: Boolean
}
"""
UpdateGroupInput is used for update Group object.
Input was generated by ent.
"""
input UpdateGroupInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """the name of the group - must be unique within the organization"""
  name: String
  """the groups description"""
  description: String
  clearDescription: Boolean
  """the URL to an auto generated gravatar image for the group"""
  gravatarLogoURL: String
  clearGravatarLogoURL: Boolean
  """the URL to an image uploaded by the customer for the groups avatar image"""
  logoURL: String
  clearLogoURL: Boolean
  """The group's displayed 'friendly' name"""
  displayName: String
  settingID: ID
  addUserIDs: [ID!]
  removeUserIDs: [ID!]
  clearUsers: Boolean
  ownerID: ID
}
"""
UpdateGroupSettingInput is used for update GroupSetting object.
Input was generated by ent.
"""
input UpdateGroupSettingInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization"""
  visibility: GroupSettingVisibility
  """the policy governing ability to freely join a group, whether it requires an invitation, application, or either"""
  joinPolicy: GroupSettingJoinPolicy
  """tags associated with the object"""
  tags: [String!]
  appendTags: [String!]
  syncToSlack: Boolean
  syncToGithub: Boolean
  groupID: ID
  clearGroup: Boolean
}
"""
UpdateIntegrationInput is used for update Integration object.
Input was generated by ent.
"""
input UpdateIntegrationInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """the name of the integration - must be unique within the organization"""
  name: String
  """a description of the integration"""
  description: String
  clearDescription: Boolean
  kind: String
  clearKind: Boolean
  ownerID: ID
  clearOwner: Boolean
}
"""
UpdateOauthProviderInput is used for update OauthProvider object.
Input was generated by ent.
"""
input UpdateOauthProviderInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """the oauth provider's name"""
  name: String
  """the client id for the oauth provider"""
  clientID: String
  """the client secret"""
  clientSecret: String
  """the redirect url"""
  redirectURL: String
  """the scopes"""
  scopes: String
  """the auth url of the provider"""
  authURL: String
  """the token url of the provider"""
  tokenURL: String
  """the auth style, 0: auto detect 1: third party log in 2: log in with username and password"""
  authStyle: Int
  """the URL to request user information by token"""
  infoURL: String
  ownerID: ID
  clearOwner: Boolean
}
"""
UpdateOhAuthTooTokenInput is used for update OhAuthTooToken object.
Input was generated by ent.
"""
input UpdateOhAuthTooTokenInput {
  clientID: String
  scopes: [String!]
  appendScopes: [String!]
  clearScopes: Boolean
  nonce: String
  claimsUserID: String
  claimsUsername: String
  claimsEmail: String
  claimsEmailVerified: Boolean
  claimsGroups: [String!]
  appendClaimsGroups: [String!]
  clearClaimsGroups: Boolean
  claimsPreferredUsername: String
  connectorID: String
  connectorData: [String!]
  appendConnectorData: [String!]
  clearConnectorData: Boolean
  lastUsed: Time
}
"""
UpdateOrganizationInput is used for update Organization object.
Input was generated by ent.
"""
input UpdateOrganizationInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """the name of the organization"""
  name: String
  """The organization's displayed 'friendly' name"""
  displayName: String
  """An optional description of the organization"""
  description: String
  clearDescription: Boolean
  addUserIDs: [ID!]
  removeUserIDs: [ID!]
  clearUsers: Boolean
  addGroupIDs: [ID!]
  removeGroupIDs: [ID!]
  clearGroups: Boolean
  addIntegrationIDs: [ID!]
  removeIntegrationIDs: [ID!]
  clearIntegrations: Boolean
  settingID: ID
  clearSetting: Boolean
  addEntitlementIDs: [ID!]
  removeEntitlementIDs: [ID!]
  clearEntitlements: Boolean
  addOauthproviderIDs: [ID!]
  removeOauthproviderIDs: [ID!]
  clearOauthprovider: Boolean
}
"""
UpdateOrganizationSettingInput is used for update OrganizationSetting object.
Input was generated by ent.
"""
input UpdateOrganizationSettingInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """domains associated with the organization"""
  domains: [String!]
  appendDomains: [String!]
  clearDomains: Boolean
  ssoCert: String
  clearSSOCert: Boolean
  ssoEntrypoint: String
  clearSSOEntrypoint: Boolean
  ssoIssuer: String
  clearSSOIssuer: Boolean
  """Name of the person to contact for billing"""
  billingContact: String
  clearBillingContact: Boolean
  billingEmail: String
  clearBillingEmail: Boolean
  billingPhone: String
  clearBillingPhone: Boolean
  billingAddress: String
  clearBillingAddress: Boolean
  """Usually government-issued tax ID or business ID such as ABN in Australia"""
  taxIdentifier: String
  clearTaxIdentifier: Boolean
  """tags associated with the object"""
  tags: [String!]
  appendTags: [String!]
  clearTags: Boolean
  organizationID: ID
  clearOrganization: Boolean
}
"""
UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
Input was generated by ent.
"""
input UpdatePersonalAccessTokenInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """the name associated with the token"""
  name: String
  """what abilites the token should have"""
  abilities: [String!]
  appendAbilities: [String!]
  clearAbilities: Boolean
  """when the token expires"""
  expiresAt: Time
  """a description of the token's purpose"""
  description: String
  clearDescription: Boolean
  lastUsedAt: Time
  clearLastUsedAt: Boolean
  ownerID: ID
}
"""
UpdateSessionInput is used for update Session object.
Input was generated by ent.
"""
input UpdateSessionInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  issuedAt: Time
  expiresAt: Time
  """organization ID of the organization the user is accessing"""
  organizationID: String
  ownerID: ID
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  email: String
  firstName: String
  lastName: String
  """The user's displayed 'friendly' name"""
  displayName: String
  """URL of the user's remote avatar"""
  avatarRemoteURL: String
  clearAvatarRemoteURL: Boolean
  """The user's local avatar file"""
  avatarLocalFile: String
  clearAvatarLocalFile: Boolean
  """The time the user's (local) avatar was last updated"""
  avatarUpdatedAt: Time
  clearAvatarUpdatedAt: Boolean
  """the time the user was last seen"""
  lastSeen: Time
  clearLastSeen: Boolean
  """user password hash"""
  password: String
  clearPassword: Boolean
  """the Subject of the user JWT"""
  sub: String
  clearSub: Boolean
  """whether the user uses oauth for login or not"""
  oauth: Boolean
  addOrganizationIDs: [ID!]
  removeOrganizationIDs: [ID!]
  clearOrganizations: Boolean
  addSessionIDs: [ID!]
  removeSessionIDs: [ID!]
  clearSessions: Boolean
  addGroupIDs: [ID!]
  removeGroupIDs: [ID!]
  clearGroups: Boolean
  addPersonalAccessTokenIDs: [ID!]
  removePersonalAccessTokenIDs: [ID!]
  clearPersonalAccessTokens: Boolean
  settingID: ID
  addEmailVerificationTokenIDs: [ID!]
  removeEmailVerificationTokenIDs: [ID!]
  clearEmailVerificationTokens: Boolean
  addResetTokenIDs: [ID!]
  removeResetTokenIDs: [ID!]
  clearResetTokens: Boolean
}
"""
UpdateUserSettingInput is used for update UserSetting object.
Input was generated by ent.
"""
input UpdateUserSettingInput {
  updatedAt: Time
  updatedBy: String
  clearUpdatedBy: Boolean
  """user account is locked if unconfirmed or explicitly locked"""
  locked: Boolean
  """The time notifications regarding the user were silenced"""
  silencedAt: Time
  clearSilencedAt: Boolean
  """The time the user was suspended"""
  suspendedAt: Time
  clearSuspendedAt: Boolean
  """local user password recovery code generated during account creation - does not exist for oauth'd users"""
  recoveryCode: String
  clearRecoveryCode: Boolean
  status: UserSettingStatus
  role: UserSettingRole
  permissions: [String!]
  appendPermissions: [String!]
  emailConfirmed: Boolean
  """tags associated with the object"""
  tags: [String!]
  appendTags: [String!]
  userID: ID
  clearUser: Boolean
}
type User implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  email: String!
  firstName: String!
  lastName: String!
  """The user's displayed 'friendly' name"""
  displayName: String!
  """URL of the user's remote avatar"""
  avatarRemoteURL: String
  """The user's local avatar file"""
  avatarLocalFile: String
  """The time the user's (local) avatar was last updated"""
  avatarUpdatedAt: Time
  """the time the user was last seen"""
  lastSeen: Time
  """user password hash"""
  password: String
  """the Subject of the user JWT"""
  sub: String
  """whether the user uses oauth for login or not"""
  oauth: Boolean!
  organizations: [Organization!]
  sessions: [Session!]
  groups: [Group!]
  personalAccessTokens: [PersonalAccessToken!]
  setting: UserSetting!
}
"""A connection to a list of items."""
type UserConnection {
  """A list of edges."""
  edges: [UserEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for User connections"""
input UserOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Users."""
  field: UserOrderField!
}
"""Properties by which User connections can be ordered."""
enum UserOrderField {
  first_name
  last_name
  display_name
}
type UserSetting implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  createdBy: String
  updatedBy: String
  deletedAt: Time
  deletedBy: String
  """user account is locked if unconfirmed or explicitly locked"""
  locked: Boolean!
  """The time notifications regarding the user were silenced"""
  silencedAt: Time
  """The time the user was suspended"""
  suspendedAt: Time
  status: UserSettingStatus!
  role: UserSettingRole!
  permissions: [String!]!
  emailConfirmed: Boolean!
  """tags associated with the object"""
  tags: [String!]!
  user: User
}
"""A connection to a list of items."""
type UserSettingConnection {
  """A list of edges."""
  edges: [UserSettingEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type UserSettingEdge {
  """The item at the end of the edge."""
  node: UserSetting
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""UserSettingRole is enum for the field role"""
enum UserSettingRole @goModel(model: "github.com/datumforge/datum/internal/ent/generated/usersetting.Role") {
  USER
  ADMIN
  OWNER
}
"""UserSettingStatus is enum for the field status"""
enum UserSettingStatus @goModel(model: "github.com/datumforge/datum/internal/ent/generated/usersetting.Status") {
  ACTIVE
  INACTIVE
  DEACTIVATED
  SUSPENDED
}
"""
UserSettingWhereInput is used for filtering UserSetting objects.
Input was generated by ent.
"""
input UserSettingWhereInput {
  not: UserSettingWhereInput
  and: [UserSettingWhereInput!]
  or: [UserSettingWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """locked field predicates"""
  locked: Boolean
  lockedNEQ: Boolean
  """silenced_at field predicates"""
  silencedAt: Time
  silencedAtNEQ: Time
  silencedAtIn: [Time!]
  silencedAtNotIn: [Time!]
  silencedAtGT: Time
  silencedAtGTE: Time
  silencedAtLT: Time
  silencedAtLTE: Time
  silencedAtIsNil: Boolean
  silencedAtNotNil: Boolean
  """suspended_at field predicates"""
  suspendedAt: Time
  suspendedAtNEQ: Time
  suspendedAtIn: [Time!]
  suspendedAtNotIn: [Time!]
  suspendedAtGT: Time
  suspendedAtGTE: Time
  suspendedAtLT: Time
  suspendedAtLTE: Time
  suspendedAtIsNil: Boolean
  suspendedAtNotNil: Boolean
  """status field predicates"""
  status: UserSettingStatus
  statusNEQ: UserSettingStatus
  statusIn: [UserSettingStatus!]
  statusNotIn: [UserSettingStatus!]
  """role field predicates"""
  role: UserSettingRole
  roleNEQ: UserSettingRole
  roleIn: [UserSettingRole!]
  roleNotIn: [UserSettingRole!]
  """email_confirmed field predicates"""
  emailConfirmed: Boolean
  emailConfirmedNEQ: Boolean
  """user edge predicates"""
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """created_by field predicates"""
  createdBy: String
  createdByNEQ: String
  createdByIn: [String!]
  createdByNotIn: [String!]
  createdByGT: String
  createdByGTE: String
  createdByLT: String
  createdByLTE: String
  createdByContains: String
  createdByHasPrefix: String
  createdByHasSuffix: String
  createdByIsNil: Boolean
  createdByNotNil: Boolean
  createdByEqualFold: String
  createdByContainsFold: String
  """updated_by field predicates"""
  updatedBy: String
  updatedByNEQ: String
  updatedByIn: [String!]
  updatedByNotIn: [String!]
  updatedByGT: String
  updatedByGTE: String
  updatedByLT: String
  updatedByLTE: String
  updatedByContains: String
  updatedByHasPrefix: String
  updatedByHasSuffix: String
  updatedByIsNil: Boolean
  updatedByNotNil: Boolean
  updatedByEqualFold: String
  updatedByContainsFold: String
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """deleted_by field predicates"""
  deletedBy: String
  deletedByNEQ: String
  deletedByIn: [String!]
  deletedByNotIn: [String!]
  deletedByGT: String
  deletedByGTE: String
  deletedByLT: String
  deletedByLTE: String
  deletedByContains: String
  deletedByHasPrefix: String
  deletedByHasSuffix: String
  deletedByIsNil: Boolean
  deletedByNotNil: Boolean
  deletedByEqualFold: String
  deletedByContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """first_name field predicates"""
  firstName: String
  firstNameNEQ: String
  firstNameIn: [String!]
  firstNameNotIn: [String!]
  firstNameGT: String
  firstNameGTE: String
  firstNameLT: String
  firstNameLTE: String
  firstNameContains: String
  firstNameHasPrefix: String
  firstNameHasSuffix: String
  firstNameEqualFold: String
  firstNameContainsFold: String
  """last_name field predicates"""
  lastName: String
  lastNameNEQ: String
  lastNameIn: [String!]
  lastNameNotIn: [String!]
  lastNameGT: String
  lastNameGTE: String
  lastNameLT: String
  lastNameLTE: String
  lastNameContains: String
  lastNameHasPrefix: String
  lastNameHasSuffix: String
  lastNameEqualFold: String
  lastNameContainsFold: String
  """display_name field predicates"""
  displayName: String
  displayNameNEQ: String
  displayNameIn: [String!]
  displayNameNotIn: [String!]
  displayNameGT: String
  displayNameGTE: String
  displayNameLT: String
  displayNameLTE: String
  displayNameContains: String
  displayNameHasPrefix: String
  displayNameHasSuffix: String
  displayNameEqualFold: String
  displayNameContainsFold: String
  """avatar_remote_url field predicates"""
  avatarRemoteURL: String
  avatarRemoteURLNEQ: String
  avatarRemoteURLIn: [String!]
  avatarRemoteURLNotIn: [String!]
  avatarRemoteURLGT: String
  avatarRemoteURLGTE: String
  avatarRemoteURLLT: String
  avatarRemoteURLLTE: String
  avatarRemoteURLContains: String
  avatarRemoteURLHasPrefix: String
  avatarRemoteURLHasSuffix: String
  avatarRemoteURLIsNil: Boolean
  avatarRemoteURLNotNil: Boolean
  avatarRemoteURLEqualFold: String
  avatarRemoteURLContainsFold: String
  """avatar_local_file field predicates"""
  avatarLocalFile: String
  avatarLocalFileNEQ: String
  avatarLocalFileIn: [String!]
  avatarLocalFileNotIn: [String!]
  avatarLocalFileGT: String
  avatarLocalFileGTE: String
  avatarLocalFileLT: String
  avatarLocalFileLTE: String
  avatarLocalFileContains: String
  avatarLocalFileHasPrefix: String
  avatarLocalFileHasSuffix: String
  avatarLocalFileIsNil: Boolean
  avatarLocalFileNotNil: Boolean
  avatarLocalFileEqualFold: String
  avatarLocalFileContainsFold: String
  """avatar_updated_at field predicates"""
  avatarUpdatedAt: Time
  avatarUpdatedAtNEQ: Time
  avatarUpdatedAtIn: [Time!]
  avatarUpdatedAtNotIn: [Time!]
  avatarUpdatedAtGT: Time
  avatarUpdatedAtGTE: Time
  avatarUpdatedAtLT: Time
  avatarUpdatedAtLTE: Time
  avatarUpdatedAtIsNil: Boolean
  avatarUpdatedAtNotNil: Boolean
  """last_seen field predicates"""
  lastSeen: Time
  lastSeenNEQ: Time
  lastSeenIn: [Time!]
  lastSeenNotIn: [Time!]
  lastSeenGT: Time
  lastSeenGTE: Time
  lastSeenLT: Time
  lastSeenLTE: Time
  lastSeenIsNil: Boolean
  lastSeenNotNil: Boolean
  """password field predicates"""
  password: String
  passwordNEQ: String
  passwordIn: [String!]
  passwordNotIn: [String!]
  passwordGT: String
  passwordGTE: String
  passwordLT: String
  passwordLTE: String
  passwordContains: String
  passwordHasPrefix: String
  passwordHasSuffix: String
  passwordIsNil: Boolean
  passwordNotNil: Boolean
  passwordEqualFold: String
  passwordContainsFold: String
  """sub field predicates"""
  sub: String
  subNEQ: String
  subIn: [String!]
  subNotIn: [String!]
  subGT: String
  subGTE: String
  subLT: String
  subLTE: String
  subContains: String
  subHasPrefix: String
  subHasSuffix: String
  subIsNil: Boolean
  subNotNil: Boolean
  subEqualFold: String
  subContainsFold: String
  """oauth field predicates"""
  oauth: Boolean
  oauthNEQ: Boolean
  """organizations edge predicates"""
  hasOrganizations: Boolean
  hasOrganizationsWith: [OrganizationWhereInput!]
  """sessions edge predicates"""
  hasSessions: Boolean
  hasSessionsWith: [SessionWhereInput!]
  """groups edge predicates"""
  hasGroups: Boolean
  hasGroupsWith: [GroupWhereInput!]
  """personal_access_tokens edge predicates"""
  hasPersonalAccessTokens: Boolean
  hasPersonalAccessTokensWith: [PersonalAccessTokenWhereInput!]
  """setting edge predicates"""
  hasSetting: Boolean
  hasSettingWith: [UserSettingWhereInput!]
}
`, BuiltIn: false},
	{Name: "../../schema/entitlement.graphql", Input: `extend type Query {
    """
    Look up entitlement by ID
    """
     entitlement(
        """
        ID of the entitlement
        """
        id: ID!
    ):  Entitlement!
}

extend type Mutation{
    """
    Create a new entitlement
    """
    createEntitlement(
        """
        values of the entitlement
        """
        input: CreateEntitlementInput!
    ): EntitlementCreatePayload!
    """
    Update an existing entitlement
    """
    updateEntitlement(
        """
        ID of the entitlement
        """
        id: ID!
        """
        New values for the entitlement
        """
        input: UpdateEntitlementInput!
    ): EntitlementUpdatePayload!
    """
    Delete an existing entitlement
    """
    deleteEntitlement(
        """
        ID of the entitlement
        """
        id: ID!
    ): EntitlementDeletePayload!
}

"""
Return response for createEntitlement mutation
"""
type EntitlementCreatePayload {
    """
    Created entitlement
    """
    entitlement: Entitlement!
}

"""
Return response for updateEntitlement mutation
"""
type EntitlementUpdatePayload {
    """
    Updated entitlement
    """
    entitlement: Entitlement!
}

"""
Return response for deleteEntitlement mutation
"""
type EntitlementDeletePayload {
    """
    Deleted entitlement ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/group.graphql", Input: `extend type Query {
    """
    Look up group by ID
    """
     group(
        """
        ID of the group
        """
        id: ID!
    ):  Group!
}

extend type Mutation{
    """
    Create a new group
    """
    createGroup(
        """
        values of the group
        """
        input: CreateGroupInput!
    ): GroupCreatePayload!
    """
    Update an existing group
    """
    updateGroup(
        """
        ID of the group
        """
        id: ID!
        """
        New values for the group
        """
        input: UpdateGroupInput!
    ): GroupUpdatePayload!
    """
    Delete an existing group
    """
    deleteGroup(
        """
        ID of the group
        """
        id: ID!
    ): GroupDeletePayload!
}

"""
Return response for createGroup mutation
"""
type GroupCreatePayload {
    """
    Created group
    """
    group: Group!
}

"""
Return response for updateGroup mutation
"""
type GroupUpdatePayload {
    """
    Updated group
    """
    group: Group!
}

"""
Return response for deleteGroup mutation
"""
type GroupDeletePayload {
    """
    Deleted group ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/groupsetting.graphql", Input: `extend type Query {
    """
    Look up groupSetting by ID
    """
     groupSetting(
        """
        ID of the groupSetting
        """
        id: ID!
    ):  GroupSetting!
}

extend type Mutation{
    """
    Create a new groupSetting
    """
    createGroupSetting(
        """
        values of the groupSetting
        """
        input: CreateGroupSettingInput!
    ): GroupSettingCreatePayload!
    """
    Update an existing groupSetting
    """
    updateGroupSetting(
        """
        ID of the groupSetting
        """
        id: ID!
        """
        New values for the groupSetting
        """
        input: UpdateGroupSettingInput!
    ): GroupSettingUpdatePayload!
    """
    Delete an existing groupSetting
    """
    deleteGroupSetting(
        """
        ID of the groupSetting
        """
        id: ID!
    ): GroupSettingDeletePayload!
}

"""
Return response for createGroupSetting mutation
"""
type GroupSettingCreatePayload {
    """
    Created groupSetting
    """
    groupSetting: GroupSetting!
}

"""
Return response for updateGroupSetting mutation
"""
type GroupSettingUpdatePayload {
    """
    Updated groupSetting
    """
    groupSetting: GroupSetting!
}

"""
Return response for deleteGroupSetting mutation
"""
type GroupSettingDeletePayload {
    """
    Deleted groupSetting ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/integration.graphql", Input: `extend type Query {
    """
    Look up integration by ID
    """
     integration(
        """
        ID of the integration
        """
        id: ID!
    ):  Integration!
}

extend type Mutation{
    """
    Create a new integration
    """
    createIntegration(
        """
        values of the integration
        """
        input: CreateIntegrationInput!
    ): IntegrationCreatePayload!
    """
    Update an existing integration
    """
    updateIntegration(
        """
        ID of the integration
        """
        id: ID!
        """
        New values for the integration
        """
        input: UpdateIntegrationInput!
    ): IntegrationUpdatePayload!
    """
    Delete an existing integration
    """
    deleteIntegration(
        """
        ID of the integration
        """
        id: ID!
    ): IntegrationDeletePayload!
}

"""
Return response for createIntegration mutation
"""
type IntegrationCreatePayload {
    """
    Created integration
    """
    integration: Integration!
}

"""
Return response for updateIntegration mutation
"""
type IntegrationUpdatePayload {
    """
    Updated integration
    """
    integration: Integration!
}

"""
Return response for deleteIntegration mutation
"""
type IntegrationDeletePayload {
    """
    Deleted integration ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/oauthprovider.graphql", Input: `extend type Query {
    """
    Look up oauthProvider by ID
    """
     oauthProvider(
        """
        ID of the oauthProvider
        """
        id: ID!
    ):  OauthProvider!
}

extend type Mutation{
    """
    Create a new oauthProvider
    """
    createOauthProvider(
        """
        values of the oauthprovider
        """
        input: CreateOauthProviderInput!
    ): OauthProviderCreatePayload!
    """
    Update an existing oauthProvider
    """
    updateOauthProvider(
        """
        ID of the oauthProvider
        """
        id: ID!
        """
        New values for the oauthProvider
        """
        input: UpdateOauthProviderInput!
    ): OauthProviderUpdatePayload!
    """
    Delete an existing oauthprovider
    """
    deleteOauthProvider(
        """
        ID of the oauthProvider
        """
        id: ID!
    ): OauthProviderDeletePayload!
}

"""
Return response for createOauthprovider mutation
"""
type OauthProviderCreatePayload {
    """
    Created oauthProvider
    """
    OauthProvider: OauthProvider!
}

"""
Return response for updateOauthprovider mutation
"""
type OauthProviderUpdatePayload {
    """
    Updated oauthProvider
    """
    OauthProvider: OauthProvider!
}

"""
Return response for deleteOauthprovider mutation
"""
type OauthProviderDeletePayload {
    """
    Deleted oauthProvider ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/ohauthtootoken.graphql", Input: `extend type Query {
    """
    Look up ohAuthTooToken by ID
    """
     ohAuthTooToken(
        """
        ID of the ohAuthTooToken
        """
        id: ID!
    ):  OhAuthTooToken!
}

extend type Mutation{
    """
    Create a new ohAuthTooToken
    """
    createOhAuthTooToken(
        """
        values of the ohAuthTooToken
        """
        input: CreateOhAuthTooTokenInput!
    ): OhAuthTooTokenCreatePayload!
    """
    Update an existing ohAuthTooToken
    """
    updateOhAuthTooToken(
        """
        ID of the ohAuthTooToken
        """
        id: ID!
        """
        New values for the ohAuthTooToken
        """
        input: UpdateOhAuthTooTokenInput!
    ): OhAuthTooTokenUpdatePayload!
    """
    Delete an existing ohAuthTooToken
    """
    deleteOhAuthTooToken(
        """
        ID of the ohAuthTooToken
        """
        id: ID!
    ): OhAuthTooTokenDeletePayload!
}

"""
Return response for createOhAuthTooToken mutation
"""
type OhAuthTooTokenCreatePayload {
    """
    Created ohAuthTooToken
    """
    ohAuthTooToken: OhAuthTooToken!
}

"""
Return response for updateOhAuthTooToken mutation
"""
type OhAuthTooTokenUpdatePayload {
    """
    Updated ohAuthTooToken
    """
    ohAuthTooToken: OhAuthTooToken!
}

"""
Return response for deleteOhAuthTooToken mutation
"""
type OhAuthTooTokenDeletePayload {
    """
    Deleted ohAuthTooToken ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/organization.graphql", Input: `extend type Query {
    """
    Look up organization by ID
    """
     organization(
        """
        ID of the organization
        """
        id: ID!
    ):  Organization!
}

extend type Mutation{
    """
    Create a new organization
    """
    createOrganization(
        """
        values of the organization
        """
        input: CreateOrganizationInput!
    ): OrganizationCreatePayload!
    """
    Update an existing organization
    """
    updateOrganization(
        """
        ID of the organization
        """
        id: ID!
        """
        New values for the organization
        """
        input: UpdateOrganizationInput!
    ): OrganizationUpdatePayload!
    """
    Delete an existing organization
    """
    deleteOrganization(
        """
        ID of the organization
        """
        id: ID!
    ): OrganizationDeletePayload!
}

"""
Return response for createOrganization mutation
"""
type OrganizationCreatePayload {
    """
    Created organization
    """
    organization: Organization!
}

"""
Return response for updateOrganization mutation
"""
type OrganizationUpdatePayload {
    """
    Updated organization
    """
    organization: Organization!
}

"""
Return response for deleteOrganization mutation
"""
type OrganizationDeletePayload {
    """
    Deleted organization ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/organizationsetting.graphql", Input: `extend type Query {
    """
    Look up organizationSetting by ID
    """
     organizationSetting(
        """
        ID of the organizationSetting
        """
        id: ID!
    ):  OrganizationSetting!
}

extend type Mutation{
    """
    Create a new organizationSetting
    """
    createOrganizationSetting(
        """
        values of the organizationSetting
        """
        input: CreateOrganizationSettingInput!
    ): OrganizationSettingCreatePayload!
    """
    Update an existing organizationSetting
    """
    updateOrganizationSetting(
        """
        ID of the organizationSetting
        """
        id: ID!
        """
        New values for the organizationSetting
        """
        input: UpdateOrganizationSettingInput!
    ): OrganizationSettingUpdatePayload!
    """
    Delete an existing organizationSetting
    """
    deleteOrganizationSetting(
        """
        ID of the organizationSetting
        """
        id: ID!
    ): OrganizationSettingDeletePayload!
}

"""
Return response for createOrganizationSetting mutation
"""
type OrganizationSettingCreatePayload {
    """
    Created organizationSetting
    """
    organizationSetting: OrganizationSetting!
}

"""
Return response for updateOrganizationSetting mutation
"""
type OrganizationSettingUpdatePayload {
    """
    Updated organizationSetting
    """
    organizationSetting: OrganizationSetting!
}

"""
Return response for deleteOrganizationSetting mutation
"""
type OrganizationSettingDeletePayload {
    """
    Deleted organizationSetting ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/personalaccesstoken.graphql", Input: `extend type Query {
    """
    Look up personalAccessToken by ID
    """
     personalAccessToken(
        """
        ID of the personalAccessToken
        """
        id: ID!
    ):  PersonalAccessToken!
}

extend type Mutation{
    """
    Create a new personalAccessToken
    """
    createPersonalAccessToken(
        """
        values of the personalAccessToken
        """
        input: CreatePersonalAccessTokenInput!
    ): PersonalAccessTokenCreatePayload!
    """
    Update an existing PersonalAccessToken
    """
    updatePersonalAccessToken(
        """
        ID of the personalAccessToken
        """
        id: ID!
        """
        New values for the personalAccessToken
        """
        input: UpdatePersonalAccessTokenInput!
    ): PersonalAccessTokenUpdatePayload!
    """
    Delete an existing PersonalAccessToken
    """
    deletePersonalAccessToken(
        """
        ID of the personalAccessToken
        """
        id: ID!
    ): PersonalAccessTokenDeletePayload!
}

"""
Return response for createPersonalAccessToken mutation
"""
type PersonalAccessTokenCreatePayload {
    """
    Created personalAccessToken
    """
    PersonalAccessToken: PersonalAccessToken!
}

"""
Return response for updatePersonalAccessToken mutation
"""
type PersonalAccessTokenUpdatePayload {
    """
    Updated personalAccessToken
    """
    PersonalAccessToken: PersonalAccessToken!
}

"""
Return response for deletePersonalAccessToken mutation
"""
type PersonalAccessTokenDeletePayload {
    """
    Deleted personalAccessToken ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/session.graphql", Input: `extend type Query {
    """
    Look up session by ID
    """
     session(
        """
        ID of the session
        """
        id: ID!
    ):  Session!
}

extend type Mutation{
    """
    Create a new session
    """
    createSession(
        """
        values of the session
        """
        input: CreateSessionInput!
    ): SessionCreatePayload!
    """
    Update an existing session
    """
    updateSession(
        """
        ID of the session
        """
        id: ID!
        """
        New values for the session
        """
        input: UpdateSessionInput!
    ): SessionUpdatePayload!
    """
    Delete an existing session
    """
    deleteSession(
        """
        ID of the session
        """
        id: ID!
    ): SessionDeletePayload!
}

"""
Return response for createSession mutation
"""
type SessionCreatePayload {
    """
    Created session
    """
    session: Session!
}

"""
Return response for updateSession mutation
"""
type SessionUpdatePayload {
    """
    Updated session
    """
    session: Session!
}

"""
Return response for deleteSession mutation
"""
type SessionDeletePayload {
    """
    Deleted session ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/user.graphql", Input: `extend type Query {
    """
    Look up user by ID
    """
     user(
        """
        ID of the user
        """
        id: ID!
    ):  User!
}

extend type Mutation{
    """
    Create a new user
    """
    createUser(
        """
        values of the user
        """
        input: CreateUserInput!
    ): UserCreatePayload!
    """
    Update an existing user
    """
    updateUser(
        """
        ID of the user
        """
        id: ID!
        """
        New values for the user
        """
        input: UpdateUserInput!
    ): UserUpdatePayload!
    """
    Delete an existing user
    """
    deleteUser(
        """
        ID of the user
        """
        id: ID!
    ): UserDeletePayload!
}

"""
Return response for createUser mutation
"""
type UserCreatePayload {
    """
    Created user
    """
    user: User!
}

"""
Return response for updateUser mutation
"""
type UserUpdatePayload {
    """
    Updated user
    """
    user: User!
}

"""
Return response for deleteUser mutation
"""
type UserDeletePayload {
    """
    Deleted user ID
    """
    deletedID: ID!
}`, BuiltIn: false},
	{Name: "../../schema/usersetting.graphql", Input: `extend type Query {
    """
    Look up userSetting by ID
    """
     userSetting(
        """
        ID of the UserSetting
        """
        id: ID!
    ):  UserSetting!
}

extend type Mutation{
    """
    Create a new userSetting
    """
    createUserSetting(
        """
        values of the userSetting
        """
        input: CreateUserSettingInput!
    ): UserSettingCreatePayload!
    """
    Update an existing userSetting
    """
    updateUserSetting(
        """
        ID of the userSetting
        """
        id: ID!
        """
        New values for the userSetting
        """
        input: UpdateUserSettingInput!
    ): UserSettingUpdatePayload!
    """
    Delete an existing userSetting
    """
    deleteUserSetting(
        """
        ID of the userSetting
        """
        id: ID!
    ): UserSettingDeletePayload!
}

"""
Return response for createUserSetting mutation
"""
type UserSettingCreatePayload {
    """
    Created userSetting
    """
    UserSetting: UserSetting!
}

"""
Return response for updateUserSetting mutation
"""
type UserSettingUpdatePayload {
    """
    Updated userSetting
    """
    UserSetting: UserSetting!
}

"""
Return response for deleteUserSetting mutation
"""
type UserSettingDeletePayload {
    """
    Deleted userSetting ID
    """
    deletedID: ID!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createEntitlement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateEntitlementInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateEntitlementInput2githubcomdatumforgedatuminternalentgeneratedCreateEntitlementInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGroupSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateGroupSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateGroupSettingInput2githubcomdatumforgedatuminternalentgeneratedCreateGroupSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateGroupInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateGroupInput2githubcomdatumforgedatuminternalentgeneratedCreateGroupInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createIntegration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateIntegrationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateIntegrationInput2githubcomdatumforgedatuminternalentgeneratedCreateIntegrationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOauthProvider_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateOauthProviderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateOauthProviderInput2githubcomdatumforgedatuminternalentgeneratedCreateOauthProviderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOhAuthTooToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateOhAuthTooTokenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateOhAuthTooTokenInput2githubcomdatumforgedatuminternalentgeneratedCreateOhAuthTooTokenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOrganizationSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateOrganizationSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateOrganizationSettingInput2githubcomdatumforgedatuminternalentgeneratedCreateOrganizationSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOrganization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateOrganizationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateOrganizationInput2githubcomdatumforgedatuminternalentgeneratedCreateOrganizationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPersonalAccessToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreatePersonalAccessTokenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreatePersonalAccessTokenInput2githubcomdatumforgedatuminternalentgeneratedCreatePersonalAccessTokenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateSessionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateSessionInput2githubcomdatumforgedatuminternalentgeneratedCreateSessionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUserSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateUserSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateUserSettingInput2githubcomdatumforgedatuminternalentgeneratedCreateUserSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 generated.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateUserInput2githubcomdatumforgedatuminternalentgeneratedCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEntitlement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGroupSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteIntegration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOauthProvider_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOhAuthTooToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOrganizationSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOrganization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePersonalAccessToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUserSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEntitlement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateEntitlementInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateEntitlementInput2githubcomdatumforgedatuminternalentgeneratedUpdateEntitlementInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGroupSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateGroupSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateGroupSettingInput2githubcomdatumforgedatuminternalentgeneratedUpdateGroupSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateGroupInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateGroupInput2githubcomdatumforgedatuminternalentgeneratedUpdateGroupInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateIntegration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateIntegrationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateIntegrationInput2githubcomdatumforgedatuminternalentgeneratedUpdateIntegrationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOauthProvider_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateOauthProviderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateOauthProviderInput2githubcomdatumforgedatuminternalentgeneratedUpdateOauthProviderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOhAuthTooToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateOhAuthTooTokenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateOhAuthTooTokenInput2githubcomdatumforgedatuminternalentgeneratedUpdateOhAuthTooTokenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOrganizationSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateOrganizationSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateOrganizationSettingInput2githubcomdatumforgedatuminternalentgeneratedUpdateOrganizationSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOrganization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateOrganizationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateOrganizationInput2githubcomdatumforgedatuminternalentgeneratedUpdateOrganizationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePersonalAccessToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdatePersonalAccessTokenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdatePersonalAccessTokenInput2githubcomdatumforgedatuminternalentgeneratedUpdatePersonalAccessTokenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateSessionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateSessionInput2githubcomdatumforgedatuminternalentgeneratedUpdateSessionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateUserSettingInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateUserSettingInput2githubcomdatumforgedatuminternalentgeneratedUpdateUserSettingInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 generated.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateUserInput2githubcomdatumforgedatuminternalentgeneratedUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Organization_children_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.OrganizationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOOrganizationOrder2githubcomdatumforgedatuminternalentgeneratedOrganizationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.OrganizationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_entitlement_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_entitlements_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.EntitlementWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_groupSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_groupSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.GroupSettingWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_group_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.GroupOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOGroupOrder2githubcomdatumforgedatuminternalentgeneratedGroupOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.GroupWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_integration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_integrations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.IntegrationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOIntegrationOrder2githubcomdatumforgedatuminternalentgeneratedIntegrationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.IntegrationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_oauthProvider_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_oauthProviders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.OauthProviderWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_ohAuthTooToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ohAuthTooTokens_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.OhAuthTooTokenWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_organizationSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_organizationSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.OrganizationSettingWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_organizations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.OrganizationOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOOrganizationOrder2githubcomdatumforgedatuminternalentgeneratedOrganizationOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.OrganizationWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_personalAccessToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_personalAccessTokens_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.PersonalAccessTokenWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_session_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_sessions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.SessionWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_userSetting_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.UserSettingWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *generated.UserOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOUserOrder2githubcomdatumforgedatuminternalentgeneratedUserOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *generated.UserWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Entitlement_id(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_tier(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_tier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entitlement.Tier)
	fc.Result = res
	return ec.marshalNEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_tier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EntitlementTier does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_externalCustomerID(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_externalCustomerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalCustomerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_externalCustomerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_externalSubscriptionID(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_externalSubscriptionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalSubscriptionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_externalSubscriptionID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_expires(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_expires(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_expiresAt(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_cancelled(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_cancelled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cancelled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_cancelled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entitlement_owner(ctx context.Context, field graphql.CollectedField, obj *generated.Entitlement) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entitlement_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entitlement_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entitlement",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.EntitlementConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.EntitlementEdge)
	fc.Result = res
	return ec.marshalOEntitlementEdge2githubcomdatumforgedatuminternalentgeneratedEntitlementEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_EntitlementEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_EntitlementEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntitlementEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.EntitlementConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.EntitlementConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementCreatePayload_entitlement(ctx context.Context, field graphql.CollectedField, obj *EntitlementCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementCreatePayload_entitlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entitlement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Entitlement)
	fc.Result = res
	return ec.marshalNEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementCreatePayload_entitlement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entitlement_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Entitlement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Entitlement_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Entitlement_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Entitlement_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Entitlement_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Entitlement_deletedBy(ctx, field)
			case "tier":
				return ec.fieldContext_Entitlement_tier(ctx, field)
			case "externalCustomerID":
				return ec.fieldContext_Entitlement_externalCustomerID(ctx, field)
			case "externalSubscriptionID":
				return ec.fieldContext_Entitlement_externalSubscriptionID(ctx, field)
			case "expires":
				return ec.fieldContext_Entitlement_expires(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Entitlement_expiresAt(ctx, field)
			case "cancelled":
				return ec.fieldContext_Entitlement_cancelled(ctx, field)
			case "owner":
				return ec.fieldContext_Entitlement_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entitlement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *EntitlementDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.EntitlementEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Entitlement)
	fc.Result = res
	return ec.marshalOEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entitlement_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Entitlement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Entitlement_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Entitlement_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Entitlement_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Entitlement_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Entitlement_deletedBy(ctx, field)
			case "tier":
				return ec.fieldContext_Entitlement_tier(ctx, field)
			case "externalCustomerID":
				return ec.fieldContext_Entitlement_externalCustomerID(ctx, field)
			case "externalSubscriptionID":
				return ec.fieldContext_Entitlement_externalSubscriptionID(ctx, field)
			case "expires":
				return ec.fieldContext_Entitlement_expires(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Entitlement_expiresAt(ctx, field)
			case "cancelled":
				return ec.fieldContext_Entitlement_cancelled(ctx, field)
			case "owner":
				return ec.fieldContext_Entitlement_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entitlement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.EntitlementEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntitlementUpdatePayload_entitlement(ctx context.Context, field graphql.CollectedField, obj *EntitlementUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntitlementUpdatePayload_entitlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entitlement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Entitlement)
	fc.Result = res
	return ec.marshalNEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntitlementUpdatePayload_entitlement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntitlementUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entitlement_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Entitlement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Entitlement_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Entitlement_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Entitlement_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Entitlement_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Entitlement_deletedBy(ctx, field)
			case "tier":
				return ec.fieldContext_Entitlement_tier(ctx, field)
			case "externalCustomerID":
				return ec.fieldContext_Entitlement_externalCustomerID(ctx, field)
			case "externalSubscriptionID":
				return ec.fieldContext_Entitlement_externalSubscriptionID(ctx, field)
			case "expires":
				return ec.fieldContext_Entitlement_expires(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Entitlement_expiresAt(ctx, field)
			case "cancelled":
				return ec.fieldContext_Entitlement_cancelled(ctx, field)
			case "owner":
				return ec.fieldContext_Entitlement_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entitlement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_id(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_description(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_gravatarLogoURL(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_gravatarLogoURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GravatarLogoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_gravatarLogoURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_logoURL(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_logoURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_logoURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_displayName(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_setting(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_setting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Setting(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.GroupSetting)
	fc.Result = res
	return ec.marshalNGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_setting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GroupSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_GroupSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GroupSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_GroupSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_GroupSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GroupSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_GroupSetting_deletedBy(ctx, field)
			case "visibility":
				return ec.fieldContext_GroupSetting_visibility(ctx, field)
			case "joinPolicy":
				return ec.fieldContext_GroupSetting_joinPolicy(ctx, field)
			case "tags":
				return ec.fieldContext_GroupSetting_tags(ctx, field)
			case "syncToSlack":
				return ec.fieldContext_GroupSetting_syncToSlack(ctx, field)
			case "syncToGithub":
				return ec.fieldContext_GroupSetting_syncToGithub(ctx, field)
			case "group":
				return ec.fieldContext_GroupSetting_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_users(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.User)
	fc.Result = res
	return ec.marshalOUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_owner(ctx context.Context, field graphql.CollectedField, obj *generated.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.GroupConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.GroupEdge)
	fc.Result = res
	return ec.marshalOGroupEdge2githubcomdatumforgedatuminternalentgeneratedGroupEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GroupEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GroupEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.GroupConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.GroupConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupCreatePayload_group(ctx context.Context, field graphql.CollectedField, obj *GroupCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupCreatePayload_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Group)
	fc.Result = res
	return ec.marshalNGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupCreatePayload_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *GroupDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.GroupEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.GroupEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_id(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_visibility(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(groupsetting.Visibility)
	fc.Result = res
	return ec.marshalNGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GroupSettingVisibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_joinPolicy(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_joinPolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JoinPolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(groupsetting.JoinPolicy)
	fc.Result = res
	return ec.marshalNGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_joinPolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GroupSettingJoinPolicy does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_tags(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_syncToSlack(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_syncToSlack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncToSlack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_syncToSlack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_syncToGithub(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_syncToGithub(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncToGithub, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_syncToGithub(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSetting_group(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSetting_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSetting_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSetting",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.GroupSettingEdge)
	fc.Result = res
	return ec.marshalOGroupSettingEdge2githubcomdatumforgedatuminternalentgeneratedGroupSettingEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GroupSettingEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GroupSettingEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSettingEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingCreatePayload_groupSetting(ctx context.Context, field graphql.CollectedField, obj *GroupSettingCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingCreatePayload_groupSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupSetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.GroupSetting)
	fc.Result = res
	return ec.marshalNGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingCreatePayload_groupSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GroupSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_GroupSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GroupSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_GroupSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_GroupSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GroupSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_GroupSetting_deletedBy(ctx, field)
			case "visibility":
				return ec.fieldContext_GroupSetting_visibility(ctx, field)
			case "joinPolicy":
				return ec.fieldContext_GroupSetting_joinPolicy(ctx, field)
			case "tags":
				return ec.fieldContext_GroupSetting_tags(ctx, field)
			case "syncToSlack":
				return ec.fieldContext_GroupSetting_syncToSlack(ctx, field)
			case "syncToGithub":
				return ec.fieldContext_GroupSetting_syncToGithub(ctx, field)
			case "group":
				return ec.fieldContext_GroupSetting_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *GroupSettingDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSettingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.GroupSetting)
	fc.Result = res
	return ec.marshalOGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GroupSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_GroupSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GroupSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_GroupSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_GroupSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GroupSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_GroupSetting_deletedBy(ctx, field)
			case "visibility":
				return ec.fieldContext_GroupSetting_visibility(ctx, field)
			case "joinPolicy":
				return ec.fieldContext_GroupSetting_joinPolicy(ctx, field)
			case "tags":
				return ec.fieldContext_GroupSetting_tags(ctx, field)
			case "syncToSlack":
				return ec.fieldContext_GroupSetting_syncToSlack(ctx, field)
			case "syncToGithub":
				return ec.fieldContext_GroupSetting_syncToGithub(ctx, field)
			case "group":
				return ec.fieldContext_GroupSetting_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.GroupSettingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupSettingUpdatePayload_groupSetting(ctx context.Context, field graphql.CollectedField, obj *GroupSettingUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupSettingUpdatePayload_groupSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupSetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.GroupSetting)
	fc.Result = res
	return ec.marshalNGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupSettingUpdatePayload_groupSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupSettingUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GroupSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_GroupSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GroupSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_GroupSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_GroupSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GroupSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_GroupSetting_deletedBy(ctx, field)
			case "visibility":
				return ec.fieldContext_GroupSetting_visibility(ctx, field)
			case "joinPolicy":
				return ec.fieldContext_GroupSetting_joinPolicy(ctx, field)
			case "tags":
				return ec.fieldContext_GroupSetting_tags(ctx, field)
			case "syncToSlack":
				return ec.fieldContext_GroupSetting_syncToSlack(ctx, field)
			case "syncToGithub":
				return ec.fieldContext_GroupSetting_syncToGithub(ctx, field)
			case "group":
				return ec.fieldContext_GroupSetting_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupUpdatePayload_group(ctx context.Context, field graphql.CollectedField, obj *GroupUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupUpdatePayload_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Group)
	fc.Result = res
	return ec.marshalNGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupUpdatePayload_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_id(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_name(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_description(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_kind(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_secretName(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_secretName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecretName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_secretName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Integration_owner(ctx context.Context, field graphql.CollectedField, obj *generated.Integration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Integration_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Integration_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Integration",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.IntegrationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.IntegrationEdge)
	fc.Result = res
	return ec.marshalOIntegrationEdge2githubcomdatumforgedatuminternalentgeneratedIntegrationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_IntegrationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_IntegrationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.IntegrationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.IntegrationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationCreatePayload_integration(ctx context.Context, field graphql.CollectedField, obj *IntegrationCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationCreatePayload_integration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Integration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Integration)
	fc.Result = res
	return ec.marshalNIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationCreatePayload_integration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Integration_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Integration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Integration_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Integration_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Integration_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Integration_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Integration_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Integration_name(ctx, field)
			case "description":
				return ec.fieldContext_Integration_description(ctx, field)
			case "kind":
				return ec.fieldContext_Integration_kind(ctx, field)
			case "secretName":
				return ec.fieldContext_Integration_secretName(ctx, field)
			case "owner":
				return ec.fieldContext_Integration_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Integration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *IntegrationDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.IntegrationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Integration)
	fc.Result = res
	return ec.marshalOIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Integration_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Integration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Integration_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Integration_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Integration_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Integration_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Integration_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Integration_name(ctx, field)
			case "description":
				return ec.fieldContext_Integration_description(ctx, field)
			case "kind":
				return ec.fieldContext_Integration_kind(ctx, field)
			case "secretName":
				return ec.fieldContext_Integration_secretName(ctx, field)
			case "owner":
				return ec.fieldContext_Integration_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Integration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.IntegrationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IntegrationUpdatePayload_integration(ctx context.Context, field graphql.CollectedField, obj *IntegrationUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IntegrationUpdatePayload_integration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Integration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Integration)
	fc.Result = res
	return ec.marshalNIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IntegrationUpdatePayload_integration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IntegrationUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Integration_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Integration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Integration_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Integration_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Integration_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Integration_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Integration_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Integration_name(ctx, field)
			case "description":
				return ec.fieldContext_Integration_description(ctx, field)
			case "kind":
				return ec.fieldContext_Integration_kind(ctx, field)
			case "secretName":
				return ec.fieldContext_Integration_secretName(ctx, field)
			case "owner":
				return ec.fieldContext_Integration_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Integration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEntitlement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEntitlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEntitlement(rctx, fc.Args["input"].(generated.CreateEntitlementInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EntitlementCreatePayload)
	fc.Result = res
	return ec.marshalNEntitlementCreatePayload2githubcomdatumforgedatuminternalgraphapiEntitlementCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEntitlement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "entitlement":
				return ec.fieldContext_EntitlementCreatePayload_entitlement(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntitlementCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEntitlement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEntitlement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEntitlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEntitlement(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateEntitlementInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EntitlementUpdatePayload)
	fc.Result = res
	return ec.marshalNEntitlementUpdatePayload2githubcomdatumforgedatuminternalgraphapiEntitlementUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEntitlement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "entitlement":
				return ec.fieldContext_EntitlementUpdatePayload_entitlement(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntitlementUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEntitlement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEntitlement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEntitlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEntitlement(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EntitlementDeletePayload)
	fc.Result = res
	return ec.marshalNEntitlementDeletePayload2githubcomdatumforgedatuminternalgraphapiEntitlementDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEntitlement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_EntitlementDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntitlementDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEntitlement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateGroup(rctx, fc.Args["input"].(generated.CreateGroupInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GroupCreatePayload)
	fc.Result = res
	return ec.marshalNGroupCreatePayload2githubcomdatumforgedatuminternalgraphapiGroupCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "group":
				return ec.fieldContext_GroupCreatePayload_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateGroup(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateGroupInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GroupUpdatePayload)
	fc.Result = res
	return ec.marshalNGroupUpdatePayload2githubcomdatumforgedatuminternalgraphapiGroupUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "group":
				return ec.fieldContext_GroupUpdatePayload_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGroup(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GroupDeletePayload)
	fc.Result = res
	return ec.marshalNGroupDeletePayload2githubcomdatumforgedatuminternalgraphapiGroupDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_GroupDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createGroupSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createGroupSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateGroupSetting(rctx, fc.Args["input"].(generated.CreateGroupSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GroupSettingCreatePayload)
	fc.Result = res
	return ec.marshalNGroupSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createGroupSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupSetting":
				return ec.fieldContext_GroupSettingCreatePayload_groupSetting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSettingCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createGroupSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateGroupSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateGroupSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateGroupSetting(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateGroupSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GroupSettingUpdatePayload)
	fc.Result = res
	return ec.marshalNGroupSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateGroupSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupSetting":
				return ec.fieldContext_GroupSettingUpdatePayload_groupSetting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSettingUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateGroupSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGroupSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGroupSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGroupSetting(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*GroupSettingDeletePayload)
	fc.Result = res
	return ec.marshalNGroupSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGroupSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_GroupSettingDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSettingDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGroupSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createIntegration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createIntegration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateIntegration(rctx, fc.Args["input"].(generated.CreateIntegrationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationCreatePayload)
	fc.Result = res
	return ec.marshalNIntegrationCreatePayload2githubcomdatumforgedatuminternalgraphapiIntegrationCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createIntegration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "integration":
				return ec.fieldContext_IntegrationCreatePayload_integration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createIntegration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateIntegration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateIntegration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateIntegration(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateIntegrationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationUpdatePayload)
	fc.Result = res
	return ec.marshalNIntegrationUpdatePayload2githubcomdatumforgedatuminternalgraphapiIntegrationUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateIntegration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "integration":
				return ec.fieldContext_IntegrationUpdatePayload_integration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateIntegration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteIntegration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteIntegration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteIntegration(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*IntegrationDeletePayload)
	fc.Result = res
	return ec.marshalNIntegrationDeletePayload2githubcomdatumforgedatuminternalgraphapiIntegrationDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteIntegration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_IntegrationDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteIntegration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOauthProvider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOauthProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOauthProvider(rctx, fc.Args["input"].(generated.CreateOauthProviderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OauthProviderCreatePayload)
	fc.Result = res
	return ec.marshalNOauthProviderCreatePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOauthProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "OauthProvider":
				return ec.fieldContext_OauthProviderCreatePayload_OauthProvider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProviderCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOauthProvider_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOauthProvider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOauthProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOauthProvider(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateOauthProviderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OauthProviderUpdatePayload)
	fc.Result = res
	return ec.marshalNOauthProviderUpdatePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOauthProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "OauthProvider":
				return ec.fieldContext_OauthProviderUpdatePayload_OauthProvider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProviderUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOauthProvider_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOauthProvider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOauthProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteOauthProvider(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OauthProviderDeletePayload)
	fc.Result = res
	return ec.marshalNOauthProviderDeletePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOauthProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_OauthProviderDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProviderDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOauthProvider_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOhAuthTooToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOhAuthTooToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOhAuthTooToken(rctx, fc.Args["input"].(generated.CreateOhAuthTooTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OhAuthTooTokenCreatePayload)
	fc.Result = res
	return ec.marshalNOhAuthTooTokenCreatePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOhAuthTooToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ohAuthTooToken":
				return ec.fieldContext_OhAuthTooTokenCreatePayload_ohAuthTooToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooTokenCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOhAuthTooToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOhAuthTooToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOhAuthTooToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOhAuthTooToken(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateOhAuthTooTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OhAuthTooTokenUpdatePayload)
	fc.Result = res
	return ec.marshalNOhAuthTooTokenUpdatePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOhAuthTooToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ohAuthTooToken":
				return ec.fieldContext_OhAuthTooTokenUpdatePayload_ohAuthTooToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooTokenUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOhAuthTooToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOhAuthTooToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOhAuthTooToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteOhAuthTooToken(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OhAuthTooTokenDeletePayload)
	fc.Result = res
	return ec.marshalNOhAuthTooTokenDeletePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOhAuthTooToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_OhAuthTooTokenDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooTokenDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOhAuthTooToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOrganization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOrganization(rctx, fc.Args["input"].(generated.CreateOrganizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OrganizationCreatePayload)
	fc.Result = res
	return ec.marshalNOrganizationCreatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "organization":
				return ec.fieldContext_OrganizationCreatePayload_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOrganization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOrganization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOrganization(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateOrganizationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OrganizationUpdatePayload)
	fc.Result = res
	return ec.marshalNOrganizationUpdatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "organization":
				return ec.fieldContext_OrganizationUpdatePayload_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOrganization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOrganization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOrganization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteOrganization(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OrganizationDeletePayload)
	fc.Result = res
	return ec.marshalNOrganizationDeletePayload2githubcomdatumforgedatuminternalgraphapiOrganizationDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOrganization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_OrganizationDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOrganization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOrganizationSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOrganizationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOrganizationSetting(rctx, fc.Args["input"].(generated.CreateOrganizationSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OrganizationSettingCreatePayload)
	fc.Result = res
	return ec.marshalNOrganizationSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOrganizationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "organizationSetting":
				return ec.fieldContext_OrganizationSettingCreatePayload_organizationSetting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSettingCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOrganizationSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOrganizationSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOrganizationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOrganizationSetting(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateOrganizationSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OrganizationSettingUpdatePayload)
	fc.Result = res
	return ec.marshalNOrganizationSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOrganizationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "organizationSetting":
				return ec.fieldContext_OrganizationSettingUpdatePayload_organizationSetting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSettingUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOrganizationSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOrganizationSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOrganizationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteOrganizationSetting(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*OrganizationSettingDeletePayload)
	fc.Result = res
	return ec.marshalNOrganizationSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOrganizationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_OrganizationSettingDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSettingDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOrganizationSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPersonalAccessToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPersonalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePersonalAccessToken(rctx, fc.Args["input"].(generated.CreatePersonalAccessTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PersonalAccessTokenCreatePayload)
	fc.Result = res
	return ec.marshalNPersonalAccessTokenCreatePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPersonalAccessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "PersonalAccessToken":
				return ec.fieldContext_PersonalAccessTokenCreatePayload_PersonalAccessToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessTokenCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPersonalAccessToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePersonalAccessToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePersonalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePersonalAccessToken(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdatePersonalAccessTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PersonalAccessTokenUpdatePayload)
	fc.Result = res
	return ec.marshalNPersonalAccessTokenUpdatePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePersonalAccessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "PersonalAccessToken":
				return ec.fieldContext_PersonalAccessTokenUpdatePayload_PersonalAccessToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessTokenUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePersonalAccessToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deletePersonalAccessToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deletePersonalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePersonalAccessToken(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PersonalAccessTokenDeletePayload)
	fc.Result = res
	return ec.marshalNPersonalAccessTokenDeletePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deletePersonalAccessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_PersonalAccessTokenDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessTokenDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deletePersonalAccessToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSession(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSession(rctx, fc.Args["input"].(generated.CreateSessionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SessionCreatePayload)
	fc.Result = res
	return ec.marshalNSessionCreatePayload2githubcomdatumforgedatuminternalgraphapiSessionCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "session":
				return ec.fieldContext_SessionCreatePayload_session(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SessionCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSession(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSession(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateSessionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SessionUpdatePayload)
	fc.Result = res
	return ec.marshalNSessionUpdatePayload2githubcomdatumforgedatuminternalgraphapiSessionUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "session":
				return ec.fieldContext_SessionUpdatePayload_session(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SessionUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSession(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSession(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SessionDeletePayload)
	fc.Result = res
	return ec.marshalNSessionDeletePayload2githubcomdatumforgedatuminternalgraphapiSessionDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSession(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_SessionDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SessionDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSession_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(generated.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserCreatePayload)
	fc.Result = res
	return ec.marshalNUserCreatePayload2githubcomdatumforgedatuminternalgraphapiUserCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserCreatePayload_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserUpdatePayload)
	fc.Result = res
	return ec.marshalNUserUpdatePayload2githubcomdatumforgedatuminternalgraphapiUserUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserUpdatePayload_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserDeletePayload)
	fc.Result = res
	return ec.marshalNUserDeletePayload2githubcomdatumforgedatuminternalgraphapiUserDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_UserDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUserSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUserSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUserSetting(rctx, fc.Args["input"].(generated.CreateUserSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserSettingCreatePayload)
	fc.Result = res
	return ec.marshalNUserSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiUserSettingCreatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUserSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "UserSetting":
				return ec.fieldContext_UserSettingCreatePayload_UserSetting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettingCreatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUserSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUserSetting(rctx, fc.Args["id"].(string), fc.Args["input"].(generated.UpdateUserSettingInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserSettingUpdatePayload)
	fc.Result = res
	return ec.marshalNUserSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiUserSettingUpdatePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "UserSetting":
				return ec.fieldContext_UserSettingUpdatePayload_UserSetting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettingUpdatePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUserSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUserSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUserSetting(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserSettingDeletePayload)
	fc.Result = res
	return ec.marshalNUserSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiUserSettingDeletePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUserSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedID":
				return ec.fieldContext_UserSettingDeletePayload_deletedID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettingDeletePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUserSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_id(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_name(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_clientID(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_clientID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_clientID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_clientSecret(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_redirectURL(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_redirectURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_redirectURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_scopes(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_scopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scopes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_scopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_authURL(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_authURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_authURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_tokenURL(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_tokenURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_tokenURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_authStyle(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_authStyle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OauthProvider().AuthStyle(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_authStyle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_infoURL(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_infoURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_infoURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProvider_owner(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProvider) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProvider_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProvider_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProvider",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.OauthProviderEdge)
	fc.Result = res
	return ec.marshalOOauthProviderEdge2githubcomdatumforgedatuminternalentgeneratedOauthProviderEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_OauthProviderEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_OauthProviderEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProviderEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProviderConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderCreatePayload_OauthProvider(ctx context.Context, field graphql.CollectedField, obj *OauthProviderCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderCreatePayload_OauthProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OauthProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OauthProvider)
	fc.Result = res
	return ec.marshalNOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderCreatePayload_OauthProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OauthProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OauthProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OauthProvider_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OauthProvider_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OauthProvider_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OauthProvider_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OauthProvider_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_OauthProvider_name(ctx, field)
			case "clientID":
				return ec.fieldContext_OauthProvider_clientID(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OauthProvider_clientSecret(ctx, field)
			case "redirectURL":
				return ec.fieldContext_OauthProvider_redirectURL(ctx, field)
			case "scopes":
				return ec.fieldContext_OauthProvider_scopes(ctx, field)
			case "authURL":
				return ec.fieldContext_OauthProvider_authURL(ctx, field)
			case "tokenURL":
				return ec.fieldContext_OauthProvider_tokenURL(ctx, field)
			case "authStyle":
				return ec.fieldContext_OauthProvider_authStyle(ctx, field)
			case "infoURL":
				return ec.fieldContext_OauthProvider_infoURL(ctx, field)
			case "owner":
				return ec.fieldContext_OauthProvider_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *OauthProviderDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProviderEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.OauthProvider)
	fc.Result = res
	return ec.marshalOOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OauthProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OauthProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OauthProvider_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OauthProvider_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OauthProvider_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OauthProvider_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OauthProvider_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_OauthProvider_name(ctx, field)
			case "clientID":
				return ec.fieldContext_OauthProvider_clientID(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OauthProvider_clientSecret(ctx, field)
			case "redirectURL":
				return ec.fieldContext_OauthProvider_redirectURL(ctx, field)
			case "scopes":
				return ec.fieldContext_OauthProvider_scopes(ctx, field)
			case "authURL":
				return ec.fieldContext_OauthProvider_authURL(ctx, field)
			case "tokenURL":
				return ec.fieldContext_OauthProvider_tokenURL(ctx, field)
			case "authStyle":
				return ec.fieldContext_OauthProvider_authStyle(ctx, field)
			case "infoURL":
				return ec.fieldContext_OauthProvider_infoURL(ctx, field)
			case "owner":
				return ec.fieldContext_OauthProvider_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.OauthProviderEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OauthProviderUpdatePayload_OauthProvider(ctx context.Context, field graphql.CollectedField, obj *OauthProviderUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OauthProviderUpdatePayload_OauthProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OauthProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OauthProvider)
	fc.Result = res
	return ec.marshalNOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OauthProviderUpdatePayload_OauthProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OauthProviderUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OauthProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OauthProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OauthProvider_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OauthProvider_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OauthProvider_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OauthProvider_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OauthProvider_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_OauthProvider_name(ctx, field)
			case "clientID":
				return ec.fieldContext_OauthProvider_clientID(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OauthProvider_clientSecret(ctx, field)
			case "redirectURL":
				return ec.fieldContext_OauthProvider_redirectURL(ctx, field)
			case "scopes":
				return ec.fieldContext_OauthProvider_scopes(ctx, field)
			case "authURL":
				return ec.fieldContext_OauthProvider_authURL(ctx, field)
			case "tokenURL":
				return ec.fieldContext_OauthProvider_tokenURL(ctx, field)
			case "authStyle":
				return ec.fieldContext_OauthProvider_authStyle(ctx, field)
			case "infoURL":
				return ec.fieldContext_OauthProvider_infoURL(ctx, field)
			case "owner":
				return ec.fieldContext_OauthProvider_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_id(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_clientID(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_clientID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_clientID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_scopes(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_scopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scopes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_scopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_nonce(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_nonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_nonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_claimsUserID(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_claimsUserID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimsUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_claimsUserID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_claimsUsername(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_claimsUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimsUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_claimsUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_claimsEmail(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_claimsEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimsEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_claimsEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_claimsEmailVerified(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_claimsEmailVerified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimsEmailVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_claimsEmailVerified(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_claimsGroups(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_claimsGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimsGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_claimsGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_claimsPreferredUsername(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_claimsPreferredUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClaimsPreferredUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_claimsPreferredUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_connectorID(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_connectorID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_connectorID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_connectorData(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_connectorData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectorData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_connectorData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooToken_lastUsed(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooToken_lastUsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUsed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooToken_lastUsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooTokenConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.OhAuthTooTokenEdge)
	fc.Result = res
	return ec.marshalOOhAuthTooTokenEdge2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_OhAuthTooTokenEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_OhAuthTooTokenEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooTokenEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooTokenConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooTokenConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenCreatePayload_ohAuthTooToken(ctx context.Context, field graphql.CollectedField, obj *OhAuthTooTokenCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenCreatePayload_ohAuthTooToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OhAuthTooToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OhAuthTooToken)
	fc.Result = res
	return ec.marshalNOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenCreatePayload_ohAuthTooToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OhAuthTooToken_id(ctx, field)
			case "clientID":
				return ec.fieldContext_OhAuthTooToken_clientID(ctx, field)
			case "scopes":
				return ec.fieldContext_OhAuthTooToken_scopes(ctx, field)
			case "nonce":
				return ec.fieldContext_OhAuthTooToken_nonce(ctx, field)
			case "claimsUserID":
				return ec.fieldContext_OhAuthTooToken_claimsUserID(ctx, field)
			case "claimsUsername":
				return ec.fieldContext_OhAuthTooToken_claimsUsername(ctx, field)
			case "claimsEmail":
				return ec.fieldContext_OhAuthTooToken_claimsEmail(ctx, field)
			case "claimsEmailVerified":
				return ec.fieldContext_OhAuthTooToken_claimsEmailVerified(ctx, field)
			case "claimsGroups":
				return ec.fieldContext_OhAuthTooToken_claimsGroups(ctx, field)
			case "claimsPreferredUsername":
				return ec.fieldContext_OhAuthTooToken_claimsPreferredUsername(ctx, field)
			case "connectorID":
				return ec.fieldContext_OhAuthTooToken_connectorID(ctx, field)
			case "connectorData":
				return ec.fieldContext_OhAuthTooToken_connectorData(ctx, field)
			case "lastUsed":
				return ec.fieldContext_OhAuthTooToken_lastUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *OhAuthTooTokenDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooTokenEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.OhAuthTooToken)
	fc.Result = res
	return ec.marshalOOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OhAuthTooToken_id(ctx, field)
			case "clientID":
				return ec.fieldContext_OhAuthTooToken_clientID(ctx, field)
			case "scopes":
				return ec.fieldContext_OhAuthTooToken_scopes(ctx, field)
			case "nonce":
				return ec.fieldContext_OhAuthTooToken_nonce(ctx, field)
			case "claimsUserID":
				return ec.fieldContext_OhAuthTooToken_claimsUserID(ctx, field)
			case "claimsUsername":
				return ec.fieldContext_OhAuthTooToken_claimsUsername(ctx, field)
			case "claimsEmail":
				return ec.fieldContext_OhAuthTooToken_claimsEmail(ctx, field)
			case "claimsEmailVerified":
				return ec.fieldContext_OhAuthTooToken_claimsEmailVerified(ctx, field)
			case "claimsGroups":
				return ec.fieldContext_OhAuthTooToken_claimsGroups(ctx, field)
			case "claimsPreferredUsername":
				return ec.fieldContext_OhAuthTooToken_claimsPreferredUsername(ctx, field)
			case "connectorID":
				return ec.fieldContext_OhAuthTooToken_connectorID(ctx, field)
			case "connectorData":
				return ec.fieldContext_OhAuthTooToken_connectorData(ctx, field)
			case "lastUsed":
				return ec.fieldContext_OhAuthTooToken_lastUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.OhAuthTooTokenEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OhAuthTooTokenUpdatePayload_ohAuthTooToken(ctx context.Context, field graphql.CollectedField, obj *OhAuthTooTokenUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OhAuthTooTokenUpdatePayload_ohAuthTooToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OhAuthTooToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OhAuthTooToken)
	fc.Result = res
	return ec.marshalNOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OhAuthTooTokenUpdatePayload_ohAuthTooToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OhAuthTooTokenUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OhAuthTooToken_id(ctx, field)
			case "clientID":
				return ec.fieldContext_OhAuthTooToken_clientID(ctx, field)
			case "scopes":
				return ec.fieldContext_OhAuthTooToken_scopes(ctx, field)
			case "nonce":
				return ec.fieldContext_OhAuthTooToken_nonce(ctx, field)
			case "claimsUserID":
				return ec.fieldContext_OhAuthTooToken_claimsUserID(ctx, field)
			case "claimsUsername":
				return ec.fieldContext_OhAuthTooToken_claimsUsername(ctx, field)
			case "claimsEmail":
				return ec.fieldContext_OhAuthTooToken_claimsEmail(ctx, field)
			case "claimsEmailVerified":
				return ec.fieldContext_OhAuthTooToken_claimsEmailVerified(ctx, field)
			case "claimsGroups":
				return ec.fieldContext_OhAuthTooToken_claimsGroups(ctx, field)
			case "claimsPreferredUsername":
				return ec.fieldContext_OhAuthTooToken_claimsPreferredUsername(ctx, field)
			case "connectorID":
				return ec.fieldContext_OhAuthTooToken_connectorID(ctx, field)
			case "connectorData":
				return ec.fieldContext_OhAuthTooToken_connectorData(ctx, field)
			case "lastUsed":
				return ec.fieldContext_OhAuthTooToken_lastUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_displayName(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_description(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_personalOrg(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_personalOrg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersonalOrg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_personalOrg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_parent(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_parent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_children(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Children(ctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.OrganizationOrder), fc.Args["where"].(*generated.OrganizationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationConnection)
	fc.Result = res
	return ec.marshalNOrganizationConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_OrganizationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_OrganizationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_OrganizationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Organization_children_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Organization_users(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.User)
	fc.Result = res
	return ec.marshalOUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_groups(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_integrations(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_integrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Integrations(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Integration)
	fc.Result = res
	return ec.marshalOIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_integrations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Integration_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Integration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Integration_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Integration_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Integration_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Integration_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Integration_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Integration_name(ctx, field)
			case "description":
				return ec.fieldContext_Integration_description(ctx, field)
			case "kind":
				return ec.fieldContext_Integration_kind(ctx, field)
			case "secretName":
				return ec.fieldContext_Integration_secretName(ctx, field)
			case "owner":
				return ec.fieldContext_Integration_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Integration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_setting(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_setting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Setting(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationSetting)
	fc.Result = res
	return ec.marshalOOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_setting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OrganizationSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OrganizationSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OrganizationSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OrganizationSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OrganizationSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OrganizationSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OrganizationSetting_deletedBy(ctx, field)
			case "domains":
				return ec.fieldContext_OrganizationSetting_domains(ctx, field)
			case "ssoCert":
				return ec.fieldContext_OrganizationSetting_ssoCert(ctx, field)
			case "ssoEntrypoint":
				return ec.fieldContext_OrganizationSetting_ssoEntrypoint(ctx, field)
			case "ssoIssuer":
				return ec.fieldContext_OrganizationSetting_ssoIssuer(ctx, field)
			case "billingContact":
				return ec.fieldContext_OrganizationSetting_billingContact(ctx, field)
			case "billingEmail":
				return ec.fieldContext_OrganizationSetting_billingEmail(ctx, field)
			case "billingPhone":
				return ec.fieldContext_OrganizationSetting_billingPhone(ctx, field)
			case "billingAddress":
				return ec.fieldContext_OrganizationSetting_billingAddress(ctx, field)
			case "taxIdentifier":
				return ec.fieldContext_OrganizationSetting_taxIdentifier(ctx, field)
			case "tags":
				return ec.fieldContext_OrganizationSetting_tags(ctx, field)
			case "organization":
				return ec.fieldContext_OrganizationSetting_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_entitlements(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_entitlements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entitlements(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Entitlement)
	fc.Result = res
	return ec.marshalOEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_entitlements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entitlement_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Entitlement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Entitlement_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Entitlement_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Entitlement_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Entitlement_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Entitlement_deletedBy(ctx, field)
			case "tier":
				return ec.fieldContext_Entitlement_tier(ctx, field)
			case "externalCustomerID":
				return ec.fieldContext_Entitlement_externalCustomerID(ctx, field)
			case "externalSubscriptionID":
				return ec.fieldContext_Entitlement_externalSubscriptionID(ctx, field)
			case "expires":
				return ec.fieldContext_Entitlement_expires(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Entitlement_expiresAt(ctx, field)
			case "cancelled":
				return ec.fieldContext_Entitlement_cancelled(ctx, field)
			case "owner":
				return ec.fieldContext_Entitlement_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entitlement", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_oauthprovider(ctx context.Context, field graphql.CollectedField, obj *generated.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_oauthprovider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Oauthprovider(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.OauthProvider)
	fc.Result = res
	return ec.marshalOOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_oauthprovider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OauthProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OauthProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OauthProvider_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OauthProvider_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OauthProvider_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OauthProvider_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OauthProvider_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_OauthProvider_name(ctx, field)
			case "clientID":
				return ec.fieldContext_OauthProvider_clientID(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OauthProvider_clientSecret(ctx, field)
			case "redirectURL":
				return ec.fieldContext_OauthProvider_redirectURL(ctx, field)
			case "scopes":
				return ec.fieldContext_OauthProvider_scopes(ctx, field)
			case "authURL":
				return ec.fieldContext_OauthProvider_authURL(ctx, field)
			case "tokenURL":
				return ec.fieldContext_OauthProvider_tokenURL(ctx, field)
			case "authStyle":
				return ec.fieldContext_OauthProvider_authStyle(ctx, field)
			case "infoURL":
				return ec.fieldContext_OauthProvider_infoURL(ctx, field)
			case "owner":
				return ec.fieldContext_OauthProvider_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.OrganizationEdge)
	fc.Result = res
	return ec.marshalOOrganizationEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_OrganizationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_OrganizationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationCreatePayload_organization(ctx context.Context, field graphql.CollectedField, obj *OrganizationCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationCreatePayload_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationCreatePayload_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *OrganizationDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_id(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_domains(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_domains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Domains, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_domains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_ssoCert(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_ssoCert(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSOCert, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_ssoCert(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_ssoEntrypoint(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_ssoEntrypoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSOEntrypoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_ssoEntrypoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_ssoIssuer(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_ssoIssuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSOIssuer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_ssoIssuer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_billingContact(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_billingContact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BillingContact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_billingContact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_billingEmail(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_billingEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BillingEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_billingEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_billingPhone(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_billingPhone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BillingPhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_billingPhone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_billingAddress(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_billingAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BillingAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_billingAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_taxIdentifier(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_taxIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaxIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_taxIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_tags(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSetting_organization(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSetting_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSetting_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSetting",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.OrganizationSettingEdge)
	fc.Result = res
	return ec.marshalOOrganizationSettingEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_OrganizationSettingEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_OrganizationSettingEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSettingEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingCreatePayload_organizationSetting(ctx context.Context, field graphql.CollectedField, obj *OrganizationSettingCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingCreatePayload_organizationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationSetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationSetting)
	fc.Result = res
	return ec.marshalNOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingCreatePayload_organizationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OrganizationSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OrganizationSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OrganizationSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OrganizationSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OrganizationSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OrganizationSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OrganizationSetting_deletedBy(ctx, field)
			case "domains":
				return ec.fieldContext_OrganizationSetting_domains(ctx, field)
			case "ssoCert":
				return ec.fieldContext_OrganizationSetting_ssoCert(ctx, field)
			case "ssoEntrypoint":
				return ec.fieldContext_OrganizationSetting_ssoEntrypoint(ctx, field)
			case "ssoIssuer":
				return ec.fieldContext_OrganizationSetting_ssoIssuer(ctx, field)
			case "billingContact":
				return ec.fieldContext_OrganizationSetting_billingContact(ctx, field)
			case "billingEmail":
				return ec.fieldContext_OrganizationSetting_billingEmail(ctx, field)
			case "billingPhone":
				return ec.fieldContext_OrganizationSetting_billingPhone(ctx, field)
			case "billingAddress":
				return ec.fieldContext_OrganizationSetting_billingAddress(ctx, field)
			case "taxIdentifier":
				return ec.fieldContext_OrganizationSetting_taxIdentifier(ctx, field)
			case "tags":
				return ec.fieldContext_OrganizationSetting_tags(ctx, field)
			case "organization":
				return ec.fieldContext_OrganizationSetting_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *OrganizationSettingDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSettingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationSetting)
	fc.Result = res
	return ec.marshalOOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OrganizationSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OrganizationSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OrganizationSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OrganizationSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OrganizationSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OrganizationSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OrganizationSetting_deletedBy(ctx, field)
			case "domains":
				return ec.fieldContext_OrganizationSetting_domains(ctx, field)
			case "ssoCert":
				return ec.fieldContext_OrganizationSetting_ssoCert(ctx, field)
			case "ssoEntrypoint":
				return ec.fieldContext_OrganizationSetting_ssoEntrypoint(ctx, field)
			case "ssoIssuer":
				return ec.fieldContext_OrganizationSetting_ssoIssuer(ctx, field)
			case "billingContact":
				return ec.fieldContext_OrganizationSetting_billingContact(ctx, field)
			case "billingEmail":
				return ec.fieldContext_OrganizationSetting_billingEmail(ctx, field)
			case "billingPhone":
				return ec.fieldContext_OrganizationSetting_billingPhone(ctx, field)
			case "billingAddress":
				return ec.fieldContext_OrganizationSetting_billingAddress(ctx, field)
			case "taxIdentifier":
				return ec.fieldContext_OrganizationSetting_taxIdentifier(ctx, field)
			case "tags":
				return ec.fieldContext_OrganizationSetting_tags(ctx, field)
			case "organization":
				return ec.fieldContext_OrganizationSetting_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.OrganizationSettingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationSettingUpdatePayload_organizationSetting(ctx context.Context, field graphql.CollectedField, obj *OrganizationSettingUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationSettingUpdatePayload_organizationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationSetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationSetting)
	fc.Result = res
	return ec.marshalNOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationSettingUpdatePayload_organizationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationSettingUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OrganizationSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OrganizationSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OrganizationSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OrganizationSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OrganizationSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OrganizationSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OrganizationSetting_deletedBy(ctx, field)
			case "domains":
				return ec.fieldContext_OrganizationSetting_domains(ctx, field)
			case "ssoCert":
				return ec.fieldContext_OrganizationSetting_ssoCert(ctx, field)
			case "ssoEntrypoint":
				return ec.fieldContext_OrganizationSetting_ssoEntrypoint(ctx, field)
			case "ssoIssuer":
				return ec.fieldContext_OrganizationSetting_ssoIssuer(ctx, field)
			case "billingContact":
				return ec.fieldContext_OrganizationSetting_billingContact(ctx, field)
			case "billingEmail":
				return ec.fieldContext_OrganizationSetting_billingEmail(ctx, field)
			case "billingPhone":
				return ec.fieldContext_OrganizationSetting_billingPhone(ctx, field)
			case "billingAddress":
				return ec.fieldContext_OrganizationSetting_billingAddress(ctx, field)
			case "taxIdentifier":
				return ec.fieldContext_OrganizationSetting_taxIdentifier(ctx, field)
			case "tags":
				return ec.fieldContext_OrganizationSetting_tags(ctx, field)
			case "organization":
				return ec.fieldContext_OrganizationSetting_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OrganizationUpdatePayload_organization(ctx context.Context, field graphql.CollectedField, obj *OrganizationUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OrganizationUpdatePayload_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OrganizationUpdatePayload_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OrganizationUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[string])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[string])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_id(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_name(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_abilities(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_abilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_abilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_expiresAt(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_description(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_lastUsedAt(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_lastUsedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUsedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_lastUsedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessToken_owner(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessToken_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessToken_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessTokenConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.PersonalAccessTokenEdge)
	fc.Result = res
	return ec.marshalOPersonalAccessTokenEdge2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_PersonalAccessTokenEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_PersonalAccessTokenEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessTokenEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessTokenConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessTokenConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenCreatePayload_PersonalAccessToken(ctx context.Context, field graphql.CollectedField, obj *PersonalAccessTokenCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenCreatePayload_PersonalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersonalAccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.PersonalAccessToken)
	fc.Result = res
	return ec.marshalNPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenCreatePayload_PersonalAccessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PersonalAccessToken_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_PersonalAccessToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PersonalAccessToken_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_PersonalAccessToken_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_PersonalAccessToken_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_PersonalAccessToken_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_PersonalAccessToken_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_PersonalAccessToken_name(ctx, field)
			case "abilities":
				return ec.fieldContext_PersonalAccessToken_abilities(ctx, field)
			case "expiresAt":
				return ec.fieldContext_PersonalAccessToken_expiresAt(ctx, field)
			case "description":
				return ec.fieldContext_PersonalAccessToken_description(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_PersonalAccessToken_lastUsedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PersonalAccessToken_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *PersonalAccessTokenDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessTokenEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.PersonalAccessToken)
	fc.Result = res
	return ec.marshalOPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PersonalAccessToken_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_PersonalAccessToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PersonalAccessToken_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_PersonalAccessToken_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_PersonalAccessToken_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_PersonalAccessToken_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_PersonalAccessToken_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_PersonalAccessToken_name(ctx, field)
			case "abilities":
				return ec.fieldContext_PersonalAccessToken_abilities(ctx, field)
			case "expiresAt":
				return ec.fieldContext_PersonalAccessToken_expiresAt(ctx, field)
			case "description":
				return ec.fieldContext_PersonalAccessToken_description(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_PersonalAccessToken_lastUsedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PersonalAccessToken_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.PersonalAccessTokenEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersonalAccessTokenUpdatePayload_PersonalAccessToken(ctx context.Context, field graphql.CollectedField, obj *PersonalAccessTokenUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PersonalAccessTokenUpdatePayload_PersonalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersonalAccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.PersonalAccessToken)
	fc.Result = res
	return ec.marshalNPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PersonalAccessTokenUpdatePayload_PersonalAccessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersonalAccessTokenUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PersonalAccessToken_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_PersonalAccessToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PersonalAccessToken_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_PersonalAccessToken_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_PersonalAccessToken_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_PersonalAccessToken_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_PersonalAccessToken_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_PersonalAccessToken_name(ctx, field)
			case "abilities":
				return ec.fieldContext_PersonalAccessToken_abilities(ctx, field)
			case "expiresAt":
				return ec.fieldContext_PersonalAccessToken_expiresAt(ctx, field)
			case "description":
				return ec.fieldContext_PersonalAccessToken_description(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_PersonalAccessToken_lastUsedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PersonalAccessToken_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(generated.Noder)
	fc.Result = res
	return ec.marshalONode2githubcomdatumforgedatuminternalentgeneratedNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]generated.Noder)
	fc.Result = res
	return ec.marshalNNode2githubcomdatumforgedatuminternalentgeneratedNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_entitlements(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_entitlements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Entitlements(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.EntitlementWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.EntitlementConnection)
	fc.Result = res
	return ec.marshalNEntitlementConnection2githubcomdatumforgedatuminternalentgeneratedEntitlementConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_entitlements(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EntitlementConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EntitlementConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EntitlementConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntitlementConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_entitlements_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_groups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Groups(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.GroupOrder), fc.Args["where"].(*generated.GroupWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.GroupConnection)
	fc.Result = res
	return ec.marshalNGroupConnection2githubcomdatumforgedatuminternalentgeneratedGroupConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GroupConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GroupConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GroupConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_groups_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_groupSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_groupSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GroupSettings(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.GroupSettingWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.GroupSettingConnection)
	fc.Result = res
	return ec.marshalNGroupSettingConnection2githubcomdatumforgedatuminternalentgeneratedGroupSettingConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_groupSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GroupSettingConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GroupSettingConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_GroupSettingConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSettingConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_groupSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_integrations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_integrations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Integrations(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.IntegrationOrder), fc.Args["where"].(*generated.IntegrationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.IntegrationConnection)
	fc.Result = res
	return ec.marshalNIntegrationConnection2githubcomdatumforgedatuminternalentgeneratedIntegrationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_integrations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_IntegrationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_IntegrationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_IntegrationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IntegrationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_integrations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauthProviders(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauthProviders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OauthProviders(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.OauthProviderWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OauthProviderConnection)
	fc.Result = res
	return ec.marshalNOauthProviderConnection2githubcomdatumforgedatuminternalentgeneratedOauthProviderConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauthProviders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_OauthProviderConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_OauthProviderConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_OauthProviderConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProviderConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauthProviders_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ohAuthTooTokens(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ohAuthTooTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OhAuthTooTokens(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.OhAuthTooTokenWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OhAuthTooTokenConnection)
	fc.Result = res
	return ec.marshalNOhAuthTooTokenConnection2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ohAuthTooTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_OhAuthTooTokenConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_OhAuthTooTokenConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_OhAuthTooTokenConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooTokenConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ohAuthTooTokens_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organizations(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.OrganizationOrder), fc.Args["where"].(*generated.OrganizationWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationConnection)
	fc.Result = res
	return ec.marshalNOrganizationConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_OrganizationConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_OrganizationConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_OrganizationConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizationSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OrganizationSettings(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.OrganizationSettingWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationSettingConnection)
	fc.Result = res
	return ec.marshalNOrganizationSettingConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_OrganizationSettingConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_OrganizationSettingConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_OrganizationSettingConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSettingConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizationSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_personalAccessTokens(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_personalAccessTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PersonalAccessTokens(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.PersonalAccessTokenWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.PersonalAccessTokenConnection)
	fc.Result = res
	return ec.marshalNPersonalAccessTokenConnection2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_personalAccessTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PersonalAccessTokenConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PersonalAccessTokenConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PersonalAccessTokenConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessTokenConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_personalAccessTokens_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_sessions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_sessions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Sessions(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.SessionWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.SessionConnection)
	fc.Result = res
	return ec.marshalNSessionConnection2githubcomdatumforgedatuminternalentgeneratedSessionConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_sessions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SessionConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SessionConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_SessionConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SessionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_sessions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*generated.UserOrder), fc.Args["where"].(*generated.UserWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.UserConnection)
	fc.Result = res
	return ec.marshalNUserConnection2githubcomdatumforgedatuminternalentgeneratedUserConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UserConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UserConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UserConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserSettings(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*generated.UserSettingWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.UserSettingConnection)
	fc.Result = res
	return ec.marshalNUserSettingConnection2githubcomdatumforgedatuminternalentgeneratedUserSettingConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UserSettingConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UserSettingConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UserSettingConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettingConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_entitlement(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_entitlement(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Entitlement(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Entitlement)
	fc.Result = res
	return ec.marshalNEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_entitlement(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Entitlement_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Entitlement_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Entitlement_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Entitlement_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Entitlement_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Entitlement_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Entitlement_deletedBy(ctx, field)
			case "tier":
				return ec.fieldContext_Entitlement_tier(ctx, field)
			case "externalCustomerID":
				return ec.fieldContext_Entitlement_externalCustomerID(ctx, field)
			case "externalSubscriptionID":
				return ec.fieldContext_Entitlement_externalSubscriptionID(ctx, field)
			case "expires":
				return ec.fieldContext_Entitlement_expires(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Entitlement_expiresAt(ctx, field)
			case "cancelled":
				return ec.fieldContext_Entitlement_cancelled(ctx, field)
			case "owner":
				return ec.fieldContext_Entitlement_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entitlement", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_entitlement_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_group(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Group(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Group)
	fc.Result = res
	return ec.marshalNGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_group_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_groupSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_groupSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GroupSetting(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.GroupSetting)
	fc.Result = res
	return ec.marshalNGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_groupSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GroupSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_GroupSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_GroupSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_GroupSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_GroupSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_GroupSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_GroupSetting_deletedBy(ctx, field)
			case "visibility":
				return ec.fieldContext_GroupSetting_visibility(ctx, field)
			case "joinPolicy":
				return ec.fieldContext_GroupSetting_joinPolicy(ctx, field)
			case "tags":
				return ec.fieldContext_GroupSetting_tags(ctx, field)
			case "syncToSlack":
				return ec.fieldContext_GroupSetting_syncToSlack(ctx, field)
			case "syncToGithub":
				return ec.fieldContext_GroupSetting_syncToGithub(ctx, field)
			case "group":
				return ec.fieldContext_GroupSetting_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupSetting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_groupSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_integration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_integration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Integration(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Integration)
	fc.Result = res
	return ec.marshalNIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_integration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Integration_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Integration_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Integration_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Integration_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Integration_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Integration_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Integration_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Integration_name(ctx, field)
			case "description":
				return ec.fieldContext_Integration_description(ctx, field)
			case "kind":
				return ec.fieldContext_Integration_kind(ctx, field)
			case "secretName":
				return ec.fieldContext_Integration_secretName(ctx, field)
			case "owner":
				return ec.fieldContext_Integration_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Integration", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_integration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauthProvider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauthProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OauthProvider(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OauthProvider)
	fc.Result = res
	return ec.marshalNOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauthProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OauthProvider_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OauthProvider_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OauthProvider_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OauthProvider_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OauthProvider_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OauthProvider_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OauthProvider_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_OauthProvider_name(ctx, field)
			case "clientID":
				return ec.fieldContext_OauthProvider_clientID(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OauthProvider_clientSecret(ctx, field)
			case "redirectURL":
				return ec.fieldContext_OauthProvider_redirectURL(ctx, field)
			case "scopes":
				return ec.fieldContext_OauthProvider_scopes(ctx, field)
			case "authURL":
				return ec.fieldContext_OauthProvider_authURL(ctx, field)
			case "tokenURL":
				return ec.fieldContext_OauthProvider_tokenURL(ctx, field)
			case "authStyle":
				return ec.fieldContext_OauthProvider_authStyle(ctx, field)
			case "infoURL":
				return ec.fieldContext_OauthProvider_infoURL(ctx, field)
			case "owner":
				return ec.fieldContext_OauthProvider_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OauthProvider", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauthProvider_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ohAuthTooToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ohAuthTooToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OhAuthTooToken(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OhAuthTooToken)
	fc.Result = res
	return ec.marshalNOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ohAuthTooToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OhAuthTooToken_id(ctx, field)
			case "clientID":
				return ec.fieldContext_OhAuthTooToken_clientID(ctx, field)
			case "scopes":
				return ec.fieldContext_OhAuthTooToken_scopes(ctx, field)
			case "nonce":
				return ec.fieldContext_OhAuthTooToken_nonce(ctx, field)
			case "claimsUserID":
				return ec.fieldContext_OhAuthTooToken_claimsUserID(ctx, field)
			case "claimsUsername":
				return ec.fieldContext_OhAuthTooToken_claimsUsername(ctx, field)
			case "claimsEmail":
				return ec.fieldContext_OhAuthTooToken_claimsEmail(ctx, field)
			case "claimsEmailVerified":
				return ec.fieldContext_OhAuthTooToken_claimsEmailVerified(ctx, field)
			case "claimsGroups":
				return ec.fieldContext_OhAuthTooToken_claimsGroups(ctx, field)
			case "claimsPreferredUsername":
				return ec.fieldContext_OhAuthTooToken_claimsPreferredUsername(ctx, field)
			case "connectorID":
				return ec.fieldContext_OhAuthTooToken_connectorID(ctx, field)
			case "connectorData":
				return ec.fieldContext_OhAuthTooToken_connectorData(ctx, field)
			case "lastUsed":
				return ec.fieldContext_OhAuthTooToken_lastUsed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OhAuthTooToken", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ohAuthTooToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organization(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_organizationSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_organizationSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OrganizationSetting(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.OrganizationSetting)
	fc.Result = res
	return ec.marshalNOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_organizationSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_OrganizationSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_OrganizationSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OrganizationSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_OrganizationSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_OrganizationSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_OrganizationSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_OrganizationSetting_deletedBy(ctx, field)
			case "domains":
				return ec.fieldContext_OrganizationSetting_domains(ctx, field)
			case "ssoCert":
				return ec.fieldContext_OrganizationSetting_ssoCert(ctx, field)
			case "ssoEntrypoint":
				return ec.fieldContext_OrganizationSetting_ssoEntrypoint(ctx, field)
			case "ssoIssuer":
				return ec.fieldContext_OrganizationSetting_ssoIssuer(ctx, field)
			case "billingContact":
				return ec.fieldContext_OrganizationSetting_billingContact(ctx, field)
			case "billingEmail":
				return ec.fieldContext_OrganizationSetting_billingEmail(ctx, field)
			case "billingPhone":
				return ec.fieldContext_OrganizationSetting_billingPhone(ctx, field)
			case "billingAddress":
				return ec.fieldContext_OrganizationSetting_billingAddress(ctx, field)
			case "taxIdentifier":
				return ec.fieldContext_OrganizationSetting_taxIdentifier(ctx, field)
			case "tags":
				return ec.fieldContext_OrganizationSetting_tags(ctx, field)
			case "organization":
				return ec.fieldContext_OrganizationSetting_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OrganizationSetting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_organizationSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_personalAccessToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_personalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PersonalAccessToken(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.PersonalAccessToken)
	fc.Result = res
	return ec.marshalNPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_personalAccessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PersonalAccessToken_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_PersonalAccessToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PersonalAccessToken_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_PersonalAccessToken_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_PersonalAccessToken_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_PersonalAccessToken_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_PersonalAccessToken_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_PersonalAccessToken_name(ctx, field)
			case "abilities":
				return ec.fieldContext_PersonalAccessToken_abilities(ctx, field)
			case "expiresAt":
				return ec.fieldContext_PersonalAccessToken_expiresAt(ctx, field)
			case "description":
				return ec.fieldContext_PersonalAccessToken_description(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_PersonalAccessToken_lastUsedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PersonalAccessToken_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessToken", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_personalAccessToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_session(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_session(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Session(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Session)
	fc.Result = res
	return ec.marshalNSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_session(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Session_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Session_updatedBy(ctx, field)
			case "sessionToken":
				return ec.fieldContext_Session_sessionToken(ctx, field)
			case "issuedAt":
				return ec.fieldContext_Session_issuedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Session_expiresAt(ctx, field)
			case "organizationID":
				return ec.fieldContext_Session_organizationID(ctx, field)
			case "userID":
				return ec.fieldContext_Session_userID(ctx, field)
			case "owner":
				return ec.fieldContext_Session_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_session_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userSetting(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserSetting(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.UserSetting)
	fc.Result = res
	return ec.marshalNUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_UserSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_UserSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_UserSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_UserSetting_deletedBy(ctx, field)
			case "locked":
				return ec.fieldContext_UserSetting_locked(ctx, field)
			case "silencedAt":
				return ec.fieldContext_UserSetting_silencedAt(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_UserSetting_suspendedAt(ctx, field)
			case "status":
				return ec.fieldContext_UserSetting_status(ctx, field)
			case "role":
				return ec.fieldContext_UserSetting_role(ctx, field)
			case "permissions":
				return ec.fieldContext_UserSetting_permissions(ctx, field)
			case "emailConfirmed":
				return ec.fieldContext_UserSetting_emailConfirmed(ctx, field)
			case "tags":
				return ec.fieldContext_UserSetting_tags(ctx, field)
			case "user":
				return ec.fieldContext_UserSetting_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSetting", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userSetting_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_id(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_sessionToken(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_sessionToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SessionToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_sessionToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_issuedAt(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_issuedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssuedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_issuedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_expiresAt(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_expiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpiresAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_expiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_organizationID(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_organizationID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrganizationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_organizationID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_userID(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_owner(ctx context.Context, field graphql.CollectedField, obj *generated.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.SessionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.SessionEdge)
	fc.Result = res
	return ec.marshalOSessionEdge2githubcomdatumforgedatuminternalentgeneratedSessionEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SessionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SessionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SessionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.SessionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.SessionConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionCreatePayload_session(ctx context.Context, field graphql.CollectedField, obj *SessionCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionCreatePayload_session(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Session, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Session)
	fc.Result = res
	return ec.marshalNSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionCreatePayload_session(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Session_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Session_updatedBy(ctx, field)
			case "sessionToken":
				return ec.fieldContext_Session_sessionToken(ctx, field)
			case "issuedAt":
				return ec.fieldContext_Session_issuedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Session_expiresAt(ctx, field)
			case "organizationID":
				return ec.fieldContext_Session_organizationID(ctx, field)
			case "userID":
				return ec.fieldContext_Session_userID(ctx, field)
			case "owner":
				return ec.fieldContext_Session_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *SessionDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.SessionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.Session)
	fc.Result = res
	return ec.marshalOSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Session_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Session_updatedBy(ctx, field)
			case "sessionToken":
				return ec.fieldContext_Session_sessionToken(ctx, field)
			case "issuedAt":
				return ec.fieldContext_Session_issuedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Session_expiresAt(ctx, field)
			case "organizationID":
				return ec.fieldContext_Session_organizationID(ctx, field)
			case "userID":
				return ec.fieldContext_Session_userID(ctx, field)
			case "owner":
				return ec.fieldContext_Session_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.SessionEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionUpdatePayload_session(ctx context.Context, field graphql.CollectedField, obj *SessionUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionUpdatePayload_session(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Session, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.Session)
	fc.Result = res
	return ec.marshalNSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionUpdatePayload_session(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Session_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Session_updatedBy(ctx, field)
			case "sessionToken":
				return ec.fieldContext_Session_sessionToken(ctx, field)
			case "issuedAt":
				return ec.fieldContext_Session_issuedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Session_expiresAt(ctx, field)
			case "organizationID":
				return ec.fieldContext_Session_organizationID(ctx, field)
			case "userID":
				return ec.fieldContext_Session_userID(ctx, field)
			case "owner":
				return ec.fieldContext_Session_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_firstName(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_firstName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_firstName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastName(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarRemoteURL(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarRemoteURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarRemoteURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarRemoteURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarLocalFile(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarLocalFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarLocalFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarLocalFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_avatarUpdatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_avatarUpdatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarUpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_avatarUpdatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastSeen(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_lastSeen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSeen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastSeen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_password(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sub(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sub(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sub, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sub(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_oauth(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_oauth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Oauth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_oauth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_organizations(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_organizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organizations(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Organization)
	fc.Result = res
	return ec.marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_organizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Organization_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Organization_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Organization_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Organization_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Organization_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Organization_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Organization_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "displayName":
				return ec.fieldContext_Organization_displayName(ctx, field)
			case "description":
				return ec.fieldContext_Organization_description(ctx, field)
			case "personalOrg":
				return ec.fieldContext_Organization_personalOrg(ctx, field)
			case "parent":
				return ec.fieldContext_Organization_parent(ctx, field)
			case "children":
				return ec.fieldContext_Organization_children(ctx, field)
			case "users":
				return ec.fieldContext_Organization_users(ctx, field)
			case "groups":
				return ec.fieldContext_Organization_groups(ctx, field)
			case "integrations":
				return ec.fieldContext_Organization_integrations(ctx, field)
			case "setting":
				return ec.fieldContext_Organization_setting(ctx, field)
			case "entitlements":
				return ec.fieldContext_Organization_entitlements(ctx, field)
			case "oauthprovider":
				return ec.fieldContext_Organization_oauthprovider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_sessions(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_sessions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sessions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Session)
	fc.Result = res
	return ec.marshalOSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_sessions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Session_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Session_updatedBy(ctx, field)
			case "sessionToken":
				return ec.fieldContext_Session_sessionToken(ctx, field)
			case "issuedAt":
				return ec.fieldContext_Session_issuedAt(ctx, field)
			case "expiresAt":
				return ec.fieldContext_Session_expiresAt(ctx, field)
			case "organizationID":
				return ec.fieldContext_Session_organizationID(ctx, field)
			case "userID":
				return ec.fieldContext_Session_userID(ctx, field)
			case "owner":
				return ec.fieldContext_Session_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_groups(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Group_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Group_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Group_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_Group_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Group_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_Group_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			case "gravatarLogoURL":
				return ec.fieldContext_Group_gravatarLogoURL(ctx, field)
			case "logoURL":
				return ec.fieldContext_Group_logoURL(ctx, field)
			case "displayName":
				return ec.fieldContext_Group_displayName(ctx, field)
			case "setting":
				return ec.fieldContext_Group_setting(ctx, field)
			case "users":
				return ec.fieldContext_Group_users(ctx, field)
			case "owner":
				return ec.fieldContext_Group_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_personalAccessTokens(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_personalAccessTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersonalAccessTokens(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.PersonalAccessToken)
	fc.Result = res
	return ec.marshalOPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_personalAccessTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PersonalAccessToken_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_PersonalAccessToken_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_PersonalAccessToken_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_PersonalAccessToken_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_PersonalAccessToken_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_PersonalAccessToken_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_PersonalAccessToken_deletedBy(ctx, field)
			case "name":
				return ec.fieldContext_PersonalAccessToken_name(ctx, field)
			case "abilities":
				return ec.fieldContext_PersonalAccessToken_abilities(ctx, field)
			case "expiresAt":
				return ec.fieldContext_PersonalAccessToken_expiresAt(ctx, field)
			case "description":
				return ec.fieldContext_PersonalAccessToken_description(ctx, field)
			case "lastUsedAt":
				return ec.fieldContext_PersonalAccessToken_lastUsedAt(ctx, field)
			case "owner":
				return ec.fieldContext_PersonalAccessToken_owner(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersonalAccessToken", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_setting(ctx context.Context, field graphql.CollectedField, obj *generated.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_setting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Setting(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.UserSetting)
	fc.Result = res
	return ec.marshalNUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_setting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_UserSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_UserSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_UserSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_UserSetting_deletedBy(ctx, field)
			case "locked":
				return ec.fieldContext_UserSetting_locked(ctx, field)
			case "silencedAt":
				return ec.fieldContext_UserSetting_silencedAt(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_UserSetting_suspendedAt(ctx, field)
			case "status":
				return ec.fieldContext_UserSetting_status(ctx, field)
			case "role":
				return ec.fieldContext_UserSetting_role(ctx, field)
			case "permissions":
				return ec.fieldContext_UserSetting_permissions(ctx, field)
			case "emailConfirmed":
				return ec.fieldContext_UserSetting_emailConfirmed(ctx, field)
			case "tags":
				return ec.fieldContext_UserSetting_tags(ctx, field)
			case "user":
				return ec.fieldContext_UserSetting_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.UserEdge)
	fc.Result = res
	return ec.marshalOUserEdge2githubcomdatumforgedatuminternalentgeneratedUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.UserConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserCreatePayload_user(ctx context.Context, field graphql.CollectedField, obj *UserCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserCreatePayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserCreatePayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *UserDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalOUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_id(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_createdAt(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_updatedAt(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_createdBy(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_updatedBy(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_updatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_updatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_deletedAt(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_deletedBy(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_deletedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_deletedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_locked(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_locked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_locked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_silencedAt(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_silencedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SilencedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_silencedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_suspendedAt(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_suspendedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspendedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_suspendedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_status(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(usersetting.Status)
	fc.Result = res
	return ec.marshalNUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserSettingStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_role(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(usersetting.Role)
	fc.Result = res
	return ec.marshalNUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserSettingRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_permissions(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_emailConfirmed(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_emailConfirmed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailConfirmed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_emailConfirmed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_tags(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSetting_user(ctx context.Context, field graphql.CollectedField, obj *generated.UserSetting) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSetting_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalOUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSetting_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSetting",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingConnection_edges(ctx context.Context, field graphql.CollectedField, obj *generated.UserSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*generated.UserSettingEdge)
	fc.Result = res
	return ec.marshalOUserSettingEdge2githubcomdatumforgedatuminternalentgeneratedUserSettingEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserSettingEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserSettingEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettingEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *generated.UserSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *generated.UserSettingConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingCreatePayload_UserSetting(ctx context.Context, field graphql.CollectedField, obj *UserSettingCreatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingCreatePayload_UserSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.UserSetting)
	fc.Result = res
	return ec.marshalNUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingCreatePayload_UserSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingCreatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_UserSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_UserSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_UserSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_UserSetting_deletedBy(ctx, field)
			case "locked":
				return ec.fieldContext_UserSetting_locked(ctx, field)
			case "silencedAt":
				return ec.fieldContext_UserSetting_silencedAt(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_UserSetting_suspendedAt(ctx, field)
			case "status":
				return ec.fieldContext_UserSetting_status(ctx, field)
			case "role":
				return ec.fieldContext_UserSetting_role(ctx, field)
			case "permissions":
				return ec.fieldContext_UserSetting_permissions(ctx, field)
			case "emailConfirmed":
				return ec.fieldContext_UserSetting_emailConfirmed(ctx, field)
			case "tags":
				return ec.fieldContext_UserSetting_tags(ctx, field)
			case "user":
				return ec.fieldContext_UserSetting_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField, obj *UserSettingDeletePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingDeletePayload_deletedID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingDeletePayload_deletedID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingDeletePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingEdge_node(ctx context.Context, field graphql.CollectedField, obj *generated.UserSettingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*generated.UserSetting)
	fc.Result = res
	return ec.marshalOUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_UserSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_UserSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_UserSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_UserSetting_deletedBy(ctx, field)
			case "locked":
				return ec.fieldContext_UserSetting_locked(ctx, field)
			case "silencedAt":
				return ec.fieldContext_UserSetting_silencedAt(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_UserSetting_suspendedAt(ctx, field)
			case "status":
				return ec.fieldContext_UserSetting_status(ctx, field)
			case "role":
				return ec.fieldContext_UserSetting_role(ctx, field)
			case "permissions":
				return ec.fieldContext_UserSetting_permissions(ctx, field)
			case "emailConfirmed":
				return ec.fieldContext_UserSetting_emailConfirmed(ctx, field)
			case "tags":
				return ec.fieldContext_UserSetting_tags(ctx, field)
			case "user":
				return ec.fieldContext_UserSetting_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *generated.UserSettingEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettingUpdatePayload_UserSetting(ctx context.Context, field graphql.CollectedField, obj *UserSettingUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettingUpdatePayload_UserSetting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSetting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.UserSetting)
	fc.Result = res
	return ec.marshalNUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettingUpdatePayload_UserSetting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettingUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserSetting_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_UserSetting_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_UserSetting_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_UserSetting_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_UserSetting_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_UserSetting_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_UserSetting_deletedBy(ctx, field)
			case "locked":
				return ec.fieldContext_UserSetting_locked(ctx, field)
			case "silencedAt":
				return ec.fieldContext_UserSetting_silencedAt(ctx, field)
			case "suspendedAt":
				return ec.fieldContext_UserSetting_suspendedAt(ctx, field)
			case "status":
				return ec.fieldContext_UserSetting_status(ctx, field)
			case "role":
				return ec.fieldContext_UserSetting_role(ctx, field)
			case "permissions":
				return ec.fieldContext_UserSetting_permissions(ctx, field)
			case "emailConfirmed":
				return ec.fieldContext_UserSetting_emailConfirmed(ctx, field)
			case "tags":
				return ec.fieldContext_UserSetting_tags(ctx, field)
			case "user":
				return ec.fieldContext_UserSetting_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSetting", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserUpdatePayload_user(ctx context.Context, field graphql.CollectedField, obj *UserUpdatePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserUpdatePayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*generated.User)
	fc.Result = res
	return ec.marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserUpdatePayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserUpdatePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_User_createdBy(ctx, field)
			case "updatedBy":
				return ec.fieldContext_User_updatedBy(ctx, field)
			case "deletedAt":
				return ec.fieldContext_User_deletedAt(ctx, field)
			case "deletedBy":
				return ec.fieldContext_User_deletedBy(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "avatarRemoteURL":
				return ec.fieldContext_User_avatarRemoteURL(ctx, field)
			case "avatarLocalFile":
				return ec.fieldContext_User_avatarLocalFile(ctx, field)
			case "avatarUpdatedAt":
				return ec.fieldContext_User_avatarUpdatedAt(ctx, field)
			case "lastSeen":
				return ec.fieldContext_User_lastSeen(ctx, field)
			case "password":
				return ec.fieldContext_User_password(ctx, field)
			case "sub":
				return ec.fieldContext_User_sub(ctx, field)
			case "oauth":
				return ec.fieldContext_User_oauth(ctx, field)
			case "organizations":
				return ec.fieldContext_User_organizations(ctx, field)
			case "sessions":
				return ec.fieldContext_User_sessions(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "personalAccessTokens":
				return ec.fieldContext_User_personalAccessTokens(ctx, field)
			case "setting":
				return ec.fieldContext_User_setting(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateEntitlementInput(ctx context.Context, obj interface{}) (generated.CreateEntitlementInput, error) {
	var it generated.CreateEntitlementInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "tier", "externalCustomerID", "externalSubscriptionID", "expires", "expiresAt", "cancelled", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		case "externalCustomerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerID = data
		case "externalSubscriptionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionID = data
		case "expires":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expires"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expires = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "cancelled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancelled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cancelled = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateGroupInput(ctx context.Context, obj interface{}) (generated.CreateGroupInput, error) {
	var it generated.CreateGroupInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "name", "description", "gravatarLogoURL", "logoURL", "displayName", "settingID", "userIDs", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "gravatarLogoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gravatarLogoURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GravatarLogoURL = data
		case "logoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogoURL = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "settingID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settingID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettingID = data
		case "userIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDs = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateGroupSettingInput(ctx context.Context, obj interface{}) (generated.CreateGroupSettingInput, error) {
	var it generated.CreateGroupSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "visibility", "joinPolicy", "tags", "syncToSlack", "syncToGithub", "groupID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "visibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "joinPolicy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("joinPolicy"))
			data, err := ec.unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, v)
			if err != nil {
				return it, err
			}
			it.JoinPolicy = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "syncToSlack":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToSlack"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToSlack = data
		case "syncToGithub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToGithub"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToGithub = data
		case "groupID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateIntegrationInput(ctx context.Context, obj interface{}) (generated.CreateIntegrationInput, error) {
	var it generated.CreateIntegrationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "name", "description", "kind", "secretName", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "kind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "secretName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretName = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOauthProviderInput(ctx context.Context, obj interface{}) (generated.CreateOauthProviderInput, error) {
	var it generated.CreateOauthProviderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "name", "clientID", "clientSecret", "redirectURL", "scopes", "authURL", "tokenURL", "authStyle", "infoURL", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "clientID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecret = data
		case "redirectURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURL = data
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "authURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURL = data
		case "tokenURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURL = data
		case "authStyle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyle"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.CreateOauthProviderInput().AuthStyle(ctx, &it, data); err != nil {
				return it, err
			}
		case "infoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURL = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOhAuthTooTokenInput(ctx context.Context, obj interface{}) (generated.CreateOhAuthTooTokenInput, error) {
	var it generated.CreateOhAuthTooTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientID", "scopes", "nonce", "claimsUserID", "claimsUsername", "claimsEmail", "claimsEmailVerified", "claimsGroups", "claimsPreferredUsername", "connectorID", "connectorData", "lastUsed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "nonce":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		case "claimsUserID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserID = data
		case "claimsUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsername"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsername = data
		case "claimsEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmail"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmail = data
		case "claimsEmailVerified":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailVerified"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailVerified = data
		case "claimsGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsGroups"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsGroups = data
		case "claimsPreferredUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsername"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsername = data
		case "connectorID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorID = data
		case "connectorData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorData"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorData = data
		case "lastUsed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsed"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOrganizationInput(ctx context.Context, obj interface{}) (generated.CreateOrganizationInput, error) {
	var it generated.CreateOrganizationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "name", "displayName", "description", "personalOrg", "parentID", "userIDs", "groupIDs", "integrationIDs", "settingID", "entitlementIDs", "oauthproviderIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "personalOrg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalOrg"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersonalOrg = data
		case "parentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "userIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDs = data
		case "groupIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupIDs = data
		case "integrationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("integrationIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntegrationIDs = data
		case "settingID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settingID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettingID = data
		case "entitlementIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entitlementIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntitlementIDs = data
		case "oauthproviderIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauthproviderIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OauthproviderIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOrganizationSettingInput(ctx context.Context, obj interface{}) (generated.CreateOrganizationSettingInput, error) {
	var it generated.CreateOrganizationSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "domains", "ssoCert", "ssoEntrypoint", "ssoIssuer", "billingContact", "billingEmail", "billingPhone", "billingAddress", "taxIdentifier", "tags", "organizationID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "domains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Domains = data
		case "ssoCert":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCert"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCert = data
		case "ssoEntrypoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypoint"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypoint = data
		case "ssoIssuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuer = data
		case "billingContact":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContact"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContact = data
		case "billingEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmail"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmail = data
		case "billingPhone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhone = data
		case "billingAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddress"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddress = data
		case "taxIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifier"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifier = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "organizationID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePersonalAccessTokenInput(ctx context.Context, obj interface{}) (generated.CreatePersonalAccessTokenInput, error) {
	var it generated.CreatePersonalAccessTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "name", "token", "abilities", "expiresAt", "description", "lastUsedAt", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "lastUsedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAt = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSessionInput(ctx context.Context, obj interface{}) (generated.CreateSessionInput, error) {
	var it generated.CreateSessionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "sessionToken", "issuedAt", "expiresAt", "organizationID", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "sessionToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionToken"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionToken = data
		case "issuedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAt"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAt = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "organizationID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationID = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (generated.CreateUserInput, error) {
	var it generated.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "email", "firstName", "lastName", "displayName", "avatarRemoteURL", "avatarLocalFile", "avatarUpdatedAt", "lastSeen", "password", "sub", "oauth", "organizationIDs", "sessionIDs", "groupIDs", "personalAccessTokenIDs", "settingID", "emailVerificationTokenIDs", "resetTokenIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "firstName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstName = data
		case "lastName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastName = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "avatarRemoteURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURL = data
		case "avatarLocalFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFile"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFile = data
		case "avatarUpdatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAt = data
		case "lastSeen":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeen"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeen = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "sub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sub"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sub = data
		case "oauth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth = data
		case "organizationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDs = data
		case "sessionIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionIDs = data
		case "groupIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupIDs = data
		case "personalAccessTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalAccessTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersonalAccessTokenIDs = data
		case "settingID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settingID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettingID = data
		case "emailVerificationTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailVerificationTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailVerificationTokenIDs = data
		case "resetTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resetTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResetTokenIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserSettingInput(ctx context.Context, obj interface{}) (generated.CreateUserSettingInput, error) {
	var it generated.CreateUserSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"createdAt", "updatedAt", "createdBy", "updatedBy", "locked", "silencedAt", "suspendedAt", "recoveryCode", "status", "role", "permissions", "emailConfirmed", "tags", "userID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "locked":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locked"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locked = data
		case "silencedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAt = data
		case "suspendedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAt = data
		case "recoveryCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recoveryCode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RecoveryCode = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "permissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Permissions = data
		case "emailConfirmed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailConfirmed"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailConfirmed = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEntitlementWhereInput(ctx context.Context, obj interface{}) (generated.EntitlementWhereInput, error) {
	var it generated.EntitlementWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "tier", "tierNEQ", "tierIn", "tierNotIn", "externalCustomerID", "externalCustomerIDNEQ", "externalCustomerIDIn", "externalCustomerIDNotIn", "externalCustomerIDGT", "externalCustomerIDGTE", "externalCustomerIDLT", "externalCustomerIDLTE", "externalCustomerIDContains", "externalCustomerIDHasPrefix", "externalCustomerIDHasSuffix", "externalCustomerIDIsNil", "externalCustomerIDNotNil", "externalCustomerIDEqualFold", "externalCustomerIDContainsFold", "externalSubscriptionID", "externalSubscriptionIDNEQ", "externalSubscriptionIDIn", "externalSubscriptionIDNotIn", "externalSubscriptionIDGT", "externalSubscriptionIDGTE", "externalSubscriptionIDLT", "externalSubscriptionIDLTE", "externalSubscriptionIDContains", "externalSubscriptionIDHasPrefix", "externalSubscriptionIDHasSuffix", "externalSubscriptionIDIsNil", "externalSubscriptionIDNotNil", "externalSubscriptionIDEqualFold", "externalSubscriptionIDContainsFold", "expires", "expiresNEQ", "expiresAt", "expiresAtNEQ", "expiresAtIn", "expiresAtNotIn", "expiresAtGT", "expiresAtGTE", "expiresAtLT", "expiresAtLTE", "expiresAtIsNil", "expiresAtNotNil", "cancelled", "cancelledNEQ", "hasOwner", "hasOwnerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		case "tierNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNEQ"))
			data, err := ec.unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierNEQ = data
		case "tierIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierIn"))
			data, err := ec.unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierIn = data
		case "tierNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNotIn"))
			data, err := ec.unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierNotIn = data
		case "externalCustomerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerID = data
		case "externalCustomerIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDNEQ = data
		case "externalCustomerIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDIn = data
		case "externalCustomerIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDNotIn = data
		case "externalCustomerIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDGT = data
		case "externalCustomerIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDGTE = data
		case "externalCustomerIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDLT = data
		case "externalCustomerIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDLTE = data
		case "externalCustomerIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDContains = data
		case "externalCustomerIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDHasPrefix = data
		case "externalCustomerIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDHasSuffix = data
		case "externalCustomerIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDIsNil = data
		case "externalCustomerIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDNotNil = data
		case "externalCustomerIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDEqualFold = data
		case "externalCustomerIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerIDContainsFold = data
		case "externalSubscriptionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionID = data
		case "externalSubscriptionIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDNEQ = data
		case "externalSubscriptionIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDIn = data
		case "externalSubscriptionIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDNotIn = data
		case "externalSubscriptionIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDGT = data
		case "externalSubscriptionIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDGTE = data
		case "externalSubscriptionIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDLT = data
		case "externalSubscriptionIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDLTE = data
		case "externalSubscriptionIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDContains = data
		case "externalSubscriptionIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDHasPrefix = data
		case "externalSubscriptionIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDHasSuffix = data
		case "externalSubscriptionIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDIsNil = data
		case "externalSubscriptionIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDNotNil = data
		case "externalSubscriptionIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDEqualFold = data
		case "externalSubscriptionIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionIDContainsFold = data
		case "expires":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expires"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expires = data
		case "expiresNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresNEQ = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "expiresAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNEQ = data
		case "expiresAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtIn = data
		case "expiresAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNotIn = data
		case "expiresAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtGT = data
		case "expiresAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtGTE = data
		case "expiresAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtLT = data
		case "expiresAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtLTE = data
		case "expiresAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtIsNil = data
		case "expiresAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNotNil = data
		case "cancelled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancelled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cancelled = data
		case "cancelledNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancelledNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CancelledNEQ = data
		case "hasOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwner = data
		case "hasOwnerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwnerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupOrder(ctx context.Context, obj interface{}) (generated.GroupOrder, error) {
	var it generated.GroupOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNGroupOrderField2githubcomdatumforgedatuminternalentgeneratedGroupOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupSettingWhereInput(ctx context.Context, obj interface{}) (generated.GroupSettingWhereInput, error) {
	var it generated.GroupSettingWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "visibility", "visibilityNEQ", "visibilityIn", "visibilityNotIn", "joinPolicy", "joinPolicyNEQ", "joinPolicyIn", "joinPolicyNotIn", "syncToSlack", "syncToSlackNEQ", "syncToGithub", "syncToGithubNEQ", "hasGroup", "hasGroupWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "visibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "visibilityNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibilityNEQ"))
			data, err := ec.unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.VisibilityNEQ = data
		case "visibilityIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibilityIn"))
			data, err := ec.unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.VisibilityIn = data
		case "visibilityNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibilityNotIn"))
			data, err := ec.unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.VisibilityNotIn = data
		case "joinPolicy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("joinPolicy"))
			data, err := ec.unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, v)
			if err != nil {
				return it, err
			}
			it.JoinPolicy = data
		case "joinPolicyNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("joinPolicyNEQ"))
			data, err := ec.unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, v)
			if err != nil {
				return it, err
			}
			it.JoinPolicyNEQ = data
		case "joinPolicyIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("joinPolicyIn"))
			data, err := ec.unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, v)
			if err != nil {
				return it, err
			}
			it.JoinPolicyIn = data
		case "joinPolicyNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("joinPolicyNotIn"))
			data, err := ec.unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, v)
			if err != nil {
				return it, err
			}
			it.JoinPolicyNotIn = data
		case "syncToSlack":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToSlack"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToSlack = data
		case "syncToSlackNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToSlackNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToSlackNEQ = data
		case "syncToGithub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToGithub"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToGithub = data
		case "syncToGithubNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToGithubNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToGithubNEQ = data
		case "hasGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGroup"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGroup = data
		case "hasGroupWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGroupWith"))
			data, err := ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGroupWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupWhereInput(ctx context.Context, obj interface{}) (generated.GroupWhereInput, error) {
	var it generated.GroupWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "displayName", "displayNameNEQ", "displayNameIn", "displayNameNotIn", "displayNameGT", "displayNameGTE", "displayNameLT", "displayNameLTE", "displayNameContains", "displayNameHasPrefix", "displayNameHasSuffix", "displayNameEqualFold", "displayNameContainsFold", "hasSetting", "hasSettingWith", "hasUsers", "hasUsersWith", "hasOwner", "hasOwnerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "displayNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNEQ = data
		case "displayNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameIn = data
		case "displayNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNotIn = data
		case "displayNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGT = data
		case "displayNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGTE = data
		case "displayNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLT = data
		case "displayNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLTE = data
		case "displayNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContains = data
		case "displayNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasPrefix = data
		case "displayNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasSuffix = data
		case "displayNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameEqualFold = data
		case "displayNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContainsFold = data
		case "hasSetting":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSetting"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSetting = data
		case "hasSettingWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSettingWith"))
			data, err := ec.unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSettingWith = data
		case "hasUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsers = data
		case "hasUsersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsersWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsersWith = data
		case "hasOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwner = data
		case "hasOwnerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwnerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntegrationOrder(ctx context.Context, obj interface{}) (generated.IntegrationOrder, error) {
	var it generated.IntegrationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNIntegrationOrderField2githubcomdatumforgedatuminternalentgeneratedIntegrationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntegrationWhereInput(ctx context.Context, obj interface{}) (generated.IntegrationWhereInput, error) {
	var it generated.IntegrationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "kind", "kindNEQ", "kindIn", "kindNotIn", "kindGT", "kindGTE", "kindLT", "kindLTE", "kindContains", "kindHasPrefix", "kindHasSuffix", "kindIsNil", "kindNotNil", "kindEqualFold", "kindContainsFold", "secretName", "secretNameNEQ", "secretNameIn", "secretNameNotIn", "secretNameGT", "secretNameGTE", "secretNameLT", "secretNameLTE", "secretNameContains", "secretNameHasPrefix", "secretNameHasSuffix", "secretNameEqualFold", "secretNameContainsFold", "hasOwner", "hasOwnerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "kind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "kindNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindNEQ = data
		case "kindIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindIn = data
		case "kindNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindNotIn = data
		case "kindGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindGT = data
		case "kindGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindGTE = data
		case "kindLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindLT = data
		case "kindLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindLTE = data
		case "kindContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindContains = data
		case "kindHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindHasPrefix = data
		case "kindHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindHasSuffix = data
		case "kindIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindIsNil = data
		case "kindNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindNotNil = data
		case "kindEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindEqualFold = data
		case "kindContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kindContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KindContainsFold = data
		case "secretName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretName = data
		case "secretNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameNEQ = data
		case "secretNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameIn = data
		case "secretNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameNotIn = data
		case "secretNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameGT = data
		case "secretNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameGTE = data
		case "secretNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameLT = data
		case "secretNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameLTE = data
		case "secretNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameContains = data
		case "secretNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameHasPrefix = data
		case "secretNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameHasSuffix = data
		case "secretNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameEqualFold = data
		case "secretNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretNameContainsFold = data
		case "hasOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwner = data
		case "hasOwnerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwnerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOauthProviderWhereInput(ctx context.Context, obj interface{}) (generated.OauthProviderWhereInput, error) {
	var it generated.OauthProviderWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "clientID", "clientIDNEQ", "clientIDIn", "clientIDNotIn", "clientIDGT", "clientIDGTE", "clientIDLT", "clientIDLTE", "clientIDContains", "clientIDHasPrefix", "clientIDHasSuffix", "clientIDEqualFold", "clientIDContainsFold", "clientSecret", "clientSecretNEQ", "clientSecretIn", "clientSecretNotIn", "clientSecretGT", "clientSecretGTE", "clientSecretLT", "clientSecretLTE", "clientSecretContains", "clientSecretHasPrefix", "clientSecretHasSuffix", "clientSecretEqualFold", "clientSecretContainsFold", "redirectURL", "redirectURLNEQ", "redirectURLIn", "redirectURLNotIn", "redirectURLGT", "redirectURLGTE", "redirectURLLT", "redirectURLLTE", "redirectURLContains", "redirectURLHasPrefix", "redirectURLHasSuffix", "redirectURLEqualFold", "redirectURLContainsFold", "scopes", "scopesNEQ", "scopesIn", "scopesNotIn", "scopesGT", "scopesGTE", "scopesLT", "scopesLTE", "scopesContains", "scopesHasPrefix", "scopesHasSuffix", "scopesEqualFold", "scopesContainsFold", "authURL", "authURLNEQ", "authURLIn", "authURLNotIn", "authURLGT", "authURLGTE", "authURLLT", "authURLLTE", "authURLContains", "authURLHasPrefix", "authURLHasSuffix", "authURLEqualFold", "authURLContainsFold", "tokenURL", "tokenURLNEQ", "tokenURLIn", "tokenURLNotIn", "tokenURLGT", "tokenURLGTE", "tokenURLLT", "tokenURLLTE", "tokenURLContains", "tokenURLHasPrefix", "tokenURLHasSuffix", "tokenURLEqualFold", "tokenURLContainsFold", "authStyle", "authStyleNEQ", "authStyleIn", "authStyleNotIn", "authStyleGT", "authStyleGTE", "authStyleLT", "authStyleLTE", "infoURL", "infoURLNEQ", "infoURLIn", "infoURLNotIn", "infoURLGT", "infoURLGTE", "infoURLLT", "infoURLLTE", "infoURLContains", "infoURLHasPrefix", "infoURLHasSuffix", "infoURLEqualFold", "infoURLContainsFold", "hasOwner", "hasOwnerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "clientID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "clientIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDNEQ = data
		case "clientIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDIn = data
		case "clientIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDNotIn = data
		case "clientIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDGT = data
		case "clientIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDGTE = data
		case "clientIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDLT = data
		case "clientIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDLTE = data
		case "clientIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDContains = data
		case "clientIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDHasPrefix = data
		case "clientIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDHasSuffix = data
		case "clientIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDEqualFold = data
		case "clientIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDContainsFold = data
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecret = data
		case "clientSecretNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretNEQ = data
		case "clientSecretIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretIn = data
		case "clientSecretNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretNotIn = data
		case "clientSecretGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretGT = data
		case "clientSecretGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretGTE = data
		case "clientSecretLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretLT = data
		case "clientSecretLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretLTE = data
		case "clientSecretContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretContains = data
		case "clientSecretHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretHasPrefix = data
		case "clientSecretHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretHasSuffix = data
		case "clientSecretEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretEqualFold = data
		case "clientSecretContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecretContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecretContainsFold = data
		case "redirectURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURL = data
		case "redirectURLNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLNEQ = data
		case "redirectURLIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLIn = data
		case "redirectURLNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLNotIn = data
		case "redirectURLGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLGT = data
		case "redirectURLGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLGTE = data
		case "redirectURLLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLLT = data
		case "redirectURLLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLLTE = data
		case "redirectURLContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLContains = data
		case "redirectURLHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLHasPrefix = data
		case "redirectURLHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLHasSuffix = data
		case "redirectURLEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLEqualFold = data
		case "redirectURLContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURLContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURLContainsFold = data
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "scopesNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesNEQ = data
		case "scopesIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesIn = data
		case "scopesNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesNotIn = data
		case "scopesGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesGT = data
		case "scopesGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesGTE = data
		case "scopesLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesLT = data
		case "scopesLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesLTE = data
		case "scopesContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesContains = data
		case "scopesHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesHasPrefix = data
		case "scopesHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesHasSuffix = data
		case "scopesEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesEqualFold = data
		case "scopesContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopesContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScopesContainsFold = data
		case "authURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURL = data
		case "authURLNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLNEQ = data
		case "authURLIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLIn = data
		case "authURLNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLNotIn = data
		case "authURLGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLGT = data
		case "authURLGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLGTE = data
		case "authURLLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLLT = data
		case "authURLLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLLTE = data
		case "authURLContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLContains = data
		case "authURLHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLHasPrefix = data
		case "authURLHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLHasSuffix = data
		case "authURLEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLEqualFold = data
		case "authURLContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURLContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURLContainsFold = data
		case "tokenURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURL = data
		case "tokenURLNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLNEQ = data
		case "tokenURLIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLIn = data
		case "tokenURLNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLNotIn = data
		case "tokenURLGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLGT = data
		case "tokenURLGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLGTE = data
		case "tokenURLLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLLT = data
		case "tokenURLLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLLTE = data
		case "tokenURLContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLContains = data
		case "tokenURLHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLHasPrefix = data
		case "tokenURLHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLHasSuffix = data
		case "tokenURLEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLEqualFold = data
		case "tokenURLContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURLContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURLContainsFold = data
		case "authStyle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyle"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyle(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "authStyleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyleLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OauthProviderWhereInput().AuthStyleLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "infoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURL = data
		case "infoURLNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLNEQ = data
		case "infoURLIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLIn = data
		case "infoURLNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLNotIn = data
		case "infoURLGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLGT = data
		case "infoURLGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLGTE = data
		case "infoURLLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLLT = data
		case "infoURLLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLLTE = data
		case "infoURLContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLContains = data
		case "infoURLHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLHasPrefix = data
		case "infoURLHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLHasSuffix = data
		case "infoURLEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLEqualFold = data
		case "infoURLContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURLContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURLContainsFold = data
		case "hasOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwner = data
		case "hasOwnerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwnerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOhAuthTooTokenWhereInput(ctx context.Context, obj interface{}) (generated.OhAuthTooTokenWhereInput, error) {
	var it generated.OhAuthTooTokenWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "clientID", "clientIDNEQ", "clientIDIn", "clientIDNotIn", "clientIDGT", "clientIDGTE", "clientIDLT", "clientIDLTE", "clientIDContains", "clientIDHasPrefix", "clientIDHasSuffix", "clientIDEqualFold", "clientIDContainsFold", "nonce", "nonceNEQ", "nonceIn", "nonceNotIn", "nonceGT", "nonceGTE", "nonceLT", "nonceLTE", "nonceContains", "nonceHasPrefix", "nonceHasSuffix", "nonceEqualFold", "nonceContainsFold", "claimsUserID", "claimsUserIDNEQ", "claimsUserIDIn", "claimsUserIDNotIn", "claimsUserIDGT", "claimsUserIDGTE", "claimsUserIDLT", "claimsUserIDLTE", "claimsUserIDContains", "claimsUserIDHasPrefix", "claimsUserIDHasSuffix", "claimsUserIDEqualFold", "claimsUserIDContainsFold", "claimsUsername", "claimsUsernameNEQ", "claimsUsernameIn", "claimsUsernameNotIn", "claimsUsernameGT", "claimsUsernameGTE", "claimsUsernameLT", "claimsUsernameLTE", "claimsUsernameContains", "claimsUsernameHasPrefix", "claimsUsernameHasSuffix", "claimsUsernameEqualFold", "claimsUsernameContainsFold", "claimsEmail", "claimsEmailNEQ", "claimsEmailIn", "claimsEmailNotIn", "claimsEmailGT", "claimsEmailGTE", "claimsEmailLT", "claimsEmailLTE", "claimsEmailContains", "claimsEmailHasPrefix", "claimsEmailHasSuffix", "claimsEmailEqualFold", "claimsEmailContainsFold", "claimsEmailVerified", "claimsEmailVerifiedNEQ", "claimsPreferredUsername", "claimsPreferredUsernameNEQ", "claimsPreferredUsernameIn", "claimsPreferredUsernameNotIn", "claimsPreferredUsernameGT", "claimsPreferredUsernameGTE", "claimsPreferredUsernameLT", "claimsPreferredUsernameLTE", "claimsPreferredUsernameContains", "claimsPreferredUsernameHasPrefix", "claimsPreferredUsernameHasSuffix", "claimsPreferredUsernameEqualFold", "claimsPreferredUsernameContainsFold", "connectorID", "connectorIDNEQ", "connectorIDIn", "connectorIDNotIn", "connectorIDGT", "connectorIDGTE", "connectorIDLT", "connectorIDLTE", "connectorIDContains", "connectorIDHasPrefix", "connectorIDHasSuffix", "connectorIDEqualFold", "connectorIDContainsFold", "lastUsed", "lastUsedNEQ", "lastUsedIn", "lastUsedNotIn", "lastUsedGT", "lastUsedGTE", "lastUsedLT", "lastUsedLTE"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "clientID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "clientIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDNEQ = data
		case "clientIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDIn = data
		case "clientIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDNotIn = data
		case "clientIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDGT = data
		case "clientIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDGTE = data
		case "clientIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDLT = data
		case "clientIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDLTE = data
		case "clientIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDContains = data
		case "clientIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDHasPrefix = data
		case "clientIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDHasSuffix = data
		case "clientIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDEqualFold = data
		case "clientIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientIDContainsFold = data
		case "nonce":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		case "nonceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceNEQ = data
		case "nonceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceIn = data
		case "nonceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceNotIn = data
		case "nonceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceGT = data
		case "nonceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceGTE = data
		case "nonceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceLT = data
		case "nonceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceLTE = data
		case "nonceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceContains = data
		case "nonceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceHasPrefix = data
		case "nonceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceHasSuffix = data
		case "nonceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceEqualFold = data
		case "nonceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NonceContainsFold = data
		case "claimsUserID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserID = data
		case "claimsUserIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDNEQ = data
		case "claimsUserIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDIn = data
		case "claimsUserIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDNotIn = data
		case "claimsUserIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDGT = data
		case "claimsUserIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDGTE = data
		case "claimsUserIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDLT = data
		case "claimsUserIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDLTE = data
		case "claimsUserIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDContains = data
		case "claimsUserIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDHasPrefix = data
		case "claimsUserIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDHasSuffix = data
		case "claimsUserIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDEqualFold = data
		case "claimsUserIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserIDContainsFold = data
		case "claimsUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsername = data
		case "claimsUsernameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameNEQ = data
		case "claimsUsernameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameIn = data
		case "claimsUsernameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameNotIn = data
		case "claimsUsernameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameGT = data
		case "claimsUsernameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameGTE = data
		case "claimsUsernameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameLT = data
		case "claimsUsernameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameLTE = data
		case "claimsUsernameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameContains = data
		case "claimsUsernameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameHasPrefix = data
		case "claimsUsernameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameHasSuffix = data
		case "claimsUsernameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameEqualFold = data
		case "claimsUsernameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsernameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsernameContainsFold = data
		case "claimsEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmail"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmail = data
		case "claimsEmailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailNEQ = data
		case "claimsEmailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailIn = data
		case "claimsEmailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailNotIn = data
		case "claimsEmailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailGT = data
		case "claimsEmailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailGTE = data
		case "claimsEmailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailLT = data
		case "claimsEmailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailLTE = data
		case "claimsEmailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailContains = data
		case "claimsEmailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailHasPrefix = data
		case "claimsEmailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailHasSuffix = data
		case "claimsEmailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailEqualFold = data
		case "claimsEmailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailContainsFold = data
		case "claimsEmailVerified":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailVerified"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailVerified = data
		case "claimsEmailVerifiedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailVerifiedNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailVerifiedNEQ = data
		case "claimsPreferredUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsername = data
		case "claimsPreferredUsernameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameNEQ = data
		case "claimsPreferredUsernameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameIn = data
		case "claimsPreferredUsernameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameNotIn = data
		case "claimsPreferredUsernameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameGT = data
		case "claimsPreferredUsernameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameGTE = data
		case "claimsPreferredUsernameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameLT = data
		case "claimsPreferredUsernameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameLTE = data
		case "claimsPreferredUsernameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameContains = data
		case "claimsPreferredUsernameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameHasPrefix = data
		case "claimsPreferredUsernameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameHasSuffix = data
		case "claimsPreferredUsernameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameEqualFold = data
		case "claimsPreferredUsernameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsernameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsernameContainsFold = data
		case "connectorID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorID = data
		case "connectorIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDNEQ = data
		case "connectorIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDIn = data
		case "connectorIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDNotIn = data
		case "connectorIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDGT = data
		case "connectorIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDGTE = data
		case "connectorIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDLT = data
		case "connectorIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDLTE = data
		case "connectorIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDContains = data
		case "connectorIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDHasPrefix = data
		case "connectorIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDHasSuffix = data
		case "connectorIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDEqualFold = data
		case "connectorIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorIDContainsFold = data
		case "lastUsed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsed"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsed = data
		case "lastUsedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedNEQ = data
		case "lastUsedIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedIn = data
		case "lastUsedNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedNotIn = data
		case "lastUsedGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedGT = data
		case "lastUsedGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedGTE = data
		case "lastUsedLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedLT = data
		case "lastUsedLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedLTE = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrganizationOrder(ctx context.Context, obj interface{}) (generated.OrganizationOrder, error) {
	var it generated.OrganizationOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNOrganizationOrderField2githubcomdatumforgedatuminternalentgeneratedOrganizationOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrganizationSettingWhereInput(ctx context.Context, obj interface{}) (generated.OrganizationSettingWhereInput, error) {
	var it generated.OrganizationSettingWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "ssoCert", "ssoCertNEQ", "ssoCertIn", "ssoCertNotIn", "ssoCertGT", "ssoCertGTE", "ssoCertLT", "ssoCertLTE", "ssoCertContains", "ssoCertHasPrefix", "ssoCertHasSuffix", "ssoCertIsNil", "ssoCertNotNil", "ssoCertEqualFold", "ssoCertContainsFold", "ssoEntrypoint", "ssoEntrypointNEQ", "ssoEntrypointIn", "ssoEntrypointNotIn", "ssoEntrypointGT", "ssoEntrypointGTE", "ssoEntrypointLT", "ssoEntrypointLTE", "ssoEntrypointContains", "ssoEntrypointHasPrefix", "ssoEntrypointHasSuffix", "ssoEntrypointIsNil", "ssoEntrypointNotNil", "ssoEntrypointEqualFold", "ssoEntrypointContainsFold", "ssoIssuer", "ssoIssuerNEQ", "ssoIssuerIn", "ssoIssuerNotIn", "ssoIssuerGT", "ssoIssuerGTE", "ssoIssuerLT", "ssoIssuerLTE", "ssoIssuerContains", "ssoIssuerHasPrefix", "ssoIssuerHasSuffix", "ssoIssuerIsNil", "ssoIssuerNotNil", "ssoIssuerEqualFold", "ssoIssuerContainsFold", "billingContact", "billingContactNEQ", "billingContactIn", "billingContactNotIn", "billingContactGT", "billingContactGTE", "billingContactLT", "billingContactLTE", "billingContactContains", "billingContactHasPrefix", "billingContactHasSuffix", "billingContactIsNil", "billingContactNotNil", "billingContactEqualFold", "billingContactContainsFold", "billingEmail", "billingEmailNEQ", "billingEmailIn", "billingEmailNotIn", "billingEmailGT", "billingEmailGTE", "billingEmailLT", "billingEmailLTE", "billingEmailContains", "billingEmailHasPrefix", "billingEmailHasSuffix", "billingEmailIsNil", "billingEmailNotNil", "billingEmailEqualFold", "billingEmailContainsFold", "billingPhone", "billingPhoneNEQ", "billingPhoneIn", "billingPhoneNotIn", "billingPhoneGT", "billingPhoneGTE", "billingPhoneLT", "billingPhoneLTE", "billingPhoneContains", "billingPhoneHasPrefix", "billingPhoneHasSuffix", "billingPhoneIsNil", "billingPhoneNotNil", "billingPhoneEqualFold", "billingPhoneContainsFold", "billingAddress", "billingAddressNEQ", "billingAddressIn", "billingAddressNotIn", "billingAddressGT", "billingAddressGTE", "billingAddressLT", "billingAddressLTE", "billingAddressContains", "billingAddressHasPrefix", "billingAddressHasSuffix", "billingAddressIsNil", "billingAddressNotNil", "billingAddressEqualFold", "billingAddressContainsFold", "taxIdentifier", "taxIdentifierNEQ", "taxIdentifierIn", "taxIdentifierNotIn", "taxIdentifierGT", "taxIdentifierGTE", "taxIdentifierLT", "taxIdentifierLTE", "taxIdentifierContains", "taxIdentifierHasPrefix", "taxIdentifierHasSuffix", "taxIdentifierIsNil", "taxIdentifierNotNil", "taxIdentifierEqualFold", "taxIdentifierContainsFold", "hasOrganization", "hasOrganizationWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "ssoCert":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCert"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCert = data
		case "ssoCertNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertNEQ = data
		case "ssoCertIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertIn = data
		case "ssoCertNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertNotIn = data
		case "ssoCertGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertGT = data
		case "ssoCertGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertGTE = data
		case "ssoCertLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertLT = data
		case "ssoCertLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertLTE = data
		case "ssoCertContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertContains = data
		case "ssoCertHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertHasPrefix = data
		case "ssoCertHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertHasSuffix = data
		case "ssoCertIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertIsNil = data
		case "ssoCertNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertNotNil = data
		case "ssoCertEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertEqualFold = data
		case "ssoCertContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCertContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCertContainsFold = data
		case "ssoEntrypoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypoint"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypoint = data
		case "ssoEntrypointNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointNEQ = data
		case "ssoEntrypointIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointIn = data
		case "ssoEntrypointNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointNotIn = data
		case "ssoEntrypointGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointGT = data
		case "ssoEntrypointGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointGTE = data
		case "ssoEntrypointLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointLT = data
		case "ssoEntrypointLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointLTE = data
		case "ssoEntrypointContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointContains = data
		case "ssoEntrypointHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointHasPrefix = data
		case "ssoEntrypointHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointHasSuffix = data
		case "ssoEntrypointIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointIsNil = data
		case "ssoEntrypointNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointNotNil = data
		case "ssoEntrypointEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointEqualFold = data
		case "ssoEntrypointContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypointContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypointContainsFold = data
		case "ssoIssuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuer = data
		case "ssoIssuerNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerNEQ = data
		case "ssoIssuerIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerIn = data
		case "ssoIssuerNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerNotIn = data
		case "ssoIssuerGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerGT = data
		case "ssoIssuerGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerGTE = data
		case "ssoIssuerLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerLT = data
		case "ssoIssuerLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerLTE = data
		case "ssoIssuerContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerContains = data
		case "ssoIssuerHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerHasPrefix = data
		case "ssoIssuerHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerHasSuffix = data
		case "ssoIssuerIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerIsNil = data
		case "ssoIssuerNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerNotNil = data
		case "ssoIssuerEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerEqualFold = data
		case "ssoIssuerContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuerContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuerContainsFold = data
		case "billingContact":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContact"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContact = data
		case "billingContactNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactNEQ = data
		case "billingContactIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactIn = data
		case "billingContactNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactNotIn = data
		case "billingContactGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactGT = data
		case "billingContactGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactGTE = data
		case "billingContactLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactLT = data
		case "billingContactLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactLTE = data
		case "billingContactContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactContains = data
		case "billingContactHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactHasPrefix = data
		case "billingContactHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactHasSuffix = data
		case "billingContactIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactIsNil = data
		case "billingContactNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactNotNil = data
		case "billingContactEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactEqualFold = data
		case "billingContactContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContactContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContactContainsFold = data
		case "billingEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmail"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmail = data
		case "billingEmailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailNEQ = data
		case "billingEmailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailIn = data
		case "billingEmailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailNotIn = data
		case "billingEmailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailGT = data
		case "billingEmailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailGTE = data
		case "billingEmailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailLT = data
		case "billingEmailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailLTE = data
		case "billingEmailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailContains = data
		case "billingEmailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailHasPrefix = data
		case "billingEmailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailHasSuffix = data
		case "billingEmailIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailIsNil = data
		case "billingEmailNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailNotNil = data
		case "billingEmailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailEqualFold = data
		case "billingEmailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmailContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmailContainsFold = data
		case "billingPhone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhone = data
		case "billingPhoneNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneNEQ = data
		case "billingPhoneIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneIn = data
		case "billingPhoneNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneNotIn = data
		case "billingPhoneGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneGT = data
		case "billingPhoneGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneGTE = data
		case "billingPhoneLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneLT = data
		case "billingPhoneLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneLTE = data
		case "billingPhoneContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneContains = data
		case "billingPhoneHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneHasPrefix = data
		case "billingPhoneHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneHasSuffix = data
		case "billingPhoneIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneIsNil = data
		case "billingPhoneNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneNotNil = data
		case "billingPhoneEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneEqualFold = data
		case "billingPhoneContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhoneContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhoneContainsFold = data
		case "billingAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddress"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddress = data
		case "billingAddressNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressNEQ = data
		case "billingAddressIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressIn = data
		case "billingAddressNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressNotIn = data
		case "billingAddressGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressGT = data
		case "billingAddressGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressGTE = data
		case "billingAddressLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressLT = data
		case "billingAddressLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressLTE = data
		case "billingAddressContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressContains = data
		case "billingAddressHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressHasPrefix = data
		case "billingAddressHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressHasSuffix = data
		case "billingAddressIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressIsNil = data
		case "billingAddressNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressNotNil = data
		case "billingAddressEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressEqualFold = data
		case "billingAddressContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddressContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddressContainsFold = data
		case "taxIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifier"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifier = data
		case "taxIdentifierNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierNEQ = data
		case "taxIdentifierIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierIn = data
		case "taxIdentifierNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierNotIn = data
		case "taxIdentifierGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierGT = data
		case "taxIdentifierGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierGTE = data
		case "taxIdentifierLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierLT = data
		case "taxIdentifierLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierLTE = data
		case "taxIdentifierContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierContains = data
		case "taxIdentifierHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierHasPrefix = data
		case "taxIdentifierHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierHasSuffix = data
		case "taxIdentifierIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierIsNil = data
		case "taxIdentifierNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierNotNil = data
		case "taxIdentifierEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierEqualFold = data
		case "taxIdentifierContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifierContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifierContainsFold = data
		case "hasOrganization":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganization"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOrganization = data
		case "hasOrganizationWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganizationWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOrganizationWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOrganizationWhereInput(ctx context.Context, obj interface{}) (generated.OrganizationWhereInput, error) {
	var it generated.OrganizationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "displayName", "displayNameNEQ", "displayNameIn", "displayNameNotIn", "displayNameGT", "displayNameGTE", "displayNameLT", "displayNameLTE", "displayNameContains", "displayNameHasPrefix", "displayNameHasSuffix", "displayNameEqualFold", "displayNameContainsFold", "parentOrganizationID", "parentOrganizationIDNEQ", "parentOrganizationIDIn", "parentOrganizationIDNotIn", "parentOrganizationIDGT", "parentOrganizationIDGTE", "parentOrganizationIDLT", "parentOrganizationIDLTE", "parentOrganizationIDContains", "parentOrganizationIDHasPrefix", "parentOrganizationIDHasSuffix", "parentOrganizationIDIsNil", "parentOrganizationIDNotNil", "parentOrganizationIDEqualFold", "parentOrganizationIDContainsFold", "personalOrg", "personalOrgNEQ", "hasParent", "hasParentWith", "hasChildren", "hasChildrenWith", "hasUsers", "hasUsersWith", "hasGroups", "hasGroupsWith", "hasIntegrations", "hasIntegrationsWith", "hasSetting", "hasSettingWith", "hasEntitlements", "hasEntitlementsWith", "hasOauthprovider", "hasOauthproviderWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "displayNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNEQ = data
		case "displayNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameIn = data
		case "displayNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNotIn = data
		case "displayNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGT = data
		case "displayNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGTE = data
		case "displayNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLT = data
		case "displayNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLTE = data
		case "displayNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContains = data
		case "displayNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasPrefix = data
		case "displayNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasSuffix = data
		case "displayNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameEqualFold = data
		case "displayNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContainsFold = data
		case "parentOrganizationID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationID = data
		case "parentOrganizationIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDNEQ = data
		case "parentOrganizationIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDIn = data
		case "parentOrganizationIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDNotIn = data
		case "parentOrganizationIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDGT = data
		case "parentOrganizationIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDGTE = data
		case "parentOrganizationIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDLT = data
		case "parentOrganizationIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDLTE = data
		case "parentOrganizationIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDContains"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDContains = data
		case "parentOrganizationIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDHasPrefix"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDHasPrefix = data
		case "parentOrganizationIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDHasSuffix"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDHasSuffix = data
		case "parentOrganizationIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDIsNil = data
		case "parentOrganizationIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDNotNil = data
		case "parentOrganizationIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDEqualFold = data
		case "parentOrganizationIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentOrganizationIDContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentOrganizationIDContainsFold = data
		case "personalOrg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalOrg"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersonalOrg = data
		case "personalOrgNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalOrgNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersonalOrgNEQ = data
		case "hasParent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParent"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasParent = data
		case "hasParentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasParentWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasParentWith = data
		case "hasChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildren"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasChildren = data
		case "hasChildrenWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasChildrenWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasChildrenWith = data
		case "hasUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsers = data
		case "hasUsersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsersWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsersWith = data
		case "hasGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGroups"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGroups = data
		case "hasGroupsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGroupsWith"))
			data, err := ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGroupsWith = data
		case "hasIntegrations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIntegrations"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIntegrations = data
		case "hasIntegrationsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIntegrationsWith"))
			data, err := ec.unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIntegrationsWith = data
		case "hasSetting":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSetting"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSetting = data
		case "hasSettingWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSettingWith"))
			data, err := ec.unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSettingWith = data
		case "hasEntitlements":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEntitlements"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEntitlements = data
		case "hasEntitlementsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEntitlementsWith"))
			data, err := ec.unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEntitlementsWith = data
		case "hasOauthprovider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOauthprovider"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOauthprovider = data
		case "hasOauthproviderWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOauthproviderWith"))
			data, err := ec.unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOauthproviderWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPersonalAccessTokenWhereInput(ctx context.Context, obj interface{}) (generated.PersonalAccessTokenWhereInput, error) {
	var it generated.PersonalAccessTokenWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "expiresAt", "expiresAtNEQ", "expiresAtIn", "expiresAtNotIn", "expiresAtGT", "expiresAtGTE", "expiresAtLT", "expiresAtLTE", "lastUsedAt", "lastUsedAtNEQ", "lastUsedAtIn", "lastUsedAtNotIn", "lastUsedAtGT", "lastUsedAtGTE", "lastUsedAtLT", "lastUsedAtLTE", "lastUsedAtIsNil", "lastUsedAtNotNil", "hasOwner", "hasOwnerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "expiresAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNEQ = data
		case "expiresAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtIn = data
		case "expiresAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNotIn = data
		case "expiresAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtGT = data
		case "expiresAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtGTE = data
		case "expiresAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtLT = data
		case "expiresAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtLTE = data
		case "lastUsedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAt = data
		case "lastUsedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtNEQ = data
		case "lastUsedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtIn = data
		case "lastUsedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtNotIn = data
		case "lastUsedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtGT = data
		case "lastUsedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtGTE = data
		case "lastUsedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtLT = data
		case "lastUsedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtLTE = data
		case "lastUsedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtIsNil = data
		case "lastUsedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAtNotNil = data
		case "hasOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwner = data
		case "hasOwnerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwnerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSessionWhereInput(ctx context.Context, obj interface{}) (generated.SessionWhereInput, error) {
	var it generated.SessionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "sessionToken", "sessionTokenNEQ", "sessionTokenIn", "sessionTokenNotIn", "sessionTokenGT", "sessionTokenGTE", "sessionTokenLT", "sessionTokenLTE", "sessionTokenContains", "sessionTokenHasPrefix", "sessionTokenHasSuffix", "sessionTokenEqualFold", "sessionTokenContainsFold", "issuedAt", "issuedAtNEQ", "issuedAtIn", "issuedAtNotIn", "issuedAtGT", "issuedAtGTE", "issuedAtLT", "issuedAtLTE", "expiresAt", "expiresAtNEQ", "expiresAtIn", "expiresAtNotIn", "expiresAtGT", "expiresAtGTE", "expiresAtLT", "expiresAtLTE", "organizationID", "organizationIDNEQ", "organizationIDIn", "organizationIDNotIn", "organizationIDGT", "organizationIDGTE", "organizationIDLT", "organizationIDLTE", "organizationIDContains", "organizationIDHasPrefix", "organizationIDHasSuffix", "organizationIDEqualFold", "organizationIDContainsFold", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "userIDGT", "userIDGTE", "userIDLT", "userIDLTE", "userIDContains", "userIDHasPrefix", "userIDHasSuffix", "userIDEqualFold", "userIDContainsFold", "hasOwner", "hasOwnerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "sessionToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionToken"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionToken = data
		case "sessionTokenNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenNEQ = data
		case "sessionTokenIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenIn = data
		case "sessionTokenNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenNotIn = data
		case "sessionTokenGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenGT = data
		case "sessionTokenGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenGTE = data
		case "sessionTokenLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenLT = data
		case "sessionTokenLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenLTE = data
		case "sessionTokenContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenContains = data
		case "sessionTokenHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenHasPrefix = data
		case "sessionTokenHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenHasSuffix = data
		case "sessionTokenEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenEqualFold = data
		case "sessionTokenContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionTokenContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SessionTokenContainsFold = data
		case "issuedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAt = data
		case "issuedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtNEQ = data
		case "issuedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtIn = data
		case "issuedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtNotIn = data
		case "issuedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtGT = data
		case "issuedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtGTE = data
		case "issuedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtLT = data
		case "issuedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAtLTE = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "expiresAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNEQ = data
		case "expiresAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtIn = data
		case "expiresAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtNotIn = data
		case "expiresAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtGT = data
		case "expiresAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtGTE = data
		case "expiresAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtLT = data
		case "expiresAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAtLTE = data
		case "organizationID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationID = data
		case "organizationIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDNEQ = data
		case "organizationIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDIn = data
		case "organizationIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDNotIn = data
		case "organizationIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDGT = data
		case "organizationIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDGTE = data
		case "organizationIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDLT = data
		case "organizationIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDLTE = data
		case "organizationIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDContains = data
		case "organizationIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDHasPrefix = data
		case "organizationIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDHasSuffix = data
		case "organizationIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDEqualFold = data
		case "organizationIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationIDContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationIDContainsFold = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "userIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGT = data
		case "userIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGTE = data
		case "userIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLT = data
		case "userIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLTE = data
		case "userIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContains"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContains = data
		case "userIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasPrefix"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasPrefix = data
		case "userIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasSuffix"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasSuffix = data
		case "userIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDEqualFold = data
		case "userIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContainsFold = data
		case "hasOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwner = data
		case "hasOwnerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOwnerWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOwnerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEntitlementInput(ctx context.Context, obj interface{}) (generated.UpdateEntitlementInput, error) {
	var it generated.UpdateEntitlementInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "tier", "externalCustomerID", "clearExternalCustomerID", "externalSubscriptionID", "clearExternalSubscriptionID", "expires", "expiresAt", "clearExpiresAt", "cancelled", "ownerID", "clearOwner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		case "externalCustomerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalCustomerID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalCustomerID = data
		case "clearExternalCustomerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearExternalCustomerID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearExternalCustomerID = data
		case "externalSubscriptionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalSubscriptionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalSubscriptionID = data
		case "clearExternalSubscriptionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearExternalSubscriptionID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearExternalSubscriptionID = data
		case "expires":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expires"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expires = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "clearExpiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearExpiresAt"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearExpiresAt = data
		case "cancelled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancelled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cancelled = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		case "clearOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearOwner = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGroupInput(ctx context.Context, obj interface{}) (generated.UpdateGroupInput, error) {
	var it generated.UpdateGroupInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "name", "description", "clearDescription", "gravatarLogoURL", "clearGravatarLogoURL", "logoURL", "clearLogoURL", "displayName", "settingID", "addUserIDs", "removeUserIDs", "clearUsers", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "clearDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDescription"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDescription = data
		case "gravatarLogoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gravatarLogoURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GravatarLogoURL = data
		case "clearGravatarLogoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearGravatarLogoURL"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearGravatarLogoURL = data
		case "logoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogoURL = data
		case "clearLogoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLogoURL"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearLogoURL = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "settingID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settingID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettingID = data
		case "addUserIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addUserIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddUserIDs = data
		case "removeUserIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeUserIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveUserIDs = data
		case "clearUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUsers = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateGroupSettingInput(ctx context.Context, obj interface{}) (generated.UpdateGroupSettingInput, error) {
	var it generated.UpdateGroupSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "visibility", "joinPolicy", "tags", "appendTags", "syncToSlack", "syncToGithub", "groupID", "clearGroup"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "visibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("visibility"))
			data, err := ec.unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Visibility = data
		case "joinPolicy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("joinPolicy"))
			data, err := ec.unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, v)
			if err != nil {
				return it, err
			}
			it.JoinPolicy = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "appendTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendTags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendTags = data
		case "syncToSlack":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToSlack"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToSlack = data
		case "syncToGithub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncToGithub"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SyncToGithub = data
		case "groupID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupID = data
		case "clearGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearGroup"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearGroup = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateIntegrationInput(ctx context.Context, obj interface{}) (generated.UpdateIntegrationInput, error) {
	var it generated.UpdateIntegrationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "name", "description", "clearDescription", "kind", "clearKind", "ownerID", "clearOwner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "clearDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDescription"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDescription = data
		case "kind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kind"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Kind = data
		case "clearKind":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearKind"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearKind = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		case "clearOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearOwner = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateOauthProviderInput(ctx context.Context, obj interface{}) (generated.UpdateOauthProviderInput, error) {
	var it generated.UpdateOauthProviderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "name", "clientID", "clientSecret", "redirectURL", "scopes", "authURL", "tokenURL", "authStyle", "infoURL", "ownerID", "clearOwner"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "clientID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientSecret = data
		case "redirectURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedirectURL = data
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "authURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthURL = data
		case "tokenURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenURL = data
		case "authStyle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authStyle"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UpdateOauthProviderInput().AuthStyle(ctx, &it, data); err != nil {
				return it, err
			}
		case "infoURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("infoURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InfoURL = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		case "clearOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOwner"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearOwner = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateOhAuthTooTokenInput(ctx context.Context, obj interface{}) (generated.UpdateOhAuthTooTokenInput, error) {
	var it generated.UpdateOhAuthTooTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientID", "scopes", "appendScopes", "clearScopes", "nonce", "claimsUserID", "claimsUsername", "claimsEmail", "claimsEmailVerified", "claimsGroups", "appendClaimsGroups", "clearClaimsGroups", "claimsPreferredUsername", "connectorID", "connectorData", "appendConnectorData", "clearConnectorData", "lastUsed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientID = data
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "appendScopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendScopes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendScopes = data
		case "clearScopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearScopes"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearScopes = data
		case "nonce":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		case "claimsUserID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUserID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUserID = data
		case "claimsUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsUsername = data
		case "claimsEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmail"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmail = data
		case "claimsEmailVerified":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsEmailVerified"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsEmailVerified = data
		case "claimsGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsGroups"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsGroups = data
		case "appendClaimsGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendClaimsGroups"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendClaimsGroups = data
		case "clearClaimsGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearClaimsGroups"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearClaimsGroups = data
		case "claimsPreferredUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimsPreferredUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimsPreferredUsername = data
		case "connectorID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorID = data
		case "connectorData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorData"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectorData = data
		case "appendConnectorData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendConnectorData"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendConnectorData = data
		case "clearConnectorData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearConnectorData"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearConnectorData = data
		case "lastUsed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsed"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateOrganizationInput(ctx context.Context, obj interface{}) (generated.UpdateOrganizationInput, error) {
	var it generated.UpdateOrganizationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "name", "displayName", "description", "clearDescription", "addUserIDs", "removeUserIDs", "clearUsers", "addGroupIDs", "removeGroupIDs", "clearGroups", "addIntegrationIDs", "removeIntegrationIDs", "clearIntegrations", "settingID", "clearSetting", "addEntitlementIDs", "removeEntitlementIDs", "clearEntitlements", "addOauthproviderIDs", "removeOauthproviderIDs", "clearOauthprovider"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "clearDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDescription"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDescription = data
		case "addUserIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addUserIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddUserIDs = data
		case "removeUserIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeUserIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveUserIDs = data
		case "clearUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUsers = data
		case "addGroupIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addGroupIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddGroupIDs = data
		case "removeGroupIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeGroupIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveGroupIDs = data
		case "clearGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearGroups"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearGroups = data
		case "addIntegrationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addIntegrationIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddIntegrationIDs = data
		case "removeIntegrationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeIntegrationIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveIntegrationIDs = data
		case "clearIntegrations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearIntegrations"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearIntegrations = data
		case "settingID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settingID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettingID = data
		case "clearSetting":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSetting"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSetting = data
		case "addEntitlementIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addEntitlementIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddEntitlementIDs = data
		case "removeEntitlementIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeEntitlementIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveEntitlementIDs = data
		case "clearEntitlements":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearEntitlements"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearEntitlements = data
		case "addOauthproviderIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOauthproviderIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddOauthproviderIDs = data
		case "removeOauthproviderIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeOauthproviderIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveOauthproviderIDs = data
		case "clearOauthprovider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOauthprovider"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearOauthprovider = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateOrganizationSettingInput(ctx context.Context, obj interface{}) (generated.UpdateOrganizationSettingInput, error) {
	var it generated.UpdateOrganizationSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "domains", "appendDomains", "clearDomains", "ssoCert", "clearSSOCert", "ssoEntrypoint", "clearSSOEntrypoint", "ssoIssuer", "clearSSOIssuer", "billingContact", "clearBillingContact", "billingEmail", "clearBillingEmail", "billingPhone", "clearBillingPhone", "billingAddress", "clearBillingAddress", "taxIdentifier", "clearTaxIdentifier", "tags", "appendTags", "clearTags", "organizationID", "clearOrganization"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "domains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Domains = data
		case "appendDomains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendDomains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendDomains = data
		case "clearDomains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDomains"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDomains = data
		case "ssoCert":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoCert"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOCert = data
		case "clearSSOCert":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSSOCert"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSSOCert = data
		case "ssoEntrypoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoEntrypoint"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOEntrypoint = data
		case "clearSSOEntrypoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSSOEntrypoint"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSSOEntrypoint = data
		case "ssoIssuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssoIssuer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSOIssuer = data
		case "clearSSOIssuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSSOIssuer"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSSOIssuer = data
		case "billingContact":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingContact"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingContact = data
		case "clearBillingContact":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBillingContact"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBillingContact = data
		case "billingEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingEmail"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingEmail = data
		case "clearBillingEmail":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBillingEmail"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBillingEmail = data
		case "billingPhone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingPhone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingPhone = data
		case "clearBillingPhone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBillingPhone"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBillingPhone = data
		case "billingAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("billingAddress"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BillingAddress = data
		case "clearBillingAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBillingAddress"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBillingAddress = data
		case "taxIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taxIdentifier"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaxIdentifier = data
		case "clearTaxIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearTaxIdentifier"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearTaxIdentifier = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "appendTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendTags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendTags = data
		case "clearTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearTags"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearTags = data
		case "organizationID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationID = data
		case "clearOrganization":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOrganization"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearOrganization = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePersonalAccessTokenInput(ctx context.Context, obj interface{}) (generated.UpdatePersonalAccessTokenInput, error) {
	var it generated.UpdatePersonalAccessTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "name", "abilities", "appendAbilities", "clearAbilities", "expiresAt", "description", "clearDescription", "lastUsedAt", "clearLastUsedAt", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		case "appendAbilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendAbilities"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendAbilities = data
		case "clearAbilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAbilities"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearAbilities = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "clearDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDescription"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDescription = data
		case "lastUsedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastUsedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastUsedAt = data
		case "clearLastUsedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLastUsedAt"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearLastUsedAt = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSessionInput(ctx context.Context, obj interface{}) (generated.UpdateSessionInput, error) {
	var it generated.UpdateSessionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "issuedAt", "expiresAt", "organizationID", "ownerID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "issuedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssuedAt = data
		case "expiresAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiresAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpiresAt = data
		case "organizationID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organizationID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrganizationID = data
		case "ownerID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownerID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (generated.UpdateUserInput, error) {
	var it generated.UpdateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "email", "firstName", "lastName", "displayName", "avatarRemoteURL", "clearAvatarRemoteURL", "avatarLocalFile", "clearAvatarLocalFile", "avatarUpdatedAt", "clearAvatarUpdatedAt", "lastSeen", "clearLastSeen", "password", "clearPassword", "sub", "clearSub", "oauth", "addOrganizationIDs", "removeOrganizationIDs", "clearOrganizations", "addSessionIDs", "removeSessionIDs", "clearSessions", "addGroupIDs", "removeGroupIDs", "clearGroups", "addPersonalAccessTokenIDs", "removePersonalAccessTokenIDs", "clearPersonalAccessTokens", "settingID", "addEmailVerificationTokenIDs", "removeEmailVerificationTokenIDs", "clearEmailVerificationTokens", "addResetTokenIDs", "removeResetTokenIDs", "clearResetTokens"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "firstName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstName = data
		case "lastName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastName = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "avatarRemoteURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURL = data
		case "clearAvatarRemoteURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAvatarRemoteURL"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearAvatarRemoteURL = data
		case "avatarLocalFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFile"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFile = data
		case "clearAvatarLocalFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAvatarLocalFile"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearAvatarLocalFile = data
		case "avatarUpdatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAt = data
		case "clearAvatarUpdatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAvatarUpdatedAt"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearAvatarUpdatedAt = data
		case "lastSeen":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeen"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeen = data
		case "clearLastSeen":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLastSeen"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearLastSeen = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "clearPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPassword"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearPassword = data
		case "sub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sub"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sub = data
		case "clearSub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSub"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSub = data
		case "oauth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth = data
		case "addOrganizationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addOrganizationIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddOrganizationIDs = data
		case "removeOrganizationIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeOrganizationIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveOrganizationIDs = data
		case "clearOrganizations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearOrganizations"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearOrganizations = data
		case "addSessionIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addSessionIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddSessionIDs = data
		case "removeSessionIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeSessionIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveSessionIDs = data
		case "clearSessions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSessions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSessions = data
		case "addGroupIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addGroupIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddGroupIDs = data
		case "removeGroupIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeGroupIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveGroupIDs = data
		case "clearGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearGroups"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearGroups = data
		case "addPersonalAccessTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPersonalAccessTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddPersonalAccessTokenIDs = data
		case "removePersonalAccessTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removePersonalAccessTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemovePersonalAccessTokenIDs = data
		case "clearPersonalAccessTokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPersonalAccessTokens"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearPersonalAccessTokens = data
		case "settingID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settingID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SettingID = data
		case "addEmailVerificationTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addEmailVerificationTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddEmailVerificationTokenIDs = data
		case "removeEmailVerificationTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeEmailVerificationTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveEmailVerificationTokenIDs = data
		case "clearEmailVerificationTokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearEmailVerificationTokens"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearEmailVerificationTokens = data
		case "addResetTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addResetTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddResetTokenIDs = data
		case "removeResetTokenIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeResetTokenIDs"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveResetTokenIDs = data
		case "clearResetTokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearResetTokens"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearResetTokens = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserSettingInput(ctx context.Context, obj interface{}) (generated.UpdateUserSettingInput, error) {
	var it generated.UpdateUserSettingInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"updatedAt", "updatedBy", "clearUpdatedBy", "locked", "silencedAt", "clearSilencedAt", "suspendedAt", "clearSuspendedAt", "recoveryCode", "clearRecoveryCode", "status", "role", "permissions", "appendPermissions", "emailConfirmed", "tags", "appendTags", "userID", "clearUser"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "clearUpdatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUpdatedBy"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUpdatedBy = data
		case "locked":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locked"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locked = data
		case "silencedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAt = data
		case "clearSilencedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSilencedAt"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSilencedAt = data
		case "suspendedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAt = data
		case "clearSuspendedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSuspendedAt"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSuspendedAt = data
		case "recoveryCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recoveryCode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RecoveryCode = data
		case "clearRecoveryCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearRecoveryCode"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearRecoveryCode = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "permissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Permissions = data
		case "appendPermissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendPermissions"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendPermissions = data
		case "emailConfirmed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailConfirmed"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailConfirmed = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "appendTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appendTags"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppendTags = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "clearUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearUser = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj interface{}) (generated.UserOrder, error) {
	var it generated.UserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserOrderField2githubcomdatumforgedatuminternalentgeneratedUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSettingWhereInput(ctx context.Context, obj interface{}) (generated.UserSettingWhereInput, error) {
	var it generated.UserSettingWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "locked", "lockedNEQ", "silencedAt", "silencedAtNEQ", "silencedAtIn", "silencedAtNotIn", "silencedAtGT", "silencedAtGTE", "silencedAtLT", "silencedAtLTE", "silencedAtIsNil", "silencedAtNotNil", "suspendedAt", "suspendedAtNEQ", "suspendedAtIn", "suspendedAtNotIn", "suspendedAtGT", "suspendedAtGTE", "suspendedAtLT", "suspendedAtLTE", "suspendedAtIsNil", "suspendedAtNotNil", "status", "statusNEQ", "statusIn", "statusNotIn", "role", "roleNEQ", "roleIn", "roleNotIn", "emailConfirmed", "emailConfirmedNEQ", "hasUser", "hasUserWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "locked":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locked"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locked = data
		case "lockedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockedNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockedNEQ = data
		case "silencedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAt = data
		case "silencedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtNEQ = data
		case "silencedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtIn = data
		case "silencedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtNotIn = data
		case "silencedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtGT = data
		case "silencedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtGTE = data
		case "silencedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtLT = data
		case "silencedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtLTE = data
		case "silencedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtIsNil = data
		case "silencedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("silencedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SilencedAtNotNil = data
		case "suspendedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAt = data
		case "suspendedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtNEQ = data
		case "suspendedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtIn = data
		case "suspendedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtNotIn = data
		case "suspendedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtGT = data
		case "suspendedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtGTE = data
		case "suspendedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtLT = data
		case "suspendedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtLTE = data
		case "suspendedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtIsNil = data
		case "suspendedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suspendedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuspendedAtNotNil = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "statusNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNEQ"))
			data, err := ec.unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusNEQ = data
		case "statusIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusIn"))
			data, err := ec.unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusIn = data
		case "statusNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNotIn"))
			data, err := ec.unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusNotIn = data
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "roleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNEQ"))
			data, err := ec.unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleNEQ = data
		case "roleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleIn"))
			data, err := ec.unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleIn = data
		case "roleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleNotIn"))
			data, err := ec.unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoleNotIn = data
		case "emailConfirmed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailConfirmed"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailConfirmed = data
		case "emailConfirmedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailConfirmedNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailConfirmedNEQ = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (generated.UserWhereInput, error) {
	var it generated.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE", "createdBy", "createdByNEQ", "createdByIn", "createdByNotIn", "createdByGT", "createdByGTE", "createdByLT", "createdByLTE", "createdByContains", "createdByHasPrefix", "createdByHasSuffix", "createdByIsNil", "createdByNotNil", "createdByEqualFold", "createdByContainsFold", "updatedBy", "updatedByNEQ", "updatedByIn", "updatedByNotIn", "updatedByGT", "updatedByGTE", "updatedByLT", "updatedByLTE", "updatedByContains", "updatedByHasPrefix", "updatedByHasSuffix", "updatedByIsNil", "updatedByNotNil", "updatedByEqualFold", "updatedByContainsFold", "deletedAt", "deletedAtNEQ", "deletedAtIn", "deletedAtNotIn", "deletedAtGT", "deletedAtGTE", "deletedAtLT", "deletedAtLTE", "deletedAtIsNil", "deletedAtNotNil", "deletedBy", "deletedByNEQ", "deletedByIn", "deletedByNotIn", "deletedByGT", "deletedByGTE", "deletedByLT", "deletedByLTE", "deletedByContains", "deletedByHasPrefix", "deletedByHasSuffix", "deletedByIsNil", "deletedByNotNil", "deletedByEqualFold", "deletedByContainsFold", "email", "emailNEQ", "emailIn", "emailNotIn", "emailGT", "emailGTE", "emailLT", "emailLTE", "emailContains", "emailHasPrefix", "emailHasSuffix", "emailEqualFold", "emailContainsFold", "firstName", "firstNameNEQ", "firstNameIn", "firstNameNotIn", "firstNameGT", "firstNameGTE", "firstNameLT", "firstNameLTE", "firstNameContains", "firstNameHasPrefix", "firstNameHasSuffix", "firstNameEqualFold", "firstNameContainsFold", "lastName", "lastNameNEQ", "lastNameIn", "lastNameNotIn", "lastNameGT", "lastNameGTE", "lastNameLT", "lastNameLTE", "lastNameContains", "lastNameHasPrefix", "lastNameHasSuffix", "lastNameEqualFold", "lastNameContainsFold", "displayName", "displayNameNEQ", "displayNameIn", "displayNameNotIn", "displayNameGT", "displayNameGTE", "displayNameLT", "displayNameLTE", "displayNameContains", "displayNameHasPrefix", "displayNameHasSuffix", "displayNameEqualFold", "displayNameContainsFold", "avatarRemoteURL", "avatarRemoteURLNEQ", "avatarRemoteURLIn", "avatarRemoteURLNotIn", "avatarRemoteURLGT", "avatarRemoteURLGTE", "avatarRemoteURLLT", "avatarRemoteURLLTE", "avatarRemoteURLContains", "avatarRemoteURLHasPrefix", "avatarRemoteURLHasSuffix", "avatarRemoteURLIsNil", "avatarRemoteURLNotNil", "avatarRemoteURLEqualFold", "avatarRemoteURLContainsFold", "avatarLocalFile", "avatarLocalFileNEQ", "avatarLocalFileIn", "avatarLocalFileNotIn", "avatarLocalFileGT", "avatarLocalFileGTE", "avatarLocalFileLT", "avatarLocalFileLTE", "avatarLocalFileContains", "avatarLocalFileHasPrefix", "avatarLocalFileHasSuffix", "avatarLocalFileIsNil", "avatarLocalFileNotNil", "avatarLocalFileEqualFold", "avatarLocalFileContainsFold", "avatarUpdatedAt", "avatarUpdatedAtNEQ", "avatarUpdatedAtIn", "avatarUpdatedAtNotIn", "avatarUpdatedAtGT", "avatarUpdatedAtGTE", "avatarUpdatedAtLT", "avatarUpdatedAtLTE", "avatarUpdatedAtIsNil", "avatarUpdatedAtNotNil", "lastSeen", "lastSeenNEQ", "lastSeenIn", "lastSeenNotIn", "lastSeenGT", "lastSeenGTE", "lastSeenLT", "lastSeenLTE", "lastSeenIsNil", "lastSeenNotNil", "password", "passwordNEQ", "passwordIn", "passwordNotIn", "passwordGT", "passwordGTE", "passwordLT", "passwordLTE", "passwordContains", "passwordHasPrefix", "passwordHasSuffix", "passwordIsNil", "passwordNotNil", "passwordEqualFold", "passwordContainsFold", "sub", "subNEQ", "subIn", "subNotIn", "subGT", "subGTE", "subLT", "subLTE", "subContains", "subHasPrefix", "subHasSuffix", "subIsNil", "subNotNil", "subEqualFold", "subContainsFold", "oauth", "oauthNEQ", "hasOrganizations", "hasOrganizationsWith", "hasSessions", "hasSessionsWith", "hasGroups", "hasGroupsWith", "hasPersonalAccessTokens", "hasPersonalAccessTokensWith", "hasSetting", "hasSettingWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		case "createdBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBy = data
		case "createdByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNEQ = data
		case "createdByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIn = data
		case "createdByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotIn = data
		case "createdByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGT = data
		case "createdByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByGTE = data
		case "createdByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLT = data
		case "createdByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByLTE = data
		case "createdByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContains = data
		case "createdByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasPrefix = data
		case "createdByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByHasSuffix = data
		case "createdByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByIsNil = data
		case "createdByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByNotNil = data
		case "createdByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByEqualFold = data
		case "createdByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedByContainsFold = data
		case "updatedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedBy = data
		case "updatedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNEQ = data
		case "updatedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIn = data
		case "updatedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotIn = data
		case "updatedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGT = data
		case "updatedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByGTE = data
		case "updatedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLT = data
		case "updatedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByLTE = data
		case "updatedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContains = data
		case "updatedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasPrefix = data
		case "updatedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByHasSuffix = data
		case "updatedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByIsNil = data
		case "updatedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByNotNil = data
		case "updatedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByEqualFold = data
		case "updatedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedByContainsFold = data
		case "deletedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAt = data
		case "deletedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNEQ = data
		case "deletedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIn = data
		case "deletedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotIn = data
		case "deletedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGT = data
		case "deletedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtGTE = data
		case "deletedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLT = data
		case "deletedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtLTE = data
		case "deletedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtIsNil = data
		case "deletedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedAtNotNil = data
		case "deletedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedBy"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedBy = data
		case "deletedByNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNEQ = data
		case "deletedByIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIn = data
		case "deletedByNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotIn = data
		case "deletedByGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGT = data
		case "deletedByGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByGTE = data
		case "deletedByLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLT = data
		case "deletedByLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByLTE = data
		case "deletedByContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContains = data
		case "deletedByHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasPrefix = data
		case "deletedByHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByHasSuffix = data
		case "deletedByIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByIsNil = data
		case "deletedByNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByNotNil = data
		case "deletedByEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByEqualFold = data
		case "deletedByContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedByContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedByContainsFold = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "emailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNEQ = data
		case "emailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailIn = data
		case "emailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotIn = data
		case "emailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGT = data
		case "emailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGTE = data
		case "emailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLT = data
		case "emailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLTE = data
		case "emailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContains = data
		case "emailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasPrefix = data
		case "emailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasSuffix = data
		case "emailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailEqualFold = data
		case "emailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContainsFold = data
		case "firstName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstName = data
		case "firstNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameNEQ = data
		case "firstNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameIn = data
		case "firstNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameNotIn = data
		case "firstNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameGT = data
		case "firstNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameGTE = data
		case "firstNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameLT = data
		case "firstNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameLTE = data
		case "firstNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameContains = data
		case "firstNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameHasPrefix = data
		case "firstNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameHasSuffix = data
		case "firstNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameEqualFold = data
		case "firstNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FirstNameContainsFold = data
		case "lastName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastName = data
		case "lastNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameNEQ = data
		case "lastNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameIn = data
		case "lastNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameNotIn = data
		case "lastNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameGT = data
		case "lastNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameGTE = data
		case "lastNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameLT = data
		case "lastNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameLTE = data
		case "lastNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameContains = data
		case "lastNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameHasPrefix = data
		case "lastNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameHasSuffix = data
		case "lastNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameEqualFold = data
		case "lastNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastNameContainsFold = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "displayNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNEQ = data
		case "displayNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameIn = data
		case "displayNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameNotIn = data
		case "displayNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGT = data
		case "displayNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameGTE = data
		case "displayNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLT = data
		case "displayNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameLTE = data
		case "displayNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContains = data
		case "displayNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasPrefix = data
		case "displayNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameHasSuffix = data
		case "displayNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameEqualFold = data
		case "displayNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayNameContainsFold = data
		case "avatarRemoteURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURL = data
		case "avatarRemoteURLNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLNEQ = data
		case "avatarRemoteURLIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLIn = data
		case "avatarRemoteURLNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLNotIn = data
		case "avatarRemoteURLGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLGT = data
		case "avatarRemoteURLGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLGTE = data
		case "avatarRemoteURLLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLLT = data
		case "avatarRemoteURLLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLLTE = data
		case "avatarRemoteURLContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLContains = data
		case "avatarRemoteURLHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLHasPrefix = data
		case "avatarRemoteURLHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLHasSuffix = data
		case "avatarRemoteURLIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLIsNil = data
		case "avatarRemoteURLNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLNotNil = data
		case "avatarRemoteURLEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLEqualFold = data
		case "avatarRemoteURLContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarRemoteURLContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarRemoteURLContainsFold = data
		case "avatarLocalFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFile"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFile = data
		case "avatarLocalFileNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileNEQ = data
		case "avatarLocalFileIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileIn = data
		case "avatarLocalFileNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileNotIn = data
		case "avatarLocalFileGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileGT = data
		case "avatarLocalFileGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileGTE = data
		case "avatarLocalFileLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileLT = data
		case "avatarLocalFileLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileLTE = data
		case "avatarLocalFileContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileContains = data
		case "avatarLocalFileHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileHasPrefix = data
		case "avatarLocalFileHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileHasSuffix = data
		case "avatarLocalFileIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileIsNil = data
		case "avatarLocalFileNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileNotNil = data
		case "avatarLocalFileEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileEqualFold = data
		case "avatarLocalFileContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarLocalFileContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarLocalFileContainsFold = data
		case "avatarUpdatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAt"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAt = data
		case "avatarUpdatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtNEQ = data
		case "avatarUpdatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtIn = data
		case "avatarUpdatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtNotIn = data
		case "avatarUpdatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtGT = data
		case "avatarUpdatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtGTE = data
		case "avatarUpdatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtLT = data
		case "avatarUpdatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtLTE = data
		case "avatarUpdatedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtIsNil = data
		case "avatarUpdatedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("avatarUpdatedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvatarUpdatedAtNotNil = data
		case "lastSeen":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeen"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeen = data
		case "lastSeenNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenNEQ = data
		case "lastSeenIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenIn = data
		case "lastSeenNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenNotIn = data
		case "lastSeenGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenGT = data
		case "lastSeenGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenGTE = data
		case "lastSeenLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenLT = data
		case "lastSeenLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenLTE = data
		case "lastSeenIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenIsNil = data
		case "lastSeenNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSeenNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSeenNotNil = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "passwordNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordNEQ = data
		case "passwordIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordIn = data
		case "passwordNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordNotIn = data
		case "passwordGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordGT = data
		case "passwordGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordGTE = data
		case "passwordLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordLT = data
		case "passwordLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordLTE = data
		case "passwordContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordContains = data
		case "passwordHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordHasPrefix = data
		case "passwordHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordHasSuffix = data
		case "passwordIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordIsNil = data
		case "passwordNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordNotNil = data
		case "passwordEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordEqualFold = data
		case "passwordContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordContainsFold = data
		case "sub":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sub"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sub = data
		case "subNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubNEQ = data
		case "subIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubIn = data
		case "subNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubNotIn = data
		case "subGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubGT = data
		case "subGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubGTE = data
		case "subLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubLT = data
		case "subLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubLTE = data
		case "subContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubContains = data
		case "subHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubHasPrefix = data
		case "subHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubHasSuffix = data
		case "subIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubIsNil = data
		case "subNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubNotNil = data
		case "subEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubEqualFold = data
		case "subContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubContainsFold = data
		case "oauth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Oauth = data
		case "oauthNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauthNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OauthNEQ = data
		case "hasOrganizations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganizations"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOrganizations = data
		case "hasOrganizationsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOrganizationsWith"))
			data, err := ec.unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOrganizationsWith = data
		case "hasSessions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSessions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSessions = data
		case "hasSessionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSessionsWith"))
			data, err := ec.unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSessionsWith = data
		case "hasGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGroups"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGroups = data
		case "hasGroupsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGroupsWith"))
			data, err := ec.unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGroupsWith = data
		case "hasPersonalAccessTokens":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPersonalAccessTokens"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPersonalAccessTokens = data
		case "hasPersonalAccessTokensWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPersonalAccessTokensWith"))
			data, err := ec.unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPersonalAccessTokensWith = data
		case "hasSetting":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSetting"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSetting = data
		case "hasSettingWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSettingWith"))
			data, err := ec.unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSettingWith = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj generated.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *generated.Entitlement:
		if obj == nil {
			return graphql.Null
		}
		return ec._Entitlement(ctx, sel, obj)
	case *generated.Group:
		if obj == nil {
			return graphql.Null
		}
		return ec._Group(ctx, sel, obj)
	case *generated.GroupSetting:
		if obj == nil {
			return graphql.Null
		}
		return ec._GroupSetting(ctx, sel, obj)
	case *generated.Integration:
		if obj == nil {
			return graphql.Null
		}
		return ec._Integration(ctx, sel, obj)
	case *generated.OauthProvider:
		if obj == nil {
			return graphql.Null
		}
		return ec._OauthProvider(ctx, sel, obj)
	case *generated.OhAuthTooToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._OhAuthTooToken(ctx, sel, obj)
	case *generated.Organization:
		if obj == nil {
			return graphql.Null
		}
		return ec._Organization(ctx, sel, obj)
	case *generated.OrganizationSetting:
		if obj == nil {
			return graphql.Null
		}
		return ec._OrganizationSetting(ctx, sel, obj)
	case *generated.PersonalAccessToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._PersonalAccessToken(ctx, sel, obj)
	case *generated.Session:
		if obj == nil {
			return graphql.Null
		}
		return ec._Session(ctx, sel, obj)
	case *generated.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *generated.UserSetting:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserSetting(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var entitlementImplementors = []string{"Entitlement", "Node"}

func (ec *executionContext) _Entitlement(ctx context.Context, sel ast.SelectionSet, obj *generated.Entitlement) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entitlementImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Entitlement")
		case "id":
			out.Values[i] = ec._Entitlement_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Entitlement_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Entitlement_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Entitlement_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Entitlement_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Entitlement_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._Entitlement_deletedBy(ctx, field, obj)
		case "tier":
			out.Values[i] = ec._Entitlement_tier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalCustomerID":
			out.Values[i] = ec._Entitlement_externalCustomerID(ctx, field, obj)
		case "externalSubscriptionID":
			out.Values[i] = ec._Entitlement_externalSubscriptionID(ctx, field, obj)
		case "expires":
			out.Values[i] = ec._Entitlement_expires(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiresAt":
			out.Values[i] = ec._Entitlement_expiresAt(ctx, field, obj)
		case "cancelled":
			out.Values[i] = ec._Entitlement_cancelled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Entitlement_owner(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entitlementConnectionImplementors = []string{"EntitlementConnection"}

func (ec *executionContext) _EntitlementConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.EntitlementConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entitlementConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntitlementConnection")
		case "edges":
			out.Values[i] = ec._EntitlementConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._EntitlementConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._EntitlementConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entitlementCreatePayloadImplementors = []string{"EntitlementCreatePayload"}

func (ec *executionContext) _EntitlementCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *EntitlementCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entitlementCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntitlementCreatePayload")
		case "entitlement":
			out.Values[i] = ec._EntitlementCreatePayload_entitlement(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entitlementDeletePayloadImplementors = []string{"EntitlementDeletePayload"}

func (ec *executionContext) _EntitlementDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *EntitlementDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entitlementDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntitlementDeletePayload")
		case "deletedID":
			out.Values[i] = ec._EntitlementDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entitlementEdgeImplementors = []string{"EntitlementEdge"}

func (ec *executionContext) _EntitlementEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.EntitlementEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entitlementEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntitlementEdge")
		case "node":
			out.Values[i] = ec._EntitlementEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._EntitlementEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entitlementUpdatePayloadImplementors = []string{"EntitlementUpdatePayload"}

func (ec *executionContext) _EntitlementUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *EntitlementUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entitlementUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntitlementUpdatePayload")
		case "entitlement":
			out.Values[i] = ec._EntitlementUpdatePayload_entitlement(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupImplementors = []string{"Group", "Node"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *generated.Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "id":
			out.Values[i] = ec._Group_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Group_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Group_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Group_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Group_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Group_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._Group_deletedBy(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Group_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Group_description(ctx, field, obj)
		case "gravatarLogoURL":
			out.Values[i] = ec._Group_gravatarLogoURL(ctx, field, obj)
		case "logoURL":
			out.Values[i] = ec._Group_logoURL(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Group_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "setting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Group_setting(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Group_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Group_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupConnectionImplementors = []string{"GroupConnection"}

func (ec *executionContext) _GroupConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.GroupConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupConnection")
		case "edges":
			out.Values[i] = ec._GroupConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._GroupConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._GroupConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupCreatePayloadImplementors = []string{"GroupCreatePayload"}

func (ec *executionContext) _GroupCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *GroupCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupCreatePayload")
		case "group":
			out.Values[i] = ec._GroupCreatePayload_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupDeletePayloadImplementors = []string{"GroupDeletePayload"}

func (ec *executionContext) _GroupDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *GroupDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupDeletePayload")
		case "deletedID":
			out.Values[i] = ec._GroupDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupEdgeImplementors = []string{"GroupEdge"}

func (ec *executionContext) _GroupEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.GroupEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupEdge")
		case "node":
			out.Values[i] = ec._GroupEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._GroupEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupSettingImplementors = []string{"GroupSetting", "Node"}

func (ec *executionContext) _GroupSetting(ctx context.Context, sel ast.SelectionSet, obj *generated.GroupSetting) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupSettingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupSetting")
		case "id":
			out.Values[i] = ec._GroupSetting_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._GroupSetting_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._GroupSetting_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._GroupSetting_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._GroupSetting_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._GroupSetting_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._GroupSetting_deletedBy(ctx, field, obj)
		case "visibility":
			out.Values[i] = ec._GroupSetting_visibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "joinPolicy":
			out.Values[i] = ec._GroupSetting_joinPolicy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._GroupSetting_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "syncToSlack":
			out.Values[i] = ec._GroupSetting_syncToSlack(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "syncToGithub":
			out.Values[i] = ec._GroupSetting_syncToGithub(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "group":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GroupSetting_group(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupSettingConnectionImplementors = []string{"GroupSettingConnection"}

func (ec *executionContext) _GroupSettingConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.GroupSettingConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupSettingConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupSettingConnection")
		case "edges":
			out.Values[i] = ec._GroupSettingConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._GroupSettingConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._GroupSettingConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupSettingCreatePayloadImplementors = []string{"GroupSettingCreatePayload"}

func (ec *executionContext) _GroupSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *GroupSettingCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupSettingCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupSettingCreatePayload")
		case "groupSetting":
			out.Values[i] = ec._GroupSettingCreatePayload_groupSetting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupSettingDeletePayloadImplementors = []string{"GroupSettingDeletePayload"}

func (ec *executionContext) _GroupSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *GroupSettingDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupSettingDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupSettingDeletePayload")
		case "deletedID":
			out.Values[i] = ec._GroupSettingDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupSettingEdgeImplementors = []string{"GroupSettingEdge"}

func (ec *executionContext) _GroupSettingEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.GroupSettingEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupSettingEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupSettingEdge")
		case "node":
			out.Values[i] = ec._GroupSettingEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._GroupSettingEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupSettingUpdatePayloadImplementors = []string{"GroupSettingUpdatePayload"}

func (ec *executionContext) _GroupSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *GroupSettingUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupSettingUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupSettingUpdatePayload")
		case "groupSetting":
			out.Values[i] = ec._GroupSettingUpdatePayload_groupSetting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupUpdatePayloadImplementors = []string{"GroupUpdatePayload"}

func (ec *executionContext) _GroupUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *GroupUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupUpdatePayload")
		case "group":
			out.Values[i] = ec._GroupUpdatePayload_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationImplementors = []string{"Integration", "Node"}

func (ec *executionContext) _Integration(ctx context.Context, sel ast.SelectionSet, obj *generated.Integration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Integration")
		case "id":
			out.Values[i] = ec._Integration_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Integration_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Integration_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Integration_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Integration_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Integration_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._Integration_deletedBy(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Integration_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Integration_description(ctx, field, obj)
		case "kind":
			out.Values[i] = ec._Integration_kind(ctx, field, obj)
		case "secretName":
			out.Values[i] = ec._Integration_secretName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Integration_owner(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationConnectionImplementors = []string{"IntegrationConnection"}

func (ec *executionContext) _IntegrationConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.IntegrationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationConnection")
		case "edges":
			out.Values[i] = ec._IntegrationConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._IntegrationConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._IntegrationConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationCreatePayloadImplementors = []string{"IntegrationCreatePayload"}

func (ec *executionContext) _IntegrationCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *IntegrationCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationCreatePayload")
		case "integration":
			out.Values[i] = ec._IntegrationCreatePayload_integration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationDeletePayloadImplementors = []string{"IntegrationDeletePayload"}

func (ec *executionContext) _IntegrationDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *IntegrationDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationDeletePayload")
		case "deletedID":
			out.Values[i] = ec._IntegrationDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationEdgeImplementors = []string{"IntegrationEdge"}

func (ec *executionContext) _IntegrationEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.IntegrationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationEdge")
		case "node":
			out.Values[i] = ec._IntegrationEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._IntegrationEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var integrationUpdatePayloadImplementors = []string{"IntegrationUpdatePayload"}

func (ec *executionContext) _IntegrationUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *IntegrationUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, integrationUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IntegrationUpdatePayload")
		case "integration":
			out.Values[i] = ec._IntegrationUpdatePayload_integration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createEntitlement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEntitlement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEntitlement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEntitlement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEntitlement":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEntitlement(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createGroup":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGroup(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateGroup":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGroup(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGroup":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGroup(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createGroupSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createGroupSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateGroupSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateGroupSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteGroupSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGroupSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createIntegration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createIntegration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateIntegration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateIntegration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteIntegration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteIntegration(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createOauthProvider":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOauthProvider(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateOauthProvider":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOauthProvider(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteOauthProvider":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOauthProvider(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createOhAuthTooToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOhAuthTooToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateOhAuthTooToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOhAuthTooToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteOhAuthTooToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOhAuthTooToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createOrganization":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOrganization(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateOrganization":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOrganization(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteOrganization":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOrganization(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createOrganizationSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOrganizationSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateOrganizationSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOrganizationSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteOrganizationSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOrganizationSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createPersonalAccessToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPersonalAccessToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatePersonalAccessToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePersonalAccessToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletePersonalAccessToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deletePersonalAccessToken(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSession":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSession(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUserSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUserSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteUserSetting":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUserSetting(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oauthProviderImplementors = []string{"OauthProvider", "Node"}

func (ec *executionContext) _OauthProvider(ctx context.Context, sel ast.SelectionSet, obj *generated.OauthProvider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oauthProviderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OauthProvider")
		case "id":
			out.Values[i] = ec._OauthProvider_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._OauthProvider_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._OauthProvider_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._OauthProvider_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._OauthProvider_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._OauthProvider_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._OauthProvider_deletedBy(ctx, field, obj)
		case "name":
			out.Values[i] = ec._OauthProvider_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "clientID":
			out.Values[i] = ec._OauthProvider_clientID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "clientSecret":
			out.Values[i] = ec._OauthProvider_clientSecret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "redirectURL":
			out.Values[i] = ec._OauthProvider_redirectURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "scopes":
			out.Values[i] = ec._OauthProvider_scopes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authURL":
			out.Values[i] = ec._OauthProvider_authURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tokenURL":
			out.Values[i] = ec._OauthProvider_tokenURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authStyle":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OauthProvider_authStyle(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "infoURL":
			out.Values[i] = ec._OauthProvider_infoURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OauthProvider_owner(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oauthProviderConnectionImplementors = []string{"OauthProviderConnection"}

func (ec *executionContext) _OauthProviderConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.OauthProviderConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oauthProviderConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OauthProviderConnection")
		case "edges":
			out.Values[i] = ec._OauthProviderConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._OauthProviderConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._OauthProviderConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oauthProviderCreatePayloadImplementors = []string{"OauthProviderCreatePayload"}

func (ec *executionContext) _OauthProviderCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *OauthProviderCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oauthProviderCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OauthProviderCreatePayload")
		case "OauthProvider":
			out.Values[i] = ec._OauthProviderCreatePayload_OauthProvider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oauthProviderDeletePayloadImplementors = []string{"OauthProviderDeletePayload"}

func (ec *executionContext) _OauthProviderDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *OauthProviderDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oauthProviderDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OauthProviderDeletePayload")
		case "deletedID":
			out.Values[i] = ec._OauthProviderDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oauthProviderEdgeImplementors = []string{"OauthProviderEdge"}

func (ec *executionContext) _OauthProviderEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.OauthProviderEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oauthProviderEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OauthProviderEdge")
		case "node":
			out.Values[i] = ec._OauthProviderEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._OauthProviderEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oauthProviderUpdatePayloadImplementors = []string{"OauthProviderUpdatePayload"}

func (ec *executionContext) _OauthProviderUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *OauthProviderUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oauthProviderUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OauthProviderUpdatePayload")
		case "OauthProvider":
			out.Values[i] = ec._OauthProviderUpdatePayload_OauthProvider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ohAuthTooTokenImplementors = []string{"OhAuthTooToken", "Node"}

func (ec *executionContext) _OhAuthTooToken(ctx context.Context, sel ast.SelectionSet, obj *generated.OhAuthTooToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ohAuthTooTokenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OhAuthTooToken")
		case "id":
			out.Values[i] = ec._OhAuthTooToken_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientID":
			out.Values[i] = ec._OhAuthTooToken_clientID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scopes":
			out.Values[i] = ec._OhAuthTooToken_scopes(ctx, field, obj)
		case "nonce":
			out.Values[i] = ec._OhAuthTooToken_nonce(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "claimsUserID":
			out.Values[i] = ec._OhAuthTooToken_claimsUserID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "claimsUsername":
			out.Values[i] = ec._OhAuthTooToken_claimsUsername(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "claimsEmail":
			out.Values[i] = ec._OhAuthTooToken_claimsEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "claimsEmailVerified":
			out.Values[i] = ec._OhAuthTooToken_claimsEmailVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "claimsGroups":
			out.Values[i] = ec._OhAuthTooToken_claimsGroups(ctx, field, obj)
		case "claimsPreferredUsername":
			out.Values[i] = ec._OhAuthTooToken_claimsPreferredUsername(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectorID":
			out.Values[i] = ec._OhAuthTooToken_connectorID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectorData":
			out.Values[i] = ec._OhAuthTooToken_connectorData(ctx, field, obj)
		case "lastUsed":
			out.Values[i] = ec._OhAuthTooToken_lastUsed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ohAuthTooTokenConnectionImplementors = []string{"OhAuthTooTokenConnection"}

func (ec *executionContext) _OhAuthTooTokenConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.OhAuthTooTokenConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ohAuthTooTokenConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OhAuthTooTokenConnection")
		case "edges":
			out.Values[i] = ec._OhAuthTooTokenConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._OhAuthTooTokenConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._OhAuthTooTokenConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ohAuthTooTokenCreatePayloadImplementors = []string{"OhAuthTooTokenCreatePayload"}

func (ec *executionContext) _OhAuthTooTokenCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *OhAuthTooTokenCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ohAuthTooTokenCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OhAuthTooTokenCreatePayload")
		case "ohAuthTooToken":
			out.Values[i] = ec._OhAuthTooTokenCreatePayload_ohAuthTooToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ohAuthTooTokenDeletePayloadImplementors = []string{"OhAuthTooTokenDeletePayload"}

func (ec *executionContext) _OhAuthTooTokenDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *OhAuthTooTokenDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ohAuthTooTokenDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OhAuthTooTokenDeletePayload")
		case "deletedID":
			out.Values[i] = ec._OhAuthTooTokenDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ohAuthTooTokenEdgeImplementors = []string{"OhAuthTooTokenEdge"}

func (ec *executionContext) _OhAuthTooTokenEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.OhAuthTooTokenEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ohAuthTooTokenEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OhAuthTooTokenEdge")
		case "node":
			out.Values[i] = ec._OhAuthTooTokenEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._OhAuthTooTokenEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ohAuthTooTokenUpdatePayloadImplementors = []string{"OhAuthTooTokenUpdatePayload"}

func (ec *executionContext) _OhAuthTooTokenUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *OhAuthTooTokenUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ohAuthTooTokenUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OhAuthTooTokenUpdatePayload")
		case "ohAuthTooToken":
			out.Values[i] = ec._OhAuthTooTokenUpdatePayload_ohAuthTooToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationImplementors = []string{"Organization", "Node"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *generated.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Organization_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Organization_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Organization_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Organization_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._Organization_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._Organization_deletedBy(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._Organization_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Organization_description(ctx, field, obj)
		case "personalOrg":
			out.Values[i] = ec._Organization_personalOrg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parent":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_parent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "children":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_children(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_users(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "integrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_integrations(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "setting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_setting(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "entitlements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_entitlements(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "oauthprovider":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_oauthprovider(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationConnectionImplementors = []string{"OrganizationConnection"}

func (ec *executionContext) _OrganizationConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.OrganizationConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationConnection")
		case "edges":
			out.Values[i] = ec._OrganizationConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._OrganizationConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._OrganizationConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationCreatePayloadImplementors = []string{"OrganizationCreatePayload"}

func (ec *executionContext) _OrganizationCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *OrganizationCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationCreatePayload")
		case "organization":
			out.Values[i] = ec._OrganizationCreatePayload_organization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationDeletePayloadImplementors = []string{"OrganizationDeletePayload"}

func (ec *executionContext) _OrganizationDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *OrganizationDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationDeletePayload")
		case "deletedID":
			out.Values[i] = ec._OrganizationDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationEdgeImplementors = []string{"OrganizationEdge"}

func (ec *executionContext) _OrganizationEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.OrganizationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationEdge")
		case "node":
			out.Values[i] = ec._OrganizationEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._OrganizationEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationSettingImplementors = []string{"OrganizationSetting", "Node"}

func (ec *executionContext) _OrganizationSetting(ctx context.Context, sel ast.SelectionSet, obj *generated.OrganizationSetting) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationSettingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationSetting")
		case "id":
			out.Values[i] = ec._OrganizationSetting_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._OrganizationSetting_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._OrganizationSetting_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._OrganizationSetting_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._OrganizationSetting_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._OrganizationSetting_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._OrganizationSetting_deletedBy(ctx, field, obj)
		case "domains":
			out.Values[i] = ec._OrganizationSetting_domains(ctx, field, obj)
		case "ssoCert":
			out.Values[i] = ec._OrganizationSetting_ssoCert(ctx, field, obj)
		case "ssoEntrypoint":
			out.Values[i] = ec._OrganizationSetting_ssoEntrypoint(ctx, field, obj)
		case "ssoIssuer":
			out.Values[i] = ec._OrganizationSetting_ssoIssuer(ctx, field, obj)
		case "billingContact":
			out.Values[i] = ec._OrganizationSetting_billingContact(ctx, field, obj)
		case "billingEmail":
			out.Values[i] = ec._OrganizationSetting_billingEmail(ctx, field, obj)
		case "billingPhone":
			out.Values[i] = ec._OrganizationSetting_billingPhone(ctx, field, obj)
		case "billingAddress":
			out.Values[i] = ec._OrganizationSetting_billingAddress(ctx, field, obj)
		case "taxIdentifier":
			out.Values[i] = ec._OrganizationSetting_taxIdentifier(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._OrganizationSetting_tags(ctx, field, obj)
		case "organization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OrganizationSetting_organization(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationSettingConnectionImplementors = []string{"OrganizationSettingConnection"}

func (ec *executionContext) _OrganizationSettingConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.OrganizationSettingConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationSettingConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationSettingConnection")
		case "edges":
			out.Values[i] = ec._OrganizationSettingConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._OrganizationSettingConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._OrganizationSettingConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationSettingCreatePayloadImplementors = []string{"OrganizationSettingCreatePayload"}

func (ec *executionContext) _OrganizationSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *OrganizationSettingCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationSettingCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationSettingCreatePayload")
		case "organizationSetting":
			out.Values[i] = ec._OrganizationSettingCreatePayload_organizationSetting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationSettingDeletePayloadImplementors = []string{"OrganizationSettingDeletePayload"}

func (ec *executionContext) _OrganizationSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *OrganizationSettingDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationSettingDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationSettingDeletePayload")
		case "deletedID":
			out.Values[i] = ec._OrganizationSettingDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationSettingEdgeImplementors = []string{"OrganizationSettingEdge"}

func (ec *executionContext) _OrganizationSettingEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.OrganizationSettingEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationSettingEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationSettingEdge")
		case "node":
			out.Values[i] = ec._OrganizationSettingEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._OrganizationSettingEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationSettingUpdatePayloadImplementors = []string{"OrganizationSettingUpdatePayload"}

func (ec *executionContext) _OrganizationSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *OrganizationSettingUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationSettingUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationSettingUpdatePayload")
		case "organizationSetting":
			out.Values[i] = ec._OrganizationSettingUpdatePayload_organizationSetting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var organizationUpdatePayloadImplementors = []string{"OrganizationUpdatePayload"}

func (ec *executionContext) _OrganizationUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *OrganizationUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrganizationUpdatePayload")
		case "organization":
			out.Values[i] = ec._OrganizationUpdatePayload_organization(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[string]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var personalAccessTokenImplementors = []string{"PersonalAccessToken", "Node"}

func (ec *executionContext) _PersonalAccessToken(ctx context.Context, sel ast.SelectionSet, obj *generated.PersonalAccessToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, personalAccessTokenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersonalAccessToken")
		case "id":
			out.Values[i] = ec._PersonalAccessToken_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._PersonalAccessToken_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._PersonalAccessToken_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._PersonalAccessToken_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._PersonalAccessToken_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._PersonalAccessToken_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._PersonalAccessToken_deletedBy(ctx, field, obj)
		case "name":
			out.Values[i] = ec._PersonalAccessToken_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "abilities":
			out.Values[i] = ec._PersonalAccessToken_abilities(ctx, field, obj)
		case "expiresAt":
			out.Values[i] = ec._PersonalAccessToken_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._PersonalAccessToken_description(ctx, field, obj)
		case "lastUsedAt":
			out.Values[i] = ec._PersonalAccessToken_lastUsedAt(ctx, field, obj)
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PersonalAccessToken_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var personalAccessTokenConnectionImplementors = []string{"PersonalAccessTokenConnection"}

func (ec *executionContext) _PersonalAccessTokenConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.PersonalAccessTokenConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, personalAccessTokenConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersonalAccessTokenConnection")
		case "edges":
			out.Values[i] = ec._PersonalAccessTokenConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._PersonalAccessTokenConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._PersonalAccessTokenConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var personalAccessTokenCreatePayloadImplementors = []string{"PersonalAccessTokenCreatePayload"}

func (ec *executionContext) _PersonalAccessTokenCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *PersonalAccessTokenCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, personalAccessTokenCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersonalAccessTokenCreatePayload")
		case "PersonalAccessToken":
			out.Values[i] = ec._PersonalAccessTokenCreatePayload_PersonalAccessToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var personalAccessTokenDeletePayloadImplementors = []string{"PersonalAccessTokenDeletePayload"}

func (ec *executionContext) _PersonalAccessTokenDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *PersonalAccessTokenDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, personalAccessTokenDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersonalAccessTokenDeletePayload")
		case "deletedID":
			out.Values[i] = ec._PersonalAccessTokenDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var personalAccessTokenEdgeImplementors = []string{"PersonalAccessTokenEdge"}

func (ec *executionContext) _PersonalAccessTokenEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.PersonalAccessTokenEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, personalAccessTokenEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersonalAccessTokenEdge")
		case "node":
			out.Values[i] = ec._PersonalAccessTokenEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._PersonalAccessTokenEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var personalAccessTokenUpdatePayloadImplementors = []string{"PersonalAccessTokenUpdatePayload"}

func (ec *executionContext) _PersonalAccessTokenUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *PersonalAccessTokenUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, personalAccessTokenUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersonalAccessTokenUpdatePayload")
		case "PersonalAccessToken":
			out.Values[i] = ec._PersonalAccessTokenUpdatePayload_PersonalAccessToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "entitlements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_entitlements(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_groups(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "groupSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_groupSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "integrations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_integrations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oauthProviders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauthProviders(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ohAuthTooTokens":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ohAuthTooTokens(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizationSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizationSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "personalAccessTokens":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_personalAccessTokens(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "sessions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_sessions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "entitlement":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_entitlement(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "group":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_group(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "groupSetting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_groupSetting(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "integration":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_integration(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "oauthProvider":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauthProvider(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ohAuthTooToken":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ohAuthTooToken(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organization":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organization(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "organizationSetting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizationSetting(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "personalAccessToken":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_personalAccessToken(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "session":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_session(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userSetting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userSetting(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionImplementors = []string{"Session", "Node"}

func (ec *executionContext) _Session(ctx context.Context, sel ast.SelectionSet, obj *generated.Session) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Session")
		case "id":
			out.Values[i] = ec._Session_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Session_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Session_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Session_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._Session_updatedBy(ctx, field, obj)
		case "sessionToken":
			out.Values[i] = ec._Session_sessionToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "issuedAt":
			out.Values[i] = ec._Session_issuedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiresAt":
			out.Values[i] = ec._Session_expiresAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "organizationID":
			out.Values[i] = ec._Session_organizationID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._Session_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Session_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionConnectionImplementors = []string{"SessionConnection"}

func (ec *executionContext) _SessionConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.SessionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SessionConnection")
		case "edges":
			out.Values[i] = ec._SessionConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._SessionConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._SessionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionCreatePayloadImplementors = []string{"SessionCreatePayload"}

func (ec *executionContext) _SessionCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *SessionCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SessionCreatePayload")
		case "session":
			out.Values[i] = ec._SessionCreatePayload_session(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionDeletePayloadImplementors = []string{"SessionDeletePayload"}

func (ec *executionContext) _SessionDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *SessionDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SessionDeletePayload")
		case "deletedID":
			out.Values[i] = ec._SessionDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionEdgeImplementors = []string{"SessionEdge"}

func (ec *executionContext) _SessionEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.SessionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SessionEdge")
		case "node":
			out.Values[i] = ec._SessionEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._SessionEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sessionUpdatePayloadImplementors = []string{"SessionUpdatePayload"}

func (ec *executionContext) _SessionUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *SessionUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SessionUpdatePayload")
		case "session":
			out.Values[i] = ec._SessionUpdatePayload_session(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *generated.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._User_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._User_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._User_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._User_deletedBy(ctx, field, obj)
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "firstName":
			out.Values[i] = ec._User_firstName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastName":
			out.Values[i] = ec._User_lastName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._User_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "avatarRemoteURL":
			out.Values[i] = ec._User_avatarRemoteURL(ctx, field, obj)
		case "avatarLocalFile":
			out.Values[i] = ec._User_avatarLocalFile(ctx, field, obj)
		case "avatarUpdatedAt":
			out.Values[i] = ec._User_avatarUpdatedAt(ctx, field, obj)
		case "lastSeen":
			out.Values[i] = ec._User_lastSeen(ctx, field, obj)
		case "password":
			out.Values[i] = ec._User_password(ctx, field, obj)
		case "sub":
			out.Values[i] = ec._User_sub(ctx, field, obj)
		case "oauth":
			out.Values[i] = ec._User_oauth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "organizations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_organizations(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "sessions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_sessions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_groups(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "personalAccessTokens":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_personalAccessTokens(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "setting":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_setting(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (ec *executionContext) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.UserConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConnection")
		case "edges":
			out.Values[i] = ec._UserConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._UserConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._UserConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userCreatePayloadImplementors = []string{"UserCreatePayload"}

func (ec *executionContext) _UserCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *UserCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserCreatePayload")
		case "user":
			out.Values[i] = ec._UserCreatePayload_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userDeletePayloadImplementors = []string{"UserDeletePayload"}

func (ec *executionContext) _UserDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *UserDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserDeletePayload")
		case "deletedID":
			out.Values[i] = ec._UserDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.UserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "node":
			out.Values[i] = ec._UserEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingImplementors = []string{"UserSetting", "Node"}

func (ec *executionContext) _UserSetting(ctx context.Context, sel ast.SelectionSet, obj *generated.UserSetting) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSetting")
		case "id":
			out.Values[i] = ec._UserSetting_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._UserSetting_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._UserSetting_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._UserSetting_createdBy(ctx, field, obj)
		case "updatedBy":
			out.Values[i] = ec._UserSetting_updatedBy(ctx, field, obj)
		case "deletedAt":
			out.Values[i] = ec._UserSetting_deletedAt(ctx, field, obj)
		case "deletedBy":
			out.Values[i] = ec._UserSetting_deletedBy(ctx, field, obj)
		case "locked":
			out.Values[i] = ec._UserSetting_locked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "silencedAt":
			out.Values[i] = ec._UserSetting_silencedAt(ctx, field, obj)
		case "suspendedAt":
			out.Values[i] = ec._UserSetting_suspendedAt(ctx, field, obj)
		case "status":
			out.Values[i] = ec._UserSetting_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "role":
			out.Values[i] = ec._UserSetting_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "permissions":
			out.Values[i] = ec._UserSetting_permissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "emailConfirmed":
			out.Values[i] = ec._UserSetting_emailConfirmed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._UserSetting_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserSetting_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingConnectionImplementors = []string{"UserSettingConnection"}

func (ec *executionContext) _UserSettingConnection(ctx context.Context, sel ast.SelectionSet, obj *generated.UserSettingConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettingConnection")
		case "edges":
			out.Values[i] = ec._UserSettingConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._UserSettingConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._UserSettingConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingCreatePayloadImplementors = []string{"UserSettingCreatePayload"}

func (ec *executionContext) _UserSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, obj *UserSettingCreatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingCreatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettingCreatePayload")
		case "UserSetting":
			out.Values[i] = ec._UserSettingCreatePayload_UserSetting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingDeletePayloadImplementors = []string{"UserSettingDeletePayload"}

func (ec *executionContext) _UserSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, obj *UserSettingDeletePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingDeletePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettingDeletePayload")
		case "deletedID":
			out.Values[i] = ec._UserSettingDeletePayload_deletedID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingEdgeImplementors = []string{"UserSettingEdge"}

func (ec *executionContext) _UserSettingEdge(ctx context.Context, sel ast.SelectionSet, obj *generated.UserSettingEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettingEdge")
		case "node":
			out.Values[i] = ec._UserSettingEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._UserSettingEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingUpdatePayloadImplementors = []string{"UserSettingUpdatePayload"}

func (ec *executionContext) _UserSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *UserSettingUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettingUpdatePayload")
		case "UserSetting":
			out.Values[i] = ec._UserSettingUpdatePayload_UserSetting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userUpdatePayloadImplementors = []string{"UserUpdatePayload"}

func (ec *executionContext) _UserUpdatePayload(ctx context.Context, sel ast.SelectionSet, obj *UserUpdatePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userUpdatePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserUpdatePayload")
		case "user":
			out.Values[i] = ec._UserUpdatePayload_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateEntitlementInput2githubcomdatumforgedatuminternalentgeneratedCreateEntitlementInput(ctx context.Context, v interface{}) (generated.CreateEntitlementInput, error) {
	res, err := ec.unmarshalInputCreateEntitlementInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateGroupInput2githubcomdatumforgedatuminternalentgeneratedCreateGroupInput(ctx context.Context, v interface{}) (generated.CreateGroupInput, error) {
	res, err := ec.unmarshalInputCreateGroupInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateGroupSettingInput2githubcomdatumforgedatuminternalentgeneratedCreateGroupSettingInput(ctx context.Context, v interface{}) (generated.CreateGroupSettingInput, error) {
	res, err := ec.unmarshalInputCreateGroupSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateIntegrationInput2githubcomdatumforgedatuminternalentgeneratedCreateIntegrationInput(ctx context.Context, v interface{}) (generated.CreateIntegrationInput, error) {
	res, err := ec.unmarshalInputCreateIntegrationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateOauthProviderInput2githubcomdatumforgedatuminternalentgeneratedCreateOauthProviderInput(ctx context.Context, v interface{}) (generated.CreateOauthProviderInput, error) {
	res, err := ec.unmarshalInputCreateOauthProviderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateOhAuthTooTokenInput2githubcomdatumforgedatuminternalentgeneratedCreateOhAuthTooTokenInput(ctx context.Context, v interface{}) (generated.CreateOhAuthTooTokenInput, error) {
	res, err := ec.unmarshalInputCreateOhAuthTooTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateOrganizationInput2githubcomdatumforgedatuminternalentgeneratedCreateOrganizationInput(ctx context.Context, v interface{}) (generated.CreateOrganizationInput, error) {
	res, err := ec.unmarshalInputCreateOrganizationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateOrganizationSettingInput2githubcomdatumforgedatuminternalentgeneratedCreateOrganizationSettingInput(ctx context.Context, v interface{}) (generated.CreateOrganizationSettingInput, error) {
	res, err := ec.unmarshalInputCreateOrganizationSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreatePersonalAccessTokenInput2githubcomdatumforgedatuminternalentgeneratedCreatePersonalAccessTokenInput(ctx context.Context, v interface{}) (generated.CreatePersonalAccessTokenInput, error) {
	res, err := ec.unmarshalInputCreatePersonalAccessTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSessionInput2githubcomdatumforgedatuminternalentgeneratedCreateSessionInput(ctx context.Context, v interface{}) (generated.CreateSessionInput, error) {
	res, err := ec.unmarshalInputCreateSessionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserInput2githubcomdatumforgedatuminternalentgeneratedCreateUserInput(ctx context.Context, v interface{}) (generated.CreateUserInput, error) {
	res, err := ec.unmarshalInputCreateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserSettingInput2githubcomdatumforgedatuminternalentgeneratedCreateUserSettingInput(ctx context.Context, v interface{}) (generated.CreateUserSettingInput, error) {
	res, err := ec.unmarshalInputCreateUserSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (entgql.Cursor[string], error) {
	var res entgql.Cursor[string]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[string]) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx context.Context, sel ast.SelectionSet, v generated.Entitlement) graphql.Marshaler {
	return ec._Entitlement(ctx, sel, &v)
}

func (ec *executionContext) marshalNEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx context.Context, sel ast.SelectionSet, v *generated.Entitlement) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Entitlement(ctx, sel, v)
}

func (ec *executionContext) marshalNEntitlementConnection2githubcomdatumforgedatuminternalentgeneratedEntitlementConnection(ctx context.Context, sel ast.SelectionSet, v generated.EntitlementConnection) graphql.Marshaler {
	return ec._EntitlementConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNEntitlementConnection2githubcomdatumforgedatuminternalentgeneratedEntitlementConnection(ctx context.Context, sel ast.SelectionSet, v *generated.EntitlementConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntitlementConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNEntitlementCreatePayload2githubcomdatumforgedatuminternalgraphapiEntitlementCreatePayload(ctx context.Context, sel ast.SelectionSet, v EntitlementCreatePayload) graphql.Marshaler {
	return ec._EntitlementCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNEntitlementCreatePayload2githubcomdatumforgedatuminternalgraphapiEntitlementCreatePayload(ctx context.Context, sel ast.SelectionSet, v *EntitlementCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntitlementCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNEntitlementDeletePayload2githubcomdatumforgedatuminternalgraphapiEntitlementDeletePayload(ctx context.Context, sel ast.SelectionSet, v EntitlementDeletePayload) graphql.Marshaler {
	return ec._EntitlementDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNEntitlementDeletePayload2githubcomdatumforgedatuminternalgraphapiEntitlementDeletePayload(ctx context.Context, sel ast.SelectionSet, v *EntitlementDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntitlementDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx context.Context, v interface{}) (entitlement.Tier, error) {
	var res entitlement.Tier
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx context.Context, sel ast.SelectionSet, v entitlement.Tier) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEntitlementUpdatePayload2githubcomdatumforgedatuminternalgraphapiEntitlementUpdatePayload(ctx context.Context, sel ast.SelectionSet, v EntitlementUpdatePayload) graphql.Marshaler {
	return ec._EntitlementUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNEntitlementUpdatePayload2githubcomdatumforgedatuminternalgraphapiEntitlementUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *EntitlementUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntitlementUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx context.Context, v interface{}) (*generated.EntitlementWhereInput, error) {
	res, err := ec.unmarshalInputEntitlementWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx context.Context, sel ast.SelectionSet, v generated.Group) graphql.Marshaler {
	return ec._Group(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx context.Context, sel ast.SelectionSet, v *generated.Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupConnection2githubcomdatumforgedatuminternalentgeneratedGroupConnection(ctx context.Context, sel ast.SelectionSet, v generated.GroupConnection) graphql.Marshaler {
	return ec._GroupConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupConnection2githubcomdatumforgedatuminternalentgeneratedGroupConnection(ctx context.Context, sel ast.SelectionSet, v *generated.GroupConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupCreatePayload2githubcomdatumforgedatuminternalgraphapiGroupCreatePayload(ctx context.Context, sel ast.SelectionSet, v GroupCreatePayload) graphql.Marshaler {
	return ec._GroupCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupCreatePayload2githubcomdatumforgedatuminternalgraphapiGroupCreatePayload(ctx context.Context, sel ast.SelectionSet, v *GroupCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupDeletePayload2githubcomdatumforgedatuminternalgraphapiGroupDeletePayload(ctx context.Context, sel ast.SelectionSet, v GroupDeletePayload) graphql.Marshaler {
	return ec._GroupDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupDeletePayload2githubcomdatumforgedatuminternalgraphapiGroupDeletePayload(ctx context.Context, sel ast.SelectionSet, v *GroupDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupOrderField2githubcomdatumforgedatuminternalentgeneratedGroupOrderField(ctx context.Context, v interface{}) (*generated.GroupOrderField, error) {
	var res = new(generated.GroupOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroupOrderField2githubcomdatumforgedatuminternalentgeneratedGroupOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.GroupOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx context.Context, sel ast.SelectionSet, v generated.GroupSetting) graphql.Marshaler {
	return ec._GroupSetting(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx context.Context, sel ast.SelectionSet, v *generated.GroupSetting) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupSetting(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupSettingConnection2githubcomdatumforgedatuminternalentgeneratedGroupSettingConnection(ctx context.Context, sel ast.SelectionSet, v generated.GroupSettingConnection) graphql.Marshaler {
	return ec._GroupSettingConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupSettingConnection2githubcomdatumforgedatuminternalentgeneratedGroupSettingConnection(ctx context.Context, sel ast.SelectionSet, v *generated.GroupSettingConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupSettingConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, v GroupSettingCreatePayload) graphql.Marshaler {
	return ec._GroupSettingCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, v *GroupSettingCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupSettingCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, v GroupSettingDeletePayload) graphql.Marshaler {
	return ec._GroupSettingDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, v *GroupSettingDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupSettingDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx context.Context, v interface{}) (groupsetting.JoinPolicy, error) {
	var res groupsetting.JoinPolicy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx context.Context, sel ast.SelectionSet, v groupsetting.JoinPolicy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGroupSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, v GroupSettingUpdatePayload) graphql.Marshaler {
	return ec._GroupSettingUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiGroupSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *GroupSettingUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupSettingUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx context.Context, v interface{}) (groupsetting.Visibility, error) {
	var res groupsetting.Visibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx context.Context, sel ast.SelectionSet, v groupsetting.Visibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx context.Context, v interface{}) (*generated.GroupSettingWhereInput, error) {
	res, err := ec.unmarshalInputGroupSettingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroupUpdatePayload2githubcomdatumforgedatuminternalgraphapiGroupUpdatePayload(ctx context.Context, sel ast.SelectionSet, v GroupUpdatePayload) graphql.Marshaler {
	return ec._GroupUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupUpdatePayload2githubcomdatumforgedatuminternalgraphapiGroupUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *GroupUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx context.Context, v interface{}) (*generated.GroupWhereInput, error) {
	res, err := ec.unmarshalInputGroupWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx context.Context, sel ast.SelectionSet, v generated.Integration) graphql.Marshaler {
	return ec._Integration(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx context.Context, sel ast.SelectionSet, v *generated.Integration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Integration(ctx, sel, v)
}

func (ec *executionContext) marshalNIntegrationConnection2githubcomdatumforgedatuminternalentgeneratedIntegrationConnection(ctx context.Context, sel ast.SelectionSet, v generated.IntegrationConnection) graphql.Marshaler {
	return ec._IntegrationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationConnection2githubcomdatumforgedatuminternalentgeneratedIntegrationConnection(ctx context.Context, sel ast.SelectionSet, v *generated.IntegrationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNIntegrationCreatePayload2githubcomdatumforgedatuminternalgraphapiIntegrationCreatePayload(ctx context.Context, sel ast.SelectionSet, v IntegrationCreatePayload) graphql.Marshaler {
	return ec._IntegrationCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationCreatePayload2githubcomdatumforgedatuminternalgraphapiIntegrationCreatePayload(ctx context.Context, sel ast.SelectionSet, v *IntegrationCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNIntegrationDeletePayload2githubcomdatumforgedatuminternalgraphapiIntegrationDeletePayload(ctx context.Context, sel ast.SelectionSet, v IntegrationDeletePayload) graphql.Marshaler {
	return ec._IntegrationDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationDeletePayload2githubcomdatumforgedatuminternalgraphapiIntegrationDeletePayload(ctx context.Context, sel ast.SelectionSet, v *IntegrationDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIntegrationOrderField2githubcomdatumforgedatuminternalentgeneratedIntegrationOrderField(ctx context.Context, v interface{}) (*generated.IntegrationOrderField, error) {
	var res = new(generated.IntegrationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIntegrationOrderField2githubcomdatumforgedatuminternalentgeneratedIntegrationOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.IntegrationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNIntegrationUpdatePayload2githubcomdatumforgedatuminternalgraphapiIntegrationUpdatePayload(ctx context.Context, sel ast.SelectionSet, v IntegrationUpdatePayload) graphql.Marshaler {
	return ec._IntegrationUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNIntegrationUpdatePayload2githubcomdatumforgedatuminternalgraphapiIntegrationUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *IntegrationUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IntegrationUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx context.Context, v interface{}) (*generated.IntegrationWhereInput, error) {
	res, err := ec.unmarshalInputIntegrationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2githubcomdatumforgedatuminternalentgeneratedNoder(ctx context.Context, sel ast.SelectionSet, v []generated.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubcomdatumforgedatuminternalentgeneratedNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx context.Context, sel ast.SelectionSet, v generated.OauthProvider) graphql.Marshaler {
	return ec._OauthProvider(ctx, sel, &v)
}

func (ec *executionContext) marshalNOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx context.Context, sel ast.SelectionSet, v *generated.OauthProvider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OauthProvider(ctx, sel, v)
}

func (ec *executionContext) marshalNOauthProviderConnection2githubcomdatumforgedatuminternalentgeneratedOauthProviderConnection(ctx context.Context, sel ast.SelectionSet, v generated.OauthProviderConnection) graphql.Marshaler {
	return ec._OauthProviderConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOauthProviderConnection2githubcomdatumforgedatuminternalentgeneratedOauthProviderConnection(ctx context.Context, sel ast.SelectionSet, v *generated.OauthProviderConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OauthProviderConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOauthProviderCreatePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderCreatePayload(ctx context.Context, sel ast.SelectionSet, v OauthProviderCreatePayload) graphql.Marshaler {
	return ec._OauthProviderCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOauthProviderCreatePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderCreatePayload(ctx context.Context, sel ast.SelectionSet, v *OauthProviderCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OauthProviderCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOauthProviderDeletePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderDeletePayload(ctx context.Context, sel ast.SelectionSet, v OauthProviderDeletePayload) graphql.Marshaler {
	return ec._OauthProviderDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOauthProviderDeletePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderDeletePayload(ctx context.Context, sel ast.SelectionSet, v *OauthProviderDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OauthProviderDeletePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOauthProviderUpdatePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderUpdatePayload(ctx context.Context, sel ast.SelectionSet, v OauthProviderUpdatePayload) graphql.Marshaler {
	return ec._OauthProviderUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOauthProviderUpdatePayload2githubcomdatumforgedatuminternalgraphapiOauthProviderUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *OauthProviderUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OauthProviderUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx context.Context, v interface{}) (*generated.OauthProviderWhereInput, error) {
	res, err := ec.unmarshalInputOauthProviderWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx context.Context, sel ast.SelectionSet, v generated.OhAuthTooToken) graphql.Marshaler {
	return ec._OhAuthTooToken(ctx, sel, &v)
}

func (ec *executionContext) marshalNOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx context.Context, sel ast.SelectionSet, v *generated.OhAuthTooToken) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OhAuthTooToken(ctx, sel, v)
}

func (ec *executionContext) marshalNOhAuthTooTokenConnection2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenConnection(ctx context.Context, sel ast.SelectionSet, v generated.OhAuthTooTokenConnection) graphql.Marshaler {
	return ec._OhAuthTooTokenConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOhAuthTooTokenConnection2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenConnection(ctx context.Context, sel ast.SelectionSet, v *generated.OhAuthTooTokenConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OhAuthTooTokenConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOhAuthTooTokenCreatePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenCreatePayload(ctx context.Context, sel ast.SelectionSet, v OhAuthTooTokenCreatePayload) graphql.Marshaler {
	return ec._OhAuthTooTokenCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOhAuthTooTokenCreatePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenCreatePayload(ctx context.Context, sel ast.SelectionSet, v *OhAuthTooTokenCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OhAuthTooTokenCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOhAuthTooTokenDeletePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenDeletePayload(ctx context.Context, sel ast.SelectionSet, v OhAuthTooTokenDeletePayload) graphql.Marshaler {
	return ec._OhAuthTooTokenDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOhAuthTooTokenDeletePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenDeletePayload(ctx context.Context, sel ast.SelectionSet, v *OhAuthTooTokenDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OhAuthTooTokenDeletePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOhAuthTooTokenUpdatePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenUpdatePayload(ctx context.Context, sel ast.SelectionSet, v OhAuthTooTokenUpdatePayload) graphql.Marshaler {
	return ec._OhAuthTooTokenUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOhAuthTooTokenUpdatePayload2githubcomdatumforgedatuminternalgraphapiOhAuthTooTokenUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *OhAuthTooTokenUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OhAuthTooTokenUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx context.Context, v interface{}) (*generated.OhAuthTooTokenWhereInput, error) {
	res, err := ec.unmarshalInputOhAuthTooTokenWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx context.Context, sel ast.SelectionSet, v generated.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx context.Context, sel ast.SelectionSet, v *generated.Organization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationConnection(ctx context.Context, sel ast.SelectionSet, v generated.OrganizationConnection) graphql.Marshaler {
	return ec._OrganizationConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationConnection(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationCreatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationCreatePayload(ctx context.Context, sel ast.SelectionSet, v OrganizationCreatePayload) graphql.Marshaler {
	return ec._OrganizationCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationCreatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationCreatePayload(ctx context.Context, sel ast.SelectionSet, v *OrganizationCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationDeletePayload2githubcomdatumforgedatuminternalgraphapiOrganizationDeletePayload(ctx context.Context, sel ast.SelectionSet, v OrganizationDeletePayload) graphql.Marshaler {
	return ec._OrganizationDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationDeletePayload2githubcomdatumforgedatuminternalgraphapiOrganizationDeletePayload(ctx context.Context, sel ast.SelectionSet, v *OrganizationDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrganizationOrderField2githubcomdatumforgedatuminternalentgeneratedOrganizationOrderField(ctx context.Context, v interface{}) (*generated.OrganizationOrderField, error) {
	var res = new(generated.OrganizationOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrganizationOrderField2githubcomdatumforgedatuminternalentgeneratedOrganizationOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx context.Context, sel ast.SelectionSet, v generated.OrganizationSetting) graphql.Marshaler {
	return ec._OrganizationSetting(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationSetting) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationSetting(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationSettingConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingConnection(ctx context.Context, sel ast.SelectionSet, v generated.OrganizationSettingConnection) graphql.Marshaler {
	return ec._OrganizationSettingConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationSettingConnection2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingConnection(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationSettingConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationSettingConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, v OrganizationSettingCreatePayload) graphql.Marshaler {
	return ec._OrganizationSettingCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, v *OrganizationSettingCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationSettingCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, v OrganizationSettingDeletePayload) graphql.Marshaler {
	return ec._OrganizationSettingDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, v *OrganizationSettingDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationSettingDeletePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganizationSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, v OrganizationSettingUpdatePayload) graphql.Marshaler {
	return ec._OrganizationSettingUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *OrganizationSettingUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationSettingUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx context.Context, v interface{}) (*generated.OrganizationSettingWhereInput, error) {
	res, err := ec.unmarshalInputOrganizationSettingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrganizationUpdatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationUpdatePayload(ctx context.Context, sel ast.SelectionSet, v OrganizationUpdatePayload) graphql.Marshaler {
	return ec._OrganizationUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganizationUpdatePayload2githubcomdatumforgedatuminternalgraphapiOrganizationUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *OrganizationUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OrganizationUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx context.Context, v interface{}) (*generated.OrganizationWhereInput, error) {
	res, err := ec.unmarshalInputOrganizationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[string]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx context.Context, sel ast.SelectionSet, v generated.PersonalAccessToken) graphql.Marshaler {
	return ec._PersonalAccessToken(ctx, sel, &v)
}

func (ec *executionContext) marshalNPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx context.Context, sel ast.SelectionSet, v *generated.PersonalAccessToken) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PersonalAccessToken(ctx, sel, v)
}

func (ec *executionContext) marshalNPersonalAccessTokenConnection2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenConnection(ctx context.Context, sel ast.SelectionSet, v generated.PersonalAccessTokenConnection) graphql.Marshaler {
	return ec._PersonalAccessTokenConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPersonalAccessTokenConnection2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenConnection(ctx context.Context, sel ast.SelectionSet, v *generated.PersonalAccessTokenConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PersonalAccessTokenConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNPersonalAccessTokenCreatePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenCreatePayload(ctx context.Context, sel ast.SelectionSet, v PersonalAccessTokenCreatePayload) graphql.Marshaler {
	return ec._PersonalAccessTokenCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNPersonalAccessTokenCreatePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenCreatePayload(ctx context.Context, sel ast.SelectionSet, v *PersonalAccessTokenCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PersonalAccessTokenCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNPersonalAccessTokenDeletePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenDeletePayload(ctx context.Context, sel ast.SelectionSet, v PersonalAccessTokenDeletePayload) graphql.Marshaler {
	return ec._PersonalAccessTokenDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNPersonalAccessTokenDeletePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenDeletePayload(ctx context.Context, sel ast.SelectionSet, v *PersonalAccessTokenDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PersonalAccessTokenDeletePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNPersonalAccessTokenUpdatePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenUpdatePayload(ctx context.Context, sel ast.SelectionSet, v PersonalAccessTokenUpdatePayload) graphql.Marshaler {
	return ec._PersonalAccessTokenUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNPersonalAccessTokenUpdatePayload2githubcomdatumforgedatuminternalgraphapiPersonalAccessTokenUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *PersonalAccessTokenUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PersonalAccessTokenUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx context.Context, v interface{}) (*generated.PersonalAccessTokenWhereInput, error) {
	res, err := ec.unmarshalInputPersonalAccessTokenWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx context.Context, sel ast.SelectionSet, v generated.Session) graphql.Marshaler {
	return ec._Session(ctx, sel, &v)
}

func (ec *executionContext) marshalNSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx context.Context, sel ast.SelectionSet, v *generated.Session) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Session(ctx, sel, v)
}

func (ec *executionContext) marshalNSessionConnection2githubcomdatumforgedatuminternalentgeneratedSessionConnection(ctx context.Context, sel ast.SelectionSet, v generated.SessionConnection) graphql.Marshaler {
	return ec._SessionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSessionConnection2githubcomdatumforgedatuminternalentgeneratedSessionConnection(ctx context.Context, sel ast.SelectionSet, v *generated.SessionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SessionConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNSessionCreatePayload2githubcomdatumforgedatuminternalgraphapiSessionCreatePayload(ctx context.Context, sel ast.SelectionSet, v SessionCreatePayload) graphql.Marshaler {
	return ec._SessionCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSessionCreatePayload2githubcomdatumforgedatuminternalgraphapiSessionCreatePayload(ctx context.Context, sel ast.SelectionSet, v *SessionCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SessionCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNSessionDeletePayload2githubcomdatumforgedatuminternalgraphapiSessionDeletePayload(ctx context.Context, sel ast.SelectionSet, v SessionDeletePayload) graphql.Marshaler {
	return ec._SessionDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSessionDeletePayload2githubcomdatumforgedatuminternalgraphapiSessionDeletePayload(ctx context.Context, sel ast.SelectionSet, v *SessionDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SessionDeletePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNSessionUpdatePayload2githubcomdatumforgedatuminternalgraphapiSessionUpdatePayload(ctx context.Context, sel ast.SelectionSet, v SessionUpdatePayload) graphql.Marshaler {
	return ec._SessionUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSessionUpdatePayload2githubcomdatumforgedatuminternalgraphapiSessionUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *SessionUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SessionUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx context.Context, v interface{}) (*generated.SessionWhereInput, error) {
	res, err := ec.unmarshalInputSessionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateEntitlementInput2githubcomdatumforgedatuminternalentgeneratedUpdateEntitlementInput(ctx context.Context, v interface{}) (generated.UpdateEntitlementInput, error) {
	res, err := ec.unmarshalInputUpdateEntitlementInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGroupInput2githubcomdatumforgedatuminternalentgeneratedUpdateGroupInput(ctx context.Context, v interface{}) (generated.UpdateGroupInput, error) {
	res, err := ec.unmarshalInputUpdateGroupInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateGroupSettingInput2githubcomdatumforgedatuminternalentgeneratedUpdateGroupSettingInput(ctx context.Context, v interface{}) (generated.UpdateGroupSettingInput, error) {
	res, err := ec.unmarshalInputUpdateGroupSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateIntegrationInput2githubcomdatumforgedatuminternalentgeneratedUpdateIntegrationInput(ctx context.Context, v interface{}) (generated.UpdateIntegrationInput, error) {
	res, err := ec.unmarshalInputUpdateIntegrationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateOauthProviderInput2githubcomdatumforgedatuminternalentgeneratedUpdateOauthProviderInput(ctx context.Context, v interface{}) (generated.UpdateOauthProviderInput, error) {
	res, err := ec.unmarshalInputUpdateOauthProviderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateOhAuthTooTokenInput2githubcomdatumforgedatuminternalentgeneratedUpdateOhAuthTooTokenInput(ctx context.Context, v interface{}) (generated.UpdateOhAuthTooTokenInput, error) {
	res, err := ec.unmarshalInputUpdateOhAuthTooTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateOrganizationInput2githubcomdatumforgedatuminternalentgeneratedUpdateOrganizationInput(ctx context.Context, v interface{}) (generated.UpdateOrganizationInput, error) {
	res, err := ec.unmarshalInputUpdateOrganizationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateOrganizationSettingInput2githubcomdatumforgedatuminternalentgeneratedUpdateOrganizationSettingInput(ctx context.Context, v interface{}) (generated.UpdateOrganizationSettingInput, error) {
	res, err := ec.unmarshalInputUpdateOrganizationSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdatePersonalAccessTokenInput2githubcomdatumforgedatuminternalentgeneratedUpdatePersonalAccessTokenInput(ctx context.Context, v interface{}) (generated.UpdatePersonalAccessTokenInput, error) {
	res, err := ec.unmarshalInputUpdatePersonalAccessTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSessionInput2githubcomdatumforgedatuminternalentgeneratedUpdateSessionInput(ctx context.Context, v interface{}) (generated.UpdateSessionInput, error) {
	res, err := ec.unmarshalInputUpdateSessionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserInput2githubcomdatumforgedatuminternalentgeneratedUpdateUserInput(ctx context.Context, v interface{}) (generated.UpdateUserInput, error) {
	res, err := ec.unmarshalInputUpdateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserSettingInput2githubcomdatumforgedatuminternalentgeneratedUpdateUserSettingInput(ctx context.Context, v interface{}) (generated.UpdateUserSettingInput, error) {
	res, err := ec.unmarshalInputUpdateUserSettingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx context.Context, sel ast.SelectionSet, v generated.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx context.Context, sel ast.SelectionSet, v *generated.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserConnection2githubcomdatumforgedatuminternalentgeneratedUserConnection(ctx context.Context, sel ast.SelectionSet, v generated.UserConnection) graphql.Marshaler {
	return ec._UserConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserConnection2githubcomdatumforgedatuminternalentgeneratedUserConnection(ctx context.Context, sel ast.SelectionSet, v *generated.UserConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNUserCreatePayload2githubcomdatumforgedatuminternalgraphapiUserCreatePayload(ctx context.Context, sel ast.SelectionSet, v UserCreatePayload) graphql.Marshaler {
	return ec._UserCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserCreatePayload2githubcomdatumforgedatuminternalgraphapiUserCreatePayload(ctx context.Context, sel ast.SelectionSet, v *UserCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUserDeletePayload2githubcomdatumforgedatuminternalgraphapiUserDeletePayload(ctx context.Context, sel ast.SelectionSet, v UserDeletePayload) graphql.Marshaler {
	return ec._UserDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserDeletePayload2githubcomdatumforgedatuminternalgraphapiUserDeletePayload(ctx context.Context, sel ast.SelectionSet, v *UserDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserOrderField2githubcomdatumforgedatuminternalentgeneratedUserOrderField(ctx context.Context, v interface{}) (*generated.UserOrderField, error) {
	var res = new(generated.UserOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2githubcomdatumforgedatuminternalentgeneratedUserOrderField(ctx context.Context, sel ast.SelectionSet, v *generated.UserOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx context.Context, sel ast.SelectionSet, v generated.UserSetting) graphql.Marshaler {
	return ec._UserSetting(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx context.Context, sel ast.SelectionSet, v *generated.UserSetting) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSetting(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSettingConnection2githubcomdatumforgedatuminternalentgeneratedUserSettingConnection(ctx context.Context, sel ast.SelectionSet, v generated.UserSettingConnection) graphql.Marshaler {
	return ec._UserSettingConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSettingConnection2githubcomdatumforgedatuminternalentgeneratedUserSettingConnection(ctx context.Context, sel ast.SelectionSet, v *generated.UserSettingConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSettingConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiUserSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, v UserSettingCreatePayload) graphql.Marshaler {
	return ec._UserSettingCreatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSettingCreatePayload2githubcomdatumforgedatuminternalgraphapiUserSettingCreatePayload(ctx context.Context, sel ast.SelectionSet, v *UserSettingCreatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSettingCreatePayload(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiUserSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, v UserSettingDeletePayload) graphql.Marshaler {
	return ec._UserSettingDeletePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSettingDeletePayload2githubcomdatumforgedatuminternalgraphapiUserSettingDeletePayload(ctx context.Context, sel ast.SelectionSet, v *UserSettingDeletePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSettingDeletePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx context.Context, v interface{}) (usersetting.Role, error) {
	var res usersetting.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx context.Context, sel ast.SelectionSet, v usersetting.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx context.Context, v interface{}) (usersetting.Status, error) {
	var res usersetting.Status
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx context.Context, sel ast.SelectionSet, v usersetting.Status) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUserSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiUserSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, v UserSettingUpdatePayload) graphql.Marshaler {
	return ec._UserSettingUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserSettingUpdatePayload2githubcomdatumforgedatuminternalgraphapiUserSettingUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *UserSettingUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSettingUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx context.Context, v interface{}) (*generated.UserSettingWhereInput, error) {
	res, err := ec.unmarshalInputUserSettingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserUpdatePayload2githubcomdatumforgedatuminternalgraphapiUserUpdatePayload(ctx context.Context, sel ast.SelectionSet, v UserUpdatePayload) graphql.Marshaler {
	return ec._UserUpdatePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserUpdatePayload2githubcomdatumforgedatuminternalgraphapiUserUpdatePayload(ctx context.Context, sel ast.SelectionSet, v *UserUpdatePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserUpdatePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx context.Context, v interface{}) (*generated.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (*entgql.Cursor[string], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[string])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[string]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx context.Context, sel ast.SelectionSet, v []*generated.Entitlement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOEntitlement2githubcomdatumforgedatuminternalentgeneratedEntitlement(ctx context.Context, sel ast.SelectionSet, v *generated.Entitlement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Entitlement(ctx, sel, v)
}

func (ec *executionContext) marshalOEntitlementEdge2githubcomdatumforgedatuminternalentgeneratedEntitlementEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.EntitlementEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEntitlementEdge2githubcomdatumforgedatuminternalentgeneratedEntitlementEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOEntitlementEdge2githubcomdatumforgedatuminternalentgeneratedEntitlementEdge(ctx context.Context, sel ast.SelectionSet, v *generated.EntitlementEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EntitlementEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx context.Context, v interface{}) ([]entitlement.Tier, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]entitlement.Tier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx context.Context, sel ast.SelectionSet, v []entitlement.Tier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx context.Context, v interface{}) (*entitlement.Tier, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entitlement.Tier)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEntitlementTier2githubcomdatumforgedatuminternalentgeneratedentitlementTier(ctx context.Context, sel ast.SelectionSet, v *entitlement.Tier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx context.Context, v interface{}) ([]*generated.EntitlementWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.EntitlementWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEntitlementWhereInput2githubcomdatumforgedatuminternalentgeneratedEntitlementWhereInput(ctx context.Context, v interface{}) (*generated.EntitlementWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEntitlementWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx context.Context, sel ast.SelectionSet, v []*generated.Group) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGroup2githubcomdatumforgedatuminternalentgeneratedGroup(ctx context.Context, sel ast.SelectionSet, v *generated.Group) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) marshalOGroupEdge2githubcomdatumforgedatuminternalentgeneratedGroupEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.GroupEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupEdge2githubcomdatumforgedatuminternalentgeneratedGroupEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGroupEdge2githubcomdatumforgedatuminternalentgeneratedGroupEdge(ctx context.Context, sel ast.SelectionSet, v *generated.GroupEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGroupOrder2githubcomdatumforgedatuminternalentgeneratedGroupOrder(ctx context.Context, v interface{}) (*generated.GroupOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGroupOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupSetting2githubcomdatumforgedatuminternalentgeneratedGroupSetting(ctx context.Context, sel ast.SelectionSet, v *generated.GroupSetting) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupSetting(ctx, sel, v)
}

func (ec *executionContext) marshalOGroupSettingEdge2githubcomdatumforgedatuminternalentgeneratedGroupSettingEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.GroupSettingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupSettingEdge2githubcomdatumforgedatuminternalentgeneratedGroupSettingEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGroupSettingEdge2githubcomdatumforgedatuminternalentgeneratedGroupSettingEdge(ctx context.Context, sel ast.SelectionSet, v *generated.GroupSettingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupSettingEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx context.Context, v interface{}) ([]groupsetting.JoinPolicy, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]groupsetting.JoinPolicy, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx context.Context, sel ast.SelectionSet, v []groupsetting.JoinPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx context.Context, v interface{}) (*groupsetting.JoinPolicy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(groupsetting.JoinPolicy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupSettingJoinPolicy2githubcomdatumforgedatuminternalentgeneratedgroupsettingJoinPolicy(ctx context.Context, sel ast.SelectionSet, v *groupsetting.JoinPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx context.Context, v interface{}) ([]groupsetting.Visibility, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]groupsetting.Visibility, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx context.Context, sel ast.SelectionSet, v []groupsetting.Visibility) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx context.Context, v interface{}) (*groupsetting.Visibility, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(groupsetting.Visibility)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupSettingVisibility2githubcomdatumforgedatuminternalentgeneratedgroupsettingVisibility(ctx context.Context, sel ast.SelectionSet, v *groupsetting.Visibility) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx context.Context, v interface{}) ([]*generated.GroupSettingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.GroupSettingWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGroupSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupSettingWhereInput(ctx context.Context, v interface{}) (*generated.GroupSettingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGroupSettingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx context.Context, v interface{}) ([]*generated.GroupWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.GroupWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGroupWhereInput2githubcomdatumforgedatuminternalentgeneratedGroupWhereInput(ctx context.Context, v interface{}) (*generated.GroupWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGroupWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx context.Context, sel ast.SelectionSet, v []*generated.Integration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOIntegration2githubcomdatumforgedatuminternalentgeneratedIntegration(ctx context.Context, sel ast.SelectionSet, v *generated.Integration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Integration(ctx, sel, v)
}

func (ec *executionContext) marshalOIntegrationEdge2githubcomdatumforgedatuminternalentgeneratedIntegrationEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.IntegrationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIntegrationEdge2githubcomdatumforgedatuminternalentgeneratedIntegrationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOIntegrationEdge2githubcomdatumforgedatuminternalentgeneratedIntegrationEdge(ctx context.Context, sel ast.SelectionSet, v *generated.IntegrationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IntegrationEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOIntegrationOrder2githubcomdatumforgedatuminternalentgeneratedIntegrationOrder(ctx context.Context, v interface{}) (*generated.IntegrationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntegrationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx context.Context, v interface{}) ([]*generated.IntegrationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.IntegrationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOIntegrationWhereInput2githubcomdatumforgedatuminternalentgeneratedIntegrationWhereInput(ctx context.Context, v interface{}) (*generated.IntegrationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntegrationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubcomdatumforgedatuminternalentgeneratedNoder(ctx context.Context, sel ast.SelectionSet, v generated.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx context.Context, sel ast.SelectionSet, v []*generated.OauthProvider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOauthProvider2githubcomdatumforgedatuminternalentgeneratedOauthProvider(ctx context.Context, sel ast.SelectionSet, v *generated.OauthProvider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OauthProvider(ctx, sel, v)
}

func (ec *executionContext) marshalOOauthProviderEdge2githubcomdatumforgedatuminternalentgeneratedOauthProviderEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.OauthProviderEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOauthProviderEdge2githubcomdatumforgedatuminternalentgeneratedOauthProviderEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOOauthProviderEdge2githubcomdatumforgedatuminternalentgeneratedOauthProviderEdge(ctx context.Context, sel ast.SelectionSet, v *generated.OauthProviderEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OauthProviderEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx context.Context, v interface{}) ([]*generated.OauthProviderWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.OauthProviderWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOauthProviderWhereInput2githubcomdatumforgedatuminternalentgeneratedOauthProviderWhereInput(ctx context.Context, v interface{}) (*generated.OauthProviderWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOauthProviderWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOhAuthTooToken2githubcomdatumforgedatuminternalentgeneratedOhAuthTooToken(ctx context.Context, sel ast.SelectionSet, v *generated.OhAuthTooToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OhAuthTooToken(ctx, sel, v)
}

func (ec *executionContext) marshalOOhAuthTooTokenEdge2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.OhAuthTooTokenEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOhAuthTooTokenEdge2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOOhAuthTooTokenEdge2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenEdge(ctx context.Context, sel ast.SelectionSet, v *generated.OhAuthTooTokenEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OhAuthTooTokenEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx context.Context, v interface{}) ([]*generated.OhAuthTooTokenWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.OhAuthTooTokenWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOhAuthTooTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedOhAuthTooTokenWhereInput(ctx context.Context, v interface{}) (*generated.OhAuthTooTokenWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOhAuthTooTokenWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx context.Context, sel ast.SelectionSet, v []*generated.Organization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOrganization2githubcomdatumforgedatuminternalentgeneratedOrganization(ctx context.Context, sel ast.SelectionSet, v *generated.Organization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) marshalOOrganizationEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.OrganizationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOrganizationEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOOrganizationEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationEdge(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OrganizationEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOrganizationOrder2githubcomdatumforgedatuminternalentgeneratedOrganizationOrder(ctx context.Context, v interface{}) (*generated.OrganizationOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrganizationOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrganizationSetting2githubcomdatumforgedatuminternalentgeneratedOrganizationSetting(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationSetting) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OrganizationSetting(ctx, sel, v)
}

func (ec *executionContext) marshalOOrganizationSettingEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.OrganizationSettingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOrganizationSettingEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOOrganizationSettingEdge2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingEdge(ctx context.Context, sel ast.SelectionSet, v *generated.OrganizationSettingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OrganizationSettingEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx context.Context, v interface{}) ([]*generated.OrganizationSettingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.OrganizationSettingWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOrganizationSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationSettingWhereInput(ctx context.Context, v interface{}) (*generated.OrganizationSettingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrganizationSettingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx context.Context, v interface{}) ([]*generated.OrganizationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.OrganizationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOOrganizationWhereInput2githubcomdatumforgedatuminternalentgeneratedOrganizationWhereInput(ctx context.Context, v interface{}) (*generated.OrganizationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOrganizationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx context.Context, sel ast.SelectionSet, v []*generated.PersonalAccessToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPersonalAccessToken2githubcomdatumforgedatuminternalentgeneratedPersonalAccessToken(ctx context.Context, sel ast.SelectionSet, v *generated.PersonalAccessToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PersonalAccessToken(ctx, sel, v)
}

func (ec *executionContext) marshalOPersonalAccessTokenEdge2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.PersonalAccessTokenEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPersonalAccessTokenEdge2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPersonalAccessTokenEdge2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenEdge(ctx context.Context, sel ast.SelectionSet, v *generated.PersonalAccessTokenEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PersonalAccessTokenEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx context.Context, v interface{}) ([]*generated.PersonalAccessTokenWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.PersonalAccessTokenWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPersonalAccessTokenWhereInput2githubcomdatumforgedatuminternalentgeneratedPersonalAccessTokenWhereInput(ctx context.Context, v interface{}) (*generated.PersonalAccessTokenWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPersonalAccessTokenWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx context.Context, sel ast.SelectionSet, v []*generated.Session) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSession2githubcomdatumforgedatuminternalentgeneratedSession(ctx context.Context, sel ast.SelectionSet, v *generated.Session) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Session(ctx, sel, v)
}

func (ec *executionContext) marshalOSessionEdge2githubcomdatumforgedatuminternalentgeneratedSessionEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.SessionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSessionEdge2githubcomdatumforgedatuminternalentgeneratedSessionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSessionEdge2githubcomdatumforgedatuminternalentgeneratedSessionEdge(ctx context.Context, sel ast.SelectionSet, v *generated.SessionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SessionEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx context.Context, v interface{}) ([]*generated.SessionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.SessionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSessionWhereInput2githubcomdatumforgedatuminternalentgeneratedSessionWhereInput(ctx context.Context, v interface{}) (*generated.SessionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSessionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx context.Context, sel ast.SelectionSet, v []*generated.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUser2githubcomdatumforgedatuminternalentgeneratedUser(ctx context.Context, sel ast.SelectionSet, v *generated.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEdge2githubcomdatumforgedatuminternalentgeneratedUserEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserEdge2githubcomdatumforgedatuminternalentgeneratedUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserEdge2githubcomdatumforgedatuminternalentgeneratedUserEdge(ctx context.Context, sel ast.SelectionSet, v *generated.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserOrder2githubcomdatumforgedatuminternalentgeneratedUserOrder(ctx context.Context, v interface{}) (*generated.UserOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserSetting2githubcomdatumforgedatuminternalentgeneratedUserSetting(ctx context.Context, sel ast.SelectionSet, v *generated.UserSetting) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserSetting(ctx, sel, v)
}

func (ec *executionContext) marshalOUserSettingEdge2githubcomdatumforgedatuminternalentgeneratedUserSettingEdge(ctx context.Context, sel ast.SelectionSet, v []*generated.UserSettingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserSettingEdge2githubcomdatumforgedatuminternalentgeneratedUserSettingEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserSettingEdge2githubcomdatumforgedatuminternalentgeneratedUserSettingEdge(ctx context.Context, sel ast.SelectionSet, v *generated.UserSettingEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserSettingEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx context.Context, v interface{}) ([]usersetting.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]usersetting.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx context.Context, sel ast.SelectionSet, v []usersetting.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx context.Context, v interface{}) (*usersetting.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(usersetting.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserSettingRole2githubcomdatumforgedatuminternalentgeneratedusersettingRole(ctx context.Context, sel ast.SelectionSet, v *usersetting.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx context.Context, v interface{}) ([]usersetting.Status, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]usersetting.Status, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx context.Context, sel ast.SelectionSet, v []usersetting.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx context.Context, v interface{}) (*usersetting.Status, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(usersetting.Status)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserSettingStatus2githubcomdatumforgedatuminternalentgeneratedusersettingStatus(ctx context.Context, sel ast.SelectionSet, v *usersetting.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx context.Context, v interface{}) ([]*generated.UserSettingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.UserSettingWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserSettingWhereInput2githubcomdatumforgedatuminternalentgeneratedUserSettingWhereInput(ctx context.Context, v interface{}) (*generated.UserSettingWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserSettingWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx context.Context, v interface{}) ([]*generated.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*generated.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2githubcomdatumforgedatuminternalentgeneratedUserWhereInput(ctx context.Context, v interface{}) (*generated.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
