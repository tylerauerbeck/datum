// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/datumforge/datum/internal/ent/generated"
	"github.com/datumforge/datum/internal/ent/generated/group"
	"github.com/datumforge/datum/internal/ent/generated/groupsettings"
	"github.com/datumforge/datum/internal/ent/generated/integration"
	"github.com/datumforge/datum/internal/ent/generated/membership"
	"github.com/datumforge/datum/internal/ent/generated/organization"
	"github.com/datumforge/datum/internal/ent/generated/session"
	"github.com/datumforge/datum/internal/ent/generated/tenant"
	"github.com/datumforge/datum/internal/ent/generated/user"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *generated.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *generated.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateGroup handles POST /groups requests.
func (h *OgentHandler) CreateGroup(ctx context.Context, req *CreateGroupReq) (CreateGroupRes, error) {
	b := h.client.Group.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetName(req.Name)
	b.SetDescription(req.Description)
	b.SetLogoURL(req.LogoURL)
	// Add all edges.
	b.SetSettingID(req.Setting)
	b.AddMembershipIDs(req.Memberships...)
	b.AddUserIDs(req.Users...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Group.Query().Where(group.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupCreate(e), nil
}

// ReadGroup handles GET /groups/{id} requests.
func (h *OgentHandler) ReadGroup(ctx context.Context, params ReadGroupParams) (ReadGroupRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupRead(e), nil
}

// UpdateGroup handles PATCH /groups/{id} requests.
func (h *OgentHandler) UpdateGroup(ctx context.Context, req *UpdateGroupReq, params UpdateGroupParams) (UpdateGroupRes, error) {
	b := h.client.Group.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.LogoURL.Get(); ok {
		b.SetLogoURL(v)
	}
	// Add all edges.
	if v, ok := req.Setting.Get(); ok {
		b.SetSettingID(v)
	}
	if req.Memberships != nil {
		b.ClearMemberships().AddMembershipIDs(req.Memberships...)
	}
	if req.Users != nil {
		b.ClearUsers().AddUserIDs(req.Users...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Group.Query().Where(group.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupUpdate(e), nil
}

// DeleteGroup handles DELETE /groups/{id} requests.
func (h *OgentHandler) DeleteGroup(ctx context.Context, params DeleteGroupParams) (DeleteGroupRes, error) {
	err := h.client.Group.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGroupNoContent), nil

}

// ListGroup handles GET /groups requests.
func (h *OgentHandler) ListGroup(ctx context.Context, params ListGroupParams) (ListGroupRes, error) {
	q := h.client.Group.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGroupLists(es)
	return (*ListGroupOKApplicationJSON)(&r), nil
}

// ReadGroupSetting handles GET /groups/{id}/setting requests.
func (h *OgentHandler) ReadGroupSetting(ctx context.Context, params ReadGroupSettingParams) (ReadGroupSettingRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QuerySetting()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupSettingRead(e), nil
}

// ListGroupMemberships handles GET /groups/{id}/memberships requests.
func (h *OgentHandler) ListGroupMemberships(ctx context.Context, params ListGroupMembershipsParams) (ListGroupMembershipsRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryMemberships()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGroupMembershipsLists(es)
	return (*ListGroupMembershipsOKApplicationJSON)(&r), nil
}

// ListGroupUsers handles GET /groups/{id}/users requests.
func (h *OgentHandler) ListGroupUsers(ctx context.Context, params ListGroupUsersParams) (ListGroupUsersRes, error) {
	q := h.client.Group.Query().Where(group.IDEQ(params.ID)).QueryUsers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGroupUsersLists(es)
	return (*ListGroupUsersOKApplicationJSON)(&r), nil
}

// CreateGroupSettings handles POST /group-settings-slice requests.
func (h *OgentHandler) CreateGroupSettings(ctx context.Context, req *CreateGroupSettingsReq) (CreateGroupSettingsRes, error) {
	b := h.client.GroupSettings.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetVisibility(groupsettings.Visibility(req.Visibility))
	b.SetJoinPolicy(groupsettings.JoinPolicy(req.JoinPolicy))
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.GroupSettings.Query().Where(groupsettings.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupSettingsCreate(e), nil
}

// ReadGroupSettings handles GET /group-settings-slice/{id} requests.
func (h *OgentHandler) ReadGroupSettings(ctx context.Context, params ReadGroupSettingsParams) (ReadGroupSettingsRes, error) {
	q := h.client.GroupSettings.Query().Where(groupsettings.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupSettingsRead(e), nil
}

// UpdateGroupSettings handles PATCH /group-settings-slice/{id} requests.
func (h *OgentHandler) UpdateGroupSettings(ctx context.Context, req *UpdateGroupSettingsReq, params UpdateGroupSettingsParams) (UpdateGroupSettingsRes, error) {
	b := h.client.GroupSettings.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Visibility.Get(); ok {
		b.SetVisibility(groupsettings.Visibility(v))
	}
	if v, ok := req.JoinPolicy.Get(); ok {
		b.SetJoinPolicy(groupsettings.JoinPolicy(v))
	}
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.GroupSettings.Query().Where(groupsettings.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGroupSettingsUpdate(e), nil
}

// DeleteGroupSettings handles DELETE /group-settings-slice/{id} requests.
func (h *OgentHandler) DeleteGroupSettings(ctx context.Context, params DeleteGroupSettingsParams) (DeleteGroupSettingsRes, error) {
	err := h.client.GroupSettings.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGroupSettingsNoContent), nil

}

// ListGroupSettings handles GET /group-settings-slice requests.
func (h *OgentHandler) ListGroupSettings(ctx context.Context, params ListGroupSettingsParams) (ListGroupSettingsRes, error) {
	q := h.client.GroupSettings.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGroupSettingsLists(es)
	return (*ListGroupSettingsOKApplicationJSON)(&r), nil
}

// ReadGroupSettingsGroup handles GET /group-settings-slice/{id}/group requests.
func (h *OgentHandler) ReadGroupSettingsGroup(ctx context.Context, params ReadGroupSettingsGroupParams) (ReadGroupSettingsGroupRes, error) {
	q := h.client.GroupSettings.Query().Where(groupsettings.IDEQ(params.ID)).QueryGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGroupSettingsGroupRead(e), nil
}

// CreateIntegration handles POST /integrations requests.
func (h *OgentHandler) CreateIntegration(ctx context.Context, req *CreateIntegrationReq) (CreateIntegrationRes, error) {
	b := h.client.Integration.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetKind(req.Kind)
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	b.SetSecretName(req.SecretName)
	// Add all edges.
	b.SetOrganizationID(req.Organization)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Integration.Query().Where(integration.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewIntegrationCreate(e), nil
}

// ReadIntegration handles GET /integrations/{id} requests.
func (h *OgentHandler) ReadIntegration(ctx context.Context, params ReadIntegrationParams) (ReadIntegrationRes, error) {
	q := h.client.Integration.Query().Where(integration.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewIntegrationRead(e), nil
}

// UpdateIntegration handles PATCH /integrations/{id} requests.
func (h *OgentHandler) UpdateIntegration(ctx context.Context, req *UpdateIntegrationReq, params UpdateIntegrationParams) (UpdateIntegrationRes, error) {
	b := h.client.Integration.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	// Add all edges.
	if v, ok := req.Organization.Get(); ok {
		b.SetOrganizationID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Integration.Query().Where(integration.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewIntegrationUpdate(e), nil
}

// DeleteIntegration handles DELETE /integrations/{id} requests.
func (h *OgentHandler) DeleteIntegration(ctx context.Context, params DeleteIntegrationParams) (DeleteIntegrationRes, error) {
	err := h.client.Integration.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteIntegrationNoContent), nil

}

// ListIntegration handles GET /integrations requests.
func (h *OgentHandler) ListIntegration(ctx context.Context, params ListIntegrationParams) (ListIntegrationRes, error) {
	q := h.client.Integration.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewIntegrationLists(es)
	return (*ListIntegrationOKApplicationJSON)(&r), nil
}

// ReadIntegrationOrganization handles GET /integrations/{id}/organization requests.
func (h *OgentHandler) ReadIntegrationOrganization(ctx context.Context, params ReadIntegrationOrganizationParams) (ReadIntegrationOrganizationRes, error) {
	q := h.client.Integration.Query().Where(integration.IDEQ(params.ID)).QueryOrganization()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewIntegrationOrganizationRead(e), nil
}

// CreateMembership handles POST /memberships requests.
func (h *OgentHandler) CreateMembership(ctx context.Context, req *CreateMembershipReq) (CreateMembershipRes, error) {
	b := h.client.Membership.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetCurrent(req.Current)
	// Add all edges.
	b.SetOrganizationID(req.Organization)
	b.SetUserID(req.User)
	b.SetGroupID(req.Group)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Membership.Query().Where(membership.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMembershipCreate(e), nil
}

// ReadMembership handles GET /memberships/{id} requests.
func (h *OgentHandler) ReadMembership(ctx context.Context, params ReadMembershipParams) (ReadMembershipRes, error) {
	q := h.client.Membership.Query().Where(membership.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMembershipRead(e), nil
}

// UpdateMembership handles PATCH /memberships/{id} requests.
func (h *OgentHandler) UpdateMembership(ctx context.Context, req *UpdateMembershipReq, params UpdateMembershipParams) (UpdateMembershipRes, error) {
	b := h.client.Membership.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Current.Get(); ok {
		b.SetCurrent(v)
	}
	// Add all edges.
	if v, ok := req.Organization.Get(); ok {
		b.SetOrganizationID(v)
	}
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Membership.Query().Where(membership.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMembershipUpdate(e), nil
}

// DeleteMembership handles DELETE /memberships/{id} requests.
func (h *OgentHandler) DeleteMembership(ctx context.Context, params DeleteMembershipParams) (DeleteMembershipRes, error) {
	err := h.client.Membership.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMembershipNoContent), nil

}

// ListMembership handles GET /memberships requests.
func (h *OgentHandler) ListMembership(ctx context.Context, params ListMembershipParams) (ListMembershipRes, error) {
	q := h.client.Membership.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMembershipLists(es)
	return (*ListMembershipOKApplicationJSON)(&r), nil
}

// ReadMembershipOrganization handles GET /memberships/{id}/organization requests.
func (h *OgentHandler) ReadMembershipOrganization(ctx context.Context, params ReadMembershipOrganizationParams) (ReadMembershipOrganizationRes, error) {
	q := h.client.Membership.Query().Where(membership.IDEQ(params.ID)).QueryOrganization()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMembershipOrganizationRead(e), nil
}

// ReadMembershipUser handles GET /memberships/{id}/user requests.
func (h *OgentHandler) ReadMembershipUser(ctx context.Context, params ReadMembershipUserParams) (ReadMembershipUserRes, error) {
	q := h.client.Membership.Query().Where(membership.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMembershipUserRead(e), nil
}

// ReadMembershipGroup handles GET /memberships/{id}/group requests.
func (h *OgentHandler) ReadMembershipGroup(ctx context.Context, params ReadMembershipGroupParams) (ReadMembershipGroupRes, error) {
	q := h.client.Membership.Query().Where(membership.IDEQ(params.ID)).QueryGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMembershipGroupRead(e), nil
}

// CreateOrganization handles POST /organizations requests.
func (h *OgentHandler) CreateOrganization(ctx context.Context, req *CreateOrganizationReq) (CreateOrganizationRes, error) {
	b := h.client.Organization.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetName(req.Name)
	// Add all edges.
	b.AddMembershipIDs(req.Memberships...)
	b.AddIntegrationIDs(req.Integrations...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Organization.Query().Where(organization.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewOrganizationCreate(e), nil
}

// ReadOrganization handles GET /organizations/{id} requests.
func (h *OgentHandler) ReadOrganization(ctx context.Context, params ReadOrganizationParams) (ReadOrganizationRes, error) {
	q := h.client.Organization.Query().Where(organization.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewOrganizationRead(e), nil
}

// UpdateOrganization handles PATCH /organizations/{id} requests.
func (h *OgentHandler) UpdateOrganization(ctx context.Context, req *UpdateOrganizationReq, params UpdateOrganizationParams) (UpdateOrganizationRes, error) {
	b := h.client.Organization.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if req.Memberships != nil {
		b.ClearMemberships().AddMembershipIDs(req.Memberships...)
	}
	if req.Integrations != nil {
		b.ClearIntegrations().AddIntegrationIDs(req.Integrations...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Organization.Query().Where(organization.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewOrganizationUpdate(e), nil
}

// DeleteOrganization handles DELETE /organizations/{id} requests.
func (h *OgentHandler) DeleteOrganization(ctx context.Context, params DeleteOrganizationParams) (DeleteOrganizationRes, error) {
	err := h.client.Organization.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteOrganizationNoContent), nil

}

// ListOrganization handles GET /organizations requests.
func (h *OgentHandler) ListOrganization(ctx context.Context, params ListOrganizationParams) (ListOrganizationRes, error) {
	q := h.client.Organization.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewOrganizationLists(es)
	return (*ListOrganizationOKApplicationJSON)(&r), nil
}

// ListOrganizationMemberships handles GET /organizations/{id}/memberships requests.
func (h *OgentHandler) ListOrganizationMemberships(ctx context.Context, params ListOrganizationMembershipsParams) (ListOrganizationMembershipsRes, error) {
	q := h.client.Organization.Query().Where(organization.IDEQ(params.ID)).QueryMemberships()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewOrganizationMembershipsLists(es)
	return (*ListOrganizationMembershipsOKApplicationJSON)(&r), nil
}

// ListOrganizationIntegrations handles GET /organizations/{id}/integrations requests.
func (h *OgentHandler) ListOrganizationIntegrations(ctx context.Context, params ListOrganizationIntegrationsParams) (ListOrganizationIntegrationsRes, error) {
	q := h.client.Organization.Query().Where(organization.IDEQ(params.ID)).QueryIntegrations()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewOrganizationIntegrationsLists(es)
	return (*ListOrganizationIntegrationsOKApplicationJSON)(&r), nil
}

// CreateSession handles POST /sessions requests.
func (h *OgentHandler) CreateSession(ctx context.Context, req *CreateSessionReq) (CreateSessionRes, error) {
	b := h.client.Session.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetType(session.Type(req.Type))
	b.SetDisabled(req.Disabled)
	b.SetToken(req.Token)
	if v, ok := req.UserAgent.Get(); ok {
		b.SetUserAgent(v)
	}
	b.SetIps(req.Ips)
	// Add all edges.
	if v, ok := req.Users.Get(); ok {
		b.SetUsersID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Session.Query().Where(session.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewSessionCreate(e), nil
}

// ReadSession handles GET /sessions/{id} requests.
func (h *OgentHandler) ReadSession(ctx context.Context, params ReadSessionParams) (ReadSessionRes, error) {
	q := h.client.Session.Query().Where(session.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewSessionRead(e), nil
}

// UpdateSession handles PATCH /sessions/{id} requests.
func (h *OgentHandler) UpdateSession(ctx context.Context, req *UpdateSessionReq, params UpdateSessionParams) (UpdateSessionRes, error) {
	b := h.client.Session.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Disabled.Get(); ok {
		b.SetDisabled(v)
	}
	if v, ok := req.UserAgent.Get(); ok {
		b.SetUserAgent(v)
	}
	if v, ok := req.Ips.Get(); ok {
		b.SetIps(v)
	}
	// Add all edges.
	if v, ok := req.Users.Get(); ok {
		b.SetUsersID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Session.Query().Where(session.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewSessionUpdate(e), nil
}

// DeleteSession handles DELETE /sessions/{id} requests.
func (h *OgentHandler) DeleteSession(ctx context.Context, params DeleteSessionParams) (DeleteSessionRes, error) {
	err := h.client.Session.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteSessionNoContent), nil

}

// ListSession handles GET /sessions requests.
func (h *OgentHandler) ListSession(ctx context.Context, params ListSessionParams) (ListSessionRes, error) {
	q := h.client.Session.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewSessionLists(es)
	return (*ListSessionOKApplicationJSON)(&r), nil
}

// ReadSessionUsers handles GET /sessions/{id}/users requests.
func (h *OgentHandler) ReadSessionUsers(ctx context.Context, params ReadSessionUsersParams) (ReadSessionUsersRes, error) {
	q := h.client.Session.Query().Where(session.IDEQ(params.ID)).QueryUsers()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewSessionUsersRead(e), nil
}

// CreateTenant handles POST /tenants requests.
func (h *OgentHandler) CreateTenant(ctx context.Context, req *CreateTenantReq) (CreateTenantRes, error) {
	b := h.client.Tenant.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Tenant.Query().Where(tenant.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTenantCreate(e), nil
}

// ReadTenant handles GET /tenants/{id} requests.
func (h *OgentHandler) ReadTenant(ctx context.Context, params ReadTenantParams) (ReadTenantRes, error) {
	q := h.client.Tenant.Query().Where(tenant.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTenantRead(e), nil
}

// UpdateTenant handles PATCH /tenants/{id} requests.
func (h *OgentHandler) UpdateTenant(ctx context.Context, req *UpdateTenantReq, params UpdateTenantParams) (UpdateTenantRes, error) {
	b := h.client.Tenant.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Tenant.Query().Where(tenant.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTenantUpdate(e), nil
}

// DeleteTenant handles DELETE /tenants/{id} requests.
func (h *OgentHandler) DeleteTenant(ctx context.Context, params DeleteTenantParams) (DeleteTenantRes, error) {
	err := h.client.Tenant.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTenantNoContent), nil

}

// ListTenant handles GET /tenants requests.
func (h *OgentHandler) ListTenant(ctx context.Context, params ListTenantParams) (ListTenantRes, error) {
	q := h.client.Tenant.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTenantLists(es)
	return (*ListTenantOKApplicationJSON)(&r), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req *CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetCreatedAt(req.CreatedAt)
	b.SetUpdatedAt(req.UpdatedAt)
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	b.SetEmail(req.Email)
	b.SetFirstName(req.FirstName)
	b.SetLastName(req.LastName)
	b.SetDisplayName(req.DisplayName)
	b.SetLocked(req.Locked)
	if v, ok := req.AvatarRemoteURL.Get(); ok {
		b.SetAvatarRemoteURL(v)
	}
	if v, ok := req.AvatarLocalFile.Get(); ok {
		b.SetAvatarLocalFile(v)
	}
	if v, ok := req.AvatarUpdatedAt.Get(); ok {
		b.SetAvatarUpdatedAt(v)
	}
	if v, ok := req.SilencedAt.Get(); ok {
		b.SetSilencedAt(v)
	}
	if v, ok := req.SuspendedAt.Get(); ok {
		b.SetSuspendedAt(v)
	}
	if v, ok := req.RecoveryCode.Get(); ok {
		b.SetRecoveryCode(v)
	}
	// Add all edges.
	b.AddMembershipIDs(req.Memberships...)
	b.AddSessionIDs(req.Sessions...)
	b.AddGroupIDs(req.Groups...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req *UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdatedAt.Get(); ok {
		b.SetUpdatedAt(v)
	}
	if v, ok := req.CreatedBy.Get(); ok {
		b.SetCreatedBy(v)
	}
	if v, ok := req.UpdatedBy.Get(); ok {
		b.SetUpdatedBy(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.FirstName.Get(); ok {
		b.SetFirstName(v)
	}
	if v, ok := req.LastName.Get(); ok {
		b.SetLastName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Locked.Get(); ok {
		b.SetLocked(v)
	}
	if v, ok := req.AvatarRemoteURL.Get(); ok {
		b.SetAvatarRemoteURL(v)
	}
	if v, ok := req.AvatarLocalFile.Get(); ok {
		b.SetAvatarLocalFile(v)
	}
	if v, ok := req.AvatarUpdatedAt.Get(); ok {
		b.SetAvatarUpdatedAt(v)
	}
	if v, ok := req.SilencedAt.Get(); ok {
		b.SetSilencedAt(v)
	}
	if v, ok := req.SuspendedAt.Get(); ok {
		b.SetSuspendedAt(v)
	}
	if v, ok := req.RecoveryCode.Get(); ok {
		b.SetRecoveryCode(v)
	}
	// Add all edges.
	if req.Memberships != nil {
		b.ClearMemberships().AddMembershipIDs(req.Memberships...)
	}
	if req.Sessions != nil {
		b.ClearSessions().AddSessionIDs(req.Sessions...)
	}
	if req.Groups != nil {
		b.ClearGroups().AddGroupIDs(req.Groups...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserMemberships handles GET /users/{id}/memberships requests.
func (h *OgentHandler) ListUserMemberships(ctx context.Context, params ListUserMembershipsParams) (ListUserMembershipsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryMemberships()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserMembershipsLists(es)
	return (*ListUserMembershipsOKApplicationJSON)(&r), nil
}

// ListUserSessions handles GET /users/{id}/sessions requests.
func (h *OgentHandler) ListUserSessions(ctx context.Context, params ListUserSessionsParams) (ListUserSessionsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QuerySessions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserSessionsLists(es)
	return (*ListUserSessionsOKApplicationJSON)(&r), nil
}

// ListUserGroups handles GET /users/{id}/groups requests.
func (h *OgentHandler) ListUserGroups(ctx context.Context, params ListUserGroupsParams) (ListUserGroupsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case generated.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case generated.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserGroupsLists(es)
	return (*ListUserGroupsOKApplicationJSON)(&r), nil
}
