// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/datumforge/datum/internal/ent/generated"

func NewGroupCreate(e *generated.Group) *GroupCreate {
	if e == nil {
		return nil
	}
	var ret GroupCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupCreates(es []*generated.Group) []GroupCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupCreate, len(es))
	for i, e := range es {
		r[i] = NewGroupCreate(e).Elem()
	}
	return r
}

func (gr *GroupCreate) Elem() GroupCreate {
	if gr == nil {
		return GroupCreate{}
	}
	return *gr
}

func NewGroupList(e *generated.Group) *GroupList {
	if e == nil {
		return nil
	}
	var ret GroupList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupLists(es []*generated.Group) []GroupList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupList, len(es))
	for i, e := range es {
		r[i] = NewGroupList(e).Elem()
	}
	return r
}

func (gr *GroupList) Elem() GroupList {
	if gr == nil {
		return GroupList{}
	}
	return *gr
}

func NewGroupRead(e *generated.Group) *GroupRead {
	if e == nil {
		return nil
	}
	var ret GroupRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupReads(es []*generated.Group) []GroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupRead, len(es))
	for i, e := range es {
		r[i] = NewGroupRead(e).Elem()
	}
	return r
}

func (gr *GroupRead) Elem() GroupRead {
	if gr == nil {
		return GroupRead{}
	}
	return *gr
}

func NewGroupSettingsCreate(e *generated.GroupSettings) *GroupSettingsCreate {
	if e == nil {
		return nil
	}
	var ret GroupSettingsCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Visibility = GroupSettingsCreateVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsCreateJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsCreates(es []*generated.GroupSettings) []GroupSettingsCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsCreate, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsCreate(e).Elem()
	}
	return r
}

func (gs *GroupSettingsCreate) Elem() GroupSettingsCreate {
	if gs == nil {
		return GroupSettingsCreate{}
	}
	return *gs
}

func NewGroupSettingsList(e *generated.GroupSettings) *GroupSettingsList {
	if e == nil {
		return nil
	}
	var ret GroupSettingsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Visibility = GroupSettingsListVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsListJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsLists(es []*generated.GroupSettings) []GroupSettingsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsList, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsList(e).Elem()
	}
	return r
}

func (gs *GroupSettingsList) Elem() GroupSettingsList {
	if gs == nil {
		return GroupSettingsList{}
	}
	return *gs
}

func NewGroupSettingsRead(e *generated.GroupSettings) *GroupSettingsRead {
	if e == nil {
		return nil
	}
	var ret GroupSettingsRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Visibility = GroupSettingsReadVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsReadJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsReads(es []*generated.GroupSettings) []GroupSettingsRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsRead, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsRead(e).Elem()
	}
	return r
}

func (gs *GroupSettingsRead) Elem() GroupSettingsRead {
	if gs == nil {
		return GroupSettingsRead{}
	}
	return *gs
}

func NewGroupSettingsUpdate(e *generated.GroupSettings) *GroupSettingsUpdate {
	if e == nil {
		return nil
	}
	var ret GroupSettingsUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Visibility = GroupSettingsUpdateVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingsUpdateJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingsUpdates(es []*generated.GroupSettings) []GroupSettingsUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsUpdate, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsUpdate(e).Elem()
	}
	return r
}

func (gs *GroupSettingsUpdate) Elem() GroupSettingsUpdate {
	if gs == nil {
		return GroupSettingsUpdate{}
	}
	return *gs
}

func NewGroupSettingsGroupRead(e *generated.Group) *GroupSettingsGroupRead {
	if e == nil {
		return nil
	}
	var ret GroupSettingsGroupRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupSettingsGroupReads(es []*generated.Group) []GroupSettingsGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingsGroupRead, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingsGroupRead(e).Elem()
	}
	return r
}

func (gr *GroupSettingsGroupRead) Elem() GroupSettingsGroupRead {
	if gr == nil {
		return GroupSettingsGroupRead{}
	}
	return *gr
}

func NewGroupUpdate(e *generated.Group) *GroupUpdate {
	if e == nil {
		return nil
	}
	var ret GroupUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewGroupUpdates(es []*generated.Group) []GroupUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupUpdate, len(es))
	for i, e := range es {
		r[i] = NewGroupUpdate(e).Elem()
	}
	return r
}

func (gr *GroupUpdate) Elem() GroupUpdate {
	if gr == nil {
		return GroupUpdate{}
	}
	return *gr
}

func NewGroupOwnerRead(e *generated.Organization) *GroupOwnerRead {
	if e == nil {
		return nil
	}
	var ret GroupOwnerRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewGroupOwnerReads(es []*generated.Organization) []GroupOwnerRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupOwnerRead, len(es))
	for i, e := range es {
		r[i] = NewGroupOwnerRead(e).Elem()
	}
	return r
}

func (o *GroupOwnerRead) Elem() GroupOwnerRead {
	if o == nil {
		return GroupOwnerRead{}
	}
	return *o
}

func NewGroupSettingRead(e *generated.GroupSettings) *GroupSettingRead {
	if e == nil {
		return nil
	}
	var ret GroupSettingRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Visibility = GroupSettingReadVisibility(e.Visibility)
	ret.JoinPolicy = GroupSettingReadJoinPolicy(e.JoinPolicy)
	return &ret
}

func NewGroupSettingReads(es []*generated.GroupSettings) []GroupSettingRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupSettingRead, len(es))
	for i, e := range es {
		r[i] = NewGroupSettingRead(e).Elem()
	}
	return r
}

func (gs *GroupSettingRead) Elem() GroupSettingRead {
	if gs == nil {
		return GroupSettingRead{}
	}
	return *gs
}

func NewGroupUsersList(e *generated.User) *GroupUsersList {
	if e == nil {
		return nil
	}
	var ret GroupUsersList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewGroupUsersLists(es []*generated.User) []GroupUsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]GroupUsersList, len(es))
	for i, e := range es {
		r[i] = NewGroupUsersList(e).Elem()
	}
	return r
}

func (u *GroupUsersList) Elem() GroupUsersList {
	if u == nil {
		return GroupUsersList{}
	}
	return *u
}

func NewIntegrationCreate(e *generated.Integration) *IntegrationCreate {
	if e == nil {
		return nil
	}
	var ret IntegrationCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationCreates(es []*generated.Integration) []IntegrationCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationCreate, len(es))
	for i, e := range es {
		r[i] = NewIntegrationCreate(e).Elem()
	}
	return r
}

func (i *IntegrationCreate) Elem() IntegrationCreate {
	if i == nil {
		return IntegrationCreate{}
	}
	return *i
}

func NewIntegrationList(e *generated.Integration) *IntegrationList {
	if e == nil {
		return nil
	}
	var ret IntegrationList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationLists(es []*generated.Integration) []IntegrationList {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationList, len(es))
	for i, e := range es {
		r[i] = NewIntegrationList(e).Elem()
	}
	return r
}

func (i *IntegrationList) Elem() IntegrationList {
	if i == nil {
		return IntegrationList{}
	}
	return *i
}

func NewIntegrationRead(e *generated.Integration) *IntegrationRead {
	if e == nil {
		return nil
	}
	var ret IntegrationRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationReads(es []*generated.Integration) []IntegrationRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationRead, len(es))
	for i, e := range es {
		r[i] = NewIntegrationRead(e).Elem()
	}
	return r
}

func (i *IntegrationRead) Elem() IntegrationRead {
	if i == nil {
		return IntegrationRead{}
	}
	return *i
}

func NewIntegrationUpdate(e *generated.Integration) *IntegrationUpdate {
	if e == nil {
		return nil
	}
	var ret IntegrationUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewIntegrationUpdates(es []*generated.Integration) []IntegrationUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationUpdate, len(es))
	for i, e := range es {
		r[i] = NewIntegrationUpdate(e).Elem()
	}
	return r
}

func (i *IntegrationUpdate) Elem() IntegrationUpdate {
	if i == nil {
		return IntegrationUpdate{}
	}
	return *i
}

func NewIntegrationOwnerRead(e *generated.Organization) *IntegrationOwnerRead {
	if e == nil {
		return nil
	}
	var ret IntegrationOwnerRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewIntegrationOwnerReads(es []*generated.Organization) []IntegrationOwnerRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntegrationOwnerRead, len(es))
	for i, e := range es {
		r[i] = NewIntegrationOwnerRead(e).Elem()
	}
	return r
}

func (o *IntegrationOwnerRead) Elem() IntegrationOwnerRead {
	if o == nil {
		return IntegrationOwnerRead{}
	}
	return *o
}

func NewOrganizationCreate(e *generated.Organization) *OrganizationCreate {
	if e == nil {
		return nil
	}
	var ret OrganizationCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewOrganizationCreates(es []*generated.Organization) []OrganizationCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationCreate, len(es))
	for i, e := range es {
		r[i] = NewOrganizationCreate(e).Elem()
	}
	return r
}

func (o *OrganizationCreate) Elem() OrganizationCreate {
	if o == nil {
		return OrganizationCreate{}
	}
	return *o
}

func NewOrganizationList(e *generated.Organization) *OrganizationList {
	if e == nil {
		return nil
	}
	var ret OrganizationList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewOrganizationLists(es []*generated.Organization) []OrganizationList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationList(e).Elem()
	}
	return r
}

func (o *OrganizationList) Elem() OrganizationList {
	if o == nil {
		return OrganizationList{}
	}
	return *o
}

func NewOrganizationRead(e *generated.Organization) *OrganizationRead {
	if e == nil {
		return nil
	}
	var ret OrganizationRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewOrganizationReads(es []*generated.Organization) []OrganizationRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationRead, len(es))
	for i, e := range es {
		r[i] = NewOrganizationRead(e).Elem()
	}
	return r
}

func (o *OrganizationRead) Elem() OrganizationRead {
	if o == nil {
		return OrganizationRead{}
	}
	return *o
}

func NewOrganizationUpdate(e *generated.Organization) *OrganizationUpdate {
	if e == nil {
		return nil
	}
	var ret OrganizationUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewOrganizationUpdates(es []*generated.Organization) []OrganizationUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationUpdate, len(es))
	for i, e := range es {
		r[i] = NewOrganizationUpdate(e).Elem()
	}
	return r
}

func (o *OrganizationUpdate) Elem() OrganizationUpdate {
	if o == nil {
		return OrganizationUpdate{}
	}
	return *o
}

func NewOrganizationChildrenList(e *generated.Organization) *OrganizationChildrenList {
	if e == nil {
		return nil
	}
	var ret OrganizationChildrenList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewOrganizationChildrenLists(es []*generated.Organization) []OrganizationChildrenList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationChildrenList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationChildrenList(e).Elem()
	}
	return r
}

func (o *OrganizationChildrenList) Elem() OrganizationChildrenList {
	if o == nil {
		return OrganizationChildrenList{}
	}
	return *o
}

func NewOrganizationGroupsList(e *generated.Group) *OrganizationGroupsList {
	if e == nil {
		return nil
	}
	var ret OrganizationGroupsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewOrganizationGroupsLists(es []*generated.Group) []OrganizationGroupsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationGroupsList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationGroupsList(e).Elem()
	}
	return r
}

func (gr *OrganizationGroupsList) Elem() OrganizationGroupsList {
	if gr == nil {
		return OrganizationGroupsList{}
	}
	return *gr
}

func NewOrganizationIntegrationsList(e *generated.Integration) *OrganizationIntegrationsList {
	if e == nil {
		return nil
	}
	var ret OrganizationIntegrationsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Kind = e.Kind
	ret.Description = NewOptString(e.Description)
	ret.SecretName = e.SecretName
	return &ret
}

func NewOrganizationIntegrationsLists(es []*generated.Integration) []OrganizationIntegrationsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationIntegrationsList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationIntegrationsList(e).Elem()
	}
	return r
}

func (i *OrganizationIntegrationsList) Elem() OrganizationIntegrationsList {
	if i == nil {
		return OrganizationIntegrationsList{}
	}
	return *i
}

func NewOrganizationParentRead(e *generated.Organization) *OrganizationParentRead {
	if e == nil {
		return nil
	}
	var ret OrganizationParentRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewOrganizationParentReads(es []*generated.Organization) []OrganizationParentRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationParentRead, len(es))
	for i, e := range es {
		r[i] = NewOrganizationParentRead(e).Elem()
	}
	return r
}

func (o *OrganizationParentRead) Elem() OrganizationParentRead {
	if o == nil {
		return OrganizationParentRead{}
	}
	return *o
}

func NewOrganizationUsersList(e *generated.User) *OrganizationUsersList {
	if e == nil {
		return nil
	}
	var ret OrganizationUsersList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewOrganizationUsersLists(es []*generated.User) []OrganizationUsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]OrganizationUsersList, len(es))
	for i, e := range es {
		r[i] = NewOrganizationUsersList(e).Elem()
	}
	return r
}

func (u *OrganizationUsersList) Elem() OrganizationUsersList {
	if u == nil {
		return OrganizationUsersList{}
	}
	return *u
}

func NewSessionCreate(e *generated.Session) *SessionCreate {
	if e == nil {
		return nil
	}
	var ret SessionCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Type = SessionCreateType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionCreates(es []*generated.Session) []SessionCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionCreate, len(es))
	for i, e := range es {
		r[i] = NewSessionCreate(e).Elem()
	}
	return r
}

func (s *SessionCreate) Elem() SessionCreate {
	if s == nil {
		return SessionCreate{}
	}
	return *s
}

func NewSessionList(e *generated.Session) *SessionList {
	if e == nil {
		return nil
	}
	var ret SessionList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Type = SessionListType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionLists(es []*generated.Session) []SessionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionList, len(es))
	for i, e := range es {
		r[i] = NewSessionList(e).Elem()
	}
	return r
}

func (s *SessionList) Elem() SessionList {
	if s == nil {
		return SessionList{}
	}
	return *s
}

func NewSessionRead(e *generated.Session) *SessionRead {
	if e == nil {
		return nil
	}
	var ret SessionRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Type = SessionReadType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionReads(es []*generated.Session) []SessionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionRead, len(es))
	for i, e := range es {
		r[i] = NewSessionRead(e).Elem()
	}
	return r
}

func (s *SessionRead) Elem() SessionRead {
	if s == nil {
		return SessionRead{}
	}
	return *s
}

func NewSessionUpdate(e *generated.Session) *SessionUpdate {
	if e == nil {
		return nil
	}
	var ret SessionUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Type = SessionUpdateType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewSessionUpdates(es []*generated.Session) []SessionUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionUpdate, len(es))
	for i, e := range es {
		r[i] = NewSessionUpdate(e).Elem()
	}
	return r
}

func (s *SessionUpdate) Elem() SessionUpdate {
	if s == nil {
		return SessionUpdate{}
	}
	return *s
}

func NewSessionUsersRead(e *generated.User) *SessionUsersRead {
	if e == nil {
		return nil
	}
	var ret SessionUsersRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewSessionUsersReads(es []*generated.User) []SessionUsersRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SessionUsersRead, len(es))
	for i, e := range es {
		r[i] = NewSessionUsersRead(e).Elem()
	}
	return r
}

func (u *SessionUsersRead) Elem() SessionUsersRead {
	if u == nil {
		return SessionUsersRead{}
	}
	return *u
}

func NewUserCreate(e *generated.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserCreates(es []*generated.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *generated.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserLists(es []*generated.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *generated.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserReads(es []*generated.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *generated.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Email = e.Email
	ret.FirstName = e.FirstName
	ret.LastName = e.LastName
	ret.DisplayName = e.DisplayName
	ret.Locked = e.Locked
	ret.AvatarRemoteURL = OptString{}
	if e.AvatarRemoteURL != nil {
		ret.AvatarRemoteURL.SetTo(*e.AvatarRemoteURL)
	}
	ret.AvatarLocalFile = OptString{}
	if e.AvatarLocalFile != nil {
		ret.AvatarLocalFile.SetTo(*e.AvatarLocalFile)
	}
	ret.AvatarUpdatedAt = OptDateTime{}
	if e.AvatarUpdatedAt != nil {
		ret.AvatarUpdatedAt.SetTo(*e.AvatarUpdatedAt)
	}
	ret.SilencedAt = OptDateTime{}
	if e.SilencedAt != nil {
		ret.SilencedAt.SetTo(*e.SilencedAt)
	}
	ret.SuspendedAt = OptDateTime{}
	if e.SuspendedAt != nil {
		ret.SuspendedAt.SetTo(*e.SuspendedAt)
	}
	return &ret
}

func NewUserUpdates(es []*generated.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}

func NewUserGroupsList(e *generated.Group) *UserGroupsList {
	if e == nil {
		return nil
	}
	var ret UserGroupsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = e.Description
	ret.LogoURL = e.LogoURL
	return &ret
}

func NewUserGroupsLists(es []*generated.Group) []UserGroupsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserGroupsList, len(es))
	for i, e := range es {
		r[i] = NewUserGroupsList(e).Elem()
	}
	return r
}

func (gr *UserGroupsList) Elem() UserGroupsList {
	if gr == nil {
		return UserGroupsList{}
	}
	return *gr
}

func NewUserOrganizationsList(e *generated.Organization) *UserOrganizationsList {
	if e == nil {
		return nil
	}
	var ret UserOrganizationsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Name = e.Name
	ret.Description = NewOptString(e.Description)
	ret.ParentOrganizationID = NewOptString(e.ParentOrganizationID)
	return &ret
}

func NewUserOrganizationsLists(es []*generated.Organization) []UserOrganizationsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserOrganizationsList, len(es))
	for i, e := range es {
		r[i] = NewUserOrganizationsList(e).Elem()
	}
	return r
}

func (o *UserOrganizationsList) Elem() UserOrganizationsList {
	if o == nil {
		return UserOrganizationsList{}
	}
	return *o
}

func NewUserSessionsList(e *generated.Session) *UserSessionsList {
	if e == nil {
		return nil
	}
	var ret UserSessionsList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	ret.UpdatedAt = e.UpdatedAt
	ret.CreatedBy = NewOptString(e.CreatedBy)
	ret.UpdatedBy = NewOptString(e.UpdatedBy)
	ret.Type = UserSessionsListType(e.Type)
	ret.Disabled = e.Disabled
	ret.Token = e.Token
	ret.UserAgent = NewOptString(e.UserAgent)
	ret.Ips = e.Ips
	return &ret
}

func NewUserSessionsLists(es []*generated.Session) []UserSessionsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserSessionsList, len(es))
	for i, e := range es {
		r[i] = NewUserSessionsList(e).Elem()
	}
	return r
}

func (s *UserSessionsList) Elem() UserSessionsList {
	if s == nil {
		return UserSessionsList{}
	}
	return *s
}
