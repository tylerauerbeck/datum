// Code generated by ent, DO NOT EDIT.

package generated

import (
	"errors"
	"fmt"
	"time"

	"github.com/datumforge/datum/internal/ent/generated/group"
	"github.com/datumforge/datum/internal/ent/generated/groupsettings"
	"github.com/datumforge/datum/internal/ent/generated/integration"
	"github.com/datumforge/datum/internal/ent/generated/organization"
	"github.com/datumforge/datum/internal/ent/generated/organizationsettings"
	"github.com/datumforge/datum/internal/ent/generated/personalaccesstoken"
	"github.com/datumforge/datum/internal/ent/generated/predicate"
	"github.com/datumforge/datum/internal/ent/generated/refreshtoken"
	"github.com/datumforge/datum/internal/ent/generated/session"
	"github.com/datumforge/datum/internal/ent/generated/user"
)

// GroupWhereInput represents a where input for filtering Group queries.
type GroupWhereInput struct {
	Predicates []predicate.Group  `json:"-"`
	Not        *GroupWhereInput   `json:"not,omitempty"`
	Or         []*GroupWhereInput `json:"or,omitempty"`
	And        []*GroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "setting" edge predicates.
	HasSetting     *bool                      `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingsWhereInput `json:"hasSettingWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupWhereInput) AddPredicates(predicates ...predicate.Group) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupWhereInput filter on the GroupQuery builder.
func (i *GroupWhereInput) Filter(q *GroupQuery) (*GroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupWhereInput is returned in case the GroupWhereInput is empty.
var ErrEmptyGroupWhereInput = errors.New("generated: empty predicate GroupWhereInput")

// P returns a predicate for filtering groups.
// An error is returned if the input is empty or invalid.
func (i *GroupWhereInput) P() (predicate.Group, error) {
	var predicates []predicate.Group
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, group.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Group, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, group.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Group, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, group.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, group.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, group.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, group.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, group.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, group.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, group.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, group.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, group.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, group.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, group.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, group.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, group.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, group.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, group.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, group.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, group.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, group.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, group.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, group.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, group.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, group.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, group.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, group.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, group.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, group.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, group.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, group.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, group.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, group.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, group.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, group.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, group.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, group.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, group.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, group.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, group.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, group.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, group.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, group.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, group.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, group.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, group.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, group.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, group.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, group.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, group.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, group.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, group.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, group.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, group.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, group.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, group.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, group.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, group.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, group.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, group.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, group.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, group.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, group.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, group.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, group.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, group.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, group.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, group.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, group.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, group.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, group.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, group.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, group.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasSetting != nil {
		p := group.HasSetting()
		if !*i.HasSetting {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettingWith) > 0 {
		with := make([]predicate.GroupSettings, 0, len(i.HasSettingWith))
		for _, w := range i.HasSettingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasSettingWith(with...))
	}
	if i.HasUsers != nil {
		p := group.HasUsers()
		if !*i.HasUsers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasUsersWith(with...))
	}
	if i.HasOwner != nil {
		p := group.HasOwner()
		if !*i.HasOwner {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return group.And(predicates...), nil
	}
}

// GroupSettingsWhereInput represents a where input for filtering GroupSettings queries.
type GroupSettingsWhereInput struct {
	Predicates []predicate.GroupSettings  `json:"-"`
	Not        *GroupSettingsWhereInput   `json:"not,omitempty"`
	Or         []*GroupSettingsWhereInput `json:"or,omitempty"`
	And        []*GroupSettingsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "visibility" field predicates.
	Visibility      *groupsettings.Visibility  `json:"visibility,omitempty"`
	VisibilityNEQ   *groupsettings.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []groupsettings.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []groupsettings.Visibility `json:"visibilityNotIn,omitempty"`

	// "join_policy" field predicates.
	JoinPolicy      *groupsettings.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNEQ   *groupsettings.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []groupsettings.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []groupsettings.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GroupSettingsWhereInput) AddPredicates(predicates ...predicate.GroupSettings) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GroupSettingsWhereInput filter on the GroupSettingsQuery builder.
func (i *GroupSettingsWhereInput) Filter(q *GroupSettingsQuery) (*GroupSettingsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGroupSettingsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGroupSettingsWhereInput is returned in case the GroupSettingsWhereInput is empty.
var ErrEmptyGroupSettingsWhereInput = errors.New("generated: empty predicate GroupSettingsWhereInput")

// P returns a predicate for filtering groupsettingsslice.
// An error is returned if the input is empty or invalid.
func (i *GroupSettingsWhereInput) P() (predicate.GroupSettings, error) {
	var predicates []predicate.GroupSettings
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, groupsettings.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GroupSettings, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, groupsettings.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GroupSettings, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, groupsettings.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, groupsettings.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, groupsettings.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, groupsettings.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, groupsettings.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, groupsettings.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, groupsettings.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, groupsettings.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, groupsettings.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, groupsettings.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, groupsettings.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, groupsettings.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, groupsettings.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, groupsettings.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, groupsettings.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, groupsettings.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, groupsettings.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, groupsettings.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, groupsettings.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, groupsettings.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, groupsettings.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, groupsettings.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, groupsettings.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, groupsettings.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, groupsettings.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, groupsettings.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, groupsettings.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, groupsettings.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, groupsettings.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, groupsettings.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, groupsettings.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, groupsettings.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, groupsettings.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, groupsettings.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, groupsettings.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, groupsettings.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, groupsettings.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, groupsettings.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, groupsettings.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, groupsettings.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, groupsettings.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, groupsettings.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, groupsettings.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, groupsettings.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, groupsettings.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, groupsettings.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, groupsettings.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, groupsettings.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, groupsettings.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, groupsettings.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, groupsettings.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, groupsettings.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, groupsettings.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, groupsettings.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, groupsettings.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, groupsettings.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, groupsettings.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Visibility != nil {
		predicates = append(predicates, groupsettings.VisibilityEQ(*i.Visibility))
	}
	if i.VisibilityNEQ != nil {
		predicates = append(predicates, groupsettings.VisibilityNEQ(*i.VisibilityNEQ))
	}
	if len(i.VisibilityIn) > 0 {
		predicates = append(predicates, groupsettings.VisibilityIn(i.VisibilityIn...))
	}
	if len(i.VisibilityNotIn) > 0 {
		predicates = append(predicates, groupsettings.VisibilityNotIn(i.VisibilityNotIn...))
	}
	if i.JoinPolicy != nil {
		predicates = append(predicates, groupsettings.JoinPolicyEQ(*i.JoinPolicy))
	}
	if i.JoinPolicyNEQ != nil {
		predicates = append(predicates, groupsettings.JoinPolicyNEQ(*i.JoinPolicyNEQ))
	}
	if len(i.JoinPolicyIn) > 0 {
		predicates = append(predicates, groupsettings.JoinPolicyIn(i.JoinPolicyIn...))
	}
	if len(i.JoinPolicyNotIn) > 0 {
		predicates = append(predicates, groupsettings.JoinPolicyNotIn(i.JoinPolicyNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGroupSettingsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return groupsettings.And(predicates...), nil
	}
}

// IntegrationWhereInput represents a where input for filtering Integration queries.
type IntegrationWhereInput struct {
	Predicates []predicate.Integration  `json:"-"`
	Not        *IntegrationWhereInput   `json:"not,omitempty"`
	Or         []*IntegrationWhereInput `json:"or,omitempty"`
	And        []*IntegrationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind             *string  `json:"kind,omitempty"`
	KindNEQ          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGT           *string  `json:"kindGT,omitempty"`
	KindGTE          *string  `json:"kindGTE,omitempty"`
	KindLT           *string  `json:"kindLT,omitempty"`
	KindLTE          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "secret_name" field predicates.
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNEQ          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGT           *string  `json:"secretNameGT,omitempty"`
	SecretNameGTE          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLT           *string  `json:"secretNameLT,omitempty"`
	SecretNameLTE          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IntegrationWhereInput) AddPredicates(predicates ...predicate.Integration) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IntegrationWhereInput filter on the IntegrationQuery builder.
func (i *IntegrationWhereInput) Filter(q *IntegrationQuery) (*IntegrationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyIntegrationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyIntegrationWhereInput is returned in case the IntegrationWhereInput is empty.
var ErrEmptyIntegrationWhereInput = errors.New("generated: empty predicate IntegrationWhereInput")

// P returns a predicate for filtering integrations.
// An error is returned if the input is empty or invalid.
func (i *IntegrationWhereInput) P() (predicate.Integration, error) {
	var predicates []predicate.Integration
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, integration.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Integration, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, integration.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Integration, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, integration.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, integration.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, integration.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, integration.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, integration.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, integration.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, integration.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, integration.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, integration.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, integration.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, integration.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, integration.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, integration.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, integration.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, integration.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, integration.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, integration.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, integration.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, integration.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, integration.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, integration.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, integration.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, integration.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, integration.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, integration.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, integration.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, integration.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, integration.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, integration.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, integration.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, integration.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, integration.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, integration.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, integration.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, integration.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, integration.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, integration.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, integration.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, integration.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, integration.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, integration.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, integration.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, integration.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, integration.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, integration.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, integration.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, integration.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, integration.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, integration.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, integration.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, integration.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, integration.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, integration.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, integration.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, integration.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, integration.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, integration.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, integration.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, integration.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, integration.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, integration.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, integration.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, integration.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, integration.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, integration.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, integration.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, integration.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, integration.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, integration.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, integration.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, integration.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, integration.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, integration.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, integration.KindNotIn(i.KindNotIn...))
	}
	if i.KindGT != nil {
		predicates = append(predicates, integration.KindGT(*i.KindGT))
	}
	if i.KindGTE != nil {
		predicates = append(predicates, integration.KindGTE(*i.KindGTE))
	}
	if i.KindLT != nil {
		predicates = append(predicates, integration.KindLT(*i.KindLT))
	}
	if i.KindLTE != nil {
		predicates = append(predicates, integration.KindLTE(*i.KindLTE))
	}
	if i.KindContains != nil {
		predicates = append(predicates, integration.KindContains(*i.KindContains))
	}
	if i.KindHasPrefix != nil {
		predicates = append(predicates, integration.KindHasPrefix(*i.KindHasPrefix))
	}
	if i.KindHasSuffix != nil {
		predicates = append(predicates, integration.KindHasSuffix(*i.KindHasSuffix))
	}
	if i.KindEqualFold != nil {
		predicates = append(predicates, integration.KindEqualFold(*i.KindEqualFold))
	}
	if i.KindContainsFold != nil {
		predicates = append(predicates, integration.KindContainsFold(*i.KindContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, integration.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, integration.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, integration.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, integration.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, integration.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, integration.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, integration.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, integration.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, integration.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, integration.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, integration.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, integration.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, integration.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, integration.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, integration.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.SecretName != nil {
		predicates = append(predicates, integration.SecretNameEQ(*i.SecretName))
	}
	if i.SecretNameNEQ != nil {
		predicates = append(predicates, integration.SecretNameNEQ(*i.SecretNameNEQ))
	}
	if len(i.SecretNameIn) > 0 {
		predicates = append(predicates, integration.SecretNameIn(i.SecretNameIn...))
	}
	if len(i.SecretNameNotIn) > 0 {
		predicates = append(predicates, integration.SecretNameNotIn(i.SecretNameNotIn...))
	}
	if i.SecretNameGT != nil {
		predicates = append(predicates, integration.SecretNameGT(*i.SecretNameGT))
	}
	if i.SecretNameGTE != nil {
		predicates = append(predicates, integration.SecretNameGTE(*i.SecretNameGTE))
	}
	if i.SecretNameLT != nil {
		predicates = append(predicates, integration.SecretNameLT(*i.SecretNameLT))
	}
	if i.SecretNameLTE != nil {
		predicates = append(predicates, integration.SecretNameLTE(*i.SecretNameLTE))
	}
	if i.SecretNameContains != nil {
		predicates = append(predicates, integration.SecretNameContains(*i.SecretNameContains))
	}
	if i.SecretNameHasPrefix != nil {
		predicates = append(predicates, integration.SecretNameHasPrefix(*i.SecretNameHasPrefix))
	}
	if i.SecretNameHasSuffix != nil {
		predicates = append(predicates, integration.SecretNameHasSuffix(*i.SecretNameHasSuffix))
	}
	if i.SecretNameEqualFold != nil {
		predicates = append(predicates, integration.SecretNameEqualFold(*i.SecretNameEqualFold))
	}
	if i.SecretNameContainsFold != nil {
		predicates = append(predicates, integration.SecretNameContainsFold(*i.SecretNameContainsFold))
	}

	if i.HasOwner != nil {
		p := integration.HasOwner()
		if !*i.HasOwner {
			p = integration.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, integration.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyIntegrationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return integration.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Predicates []predicate.Organization  `json:"-"`
	Not        *OrganizationWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationWhereInput `json:"or,omitempty"`
	And        []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "parent_organization_id" field predicates.
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNEQ          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGT           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGTE          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLT           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLTE          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        bool     `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       bool     `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "integrations" edge predicates.
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationWhereInput) AddPredicates(predicates ...predicate.Organization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationWhereInput is returned in case the OrganizationWhereInput is empty.
var ErrEmptyOrganizationWhereInput = errors.New("generated: empty predicate OrganizationWhereInput")

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, organization.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, organization.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organization.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organization.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organization.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organization.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organization.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organization.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organization.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organization.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organization.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organization.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organization.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organization.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organization.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organization.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organization.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organization.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organization.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organization.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organization.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organization.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organization.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organization.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organization.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organization.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organization.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organization.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organization.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organization.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organization.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organization.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organization.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organization.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organization.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organization.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organization.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organization.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organization.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organization.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organization.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organization.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organization.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organization.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organization.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.ParentOrganizationID != nil {
		predicates = append(predicates, organization.ParentOrganizationIDEQ(*i.ParentOrganizationID))
	}
	if i.ParentOrganizationIDNEQ != nil {
		predicates = append(predicates, organization.ParentOrganizationIDNEQ(*i.ParentOrganizationIDNEQ))
	}
	if len(i.ParentOrganizationIDIn) > 0 {
		predicates = append(predicates, organization.ParentOrganizationIDIn(i.ParentOrganizationIDIn...))
	}
	if len(i.ParentOrganizationIDNotIn) > 0 {
		predicates = append(predicates, organization.ParentOrganizationIDNotIn(i.ParentOrganizationIDNotIn...))
	}
	if i.ParentOrganizationIDGT != nil {
		predicates = append(predicates, organization.ParentOrganizationIDGT(*i.ParentOrganizationIDGT))
	}
	if i.ParentOrganizationIDGTE != nil {
		predicates = append(predicates, organization.ParentOrganizationIDGTE(*i.ParentOrganizationIDGTE))
	}
	if i.ParentOrganizationIDLT != nil {
		predicates = append(predicates, organization.ParentOrganizationIDLT(*i.ParentOrganizationIDLT))
	}
	if i.ParentOrganizationIDLTE != nil {
		predicates = append(predicates, organization.ParentOrganizationIDLTE(*i.ParentOrganizationIDLTE))
	}
	if i.ParentOrganizationIDContains != nil {
		predicates = append(predicates, organization.ParentOrganizationIDContains(*i.ParentOrganizationIDContains))
	}
	if i.ParentOrganizationIDHasPrefix != nil {
		predicates = append(predicates, organization.ParentOrganizationIDHasPrefix(*i.ParentOrganizationIDHasPrefix))
	}
	if i.ParentOrganizationIDHasSuffix != nil {
		predicates = append(predicates, organization.ParentOrganizationIDHasSuffix(*i.ParentOrganizationIDHasSuffix))
	}
	if i.ParentOrganizationIDIsNil {
		predicates = append(predicates, organization.ParentOrganizationIDIsNil())
	}
	if i.ParentOrganizationIDNotNil {
		predicates = append(predicates, organization.ParentOrganizationIDNotNil())
	}
	if i.ParentOrganizationIDEqualFold != nil {
		predicates = append(predicates, organization.ParentOrganizationIDEqualFold(*i.ParentOrganizationIDEqualFold))
	}
	if i.ParentOrganizationIDContainsFold != nil {
		predicates = append(predicates, organization.ParentOrganizationIDContainsFold(*i.ParentOrganizationIDContainsFold))
	}

	if i.HasParent != nil {
		p := organization.HasParent()
		if !*i.HasParent {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := organization.HasChildren()
		if !*i.HasChildren {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasChildrenWith(with...))
	}
	if i.HasUsers != nil {
		p := organization.HasUsers()
		if !*i.HasUsers {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasUsersWith(with...))
	}
	if i.HasGroups != nil {
		p := organization.HasGroups()
		if !*i.HasGroups {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasGroupsWith(with...))
	}
	if i.HasIntegrations != nil {
		p := organization.HasIntegrations()
		if !*i.HasIntegrations {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationsWith) > 0 {
		with := make([]predicate.Integration, 0, len(i.HasIntegrationsWith))
		for _, w := range i.HasIntegrationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasIntegrationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// OrganizationSettingsWhereInput represents a where input for filtering OrganizationSettings queries.
type OrganizationSettingsWhereInput struct {
	Predicates []predicate.OrganizationSettings  `json:"-"`
	Not        *OrganizationSettingsWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationSettingsWhereInput `json:"or,omitempty"`
	And        []*OrganizationSettingsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "sso_cert" field predicates.
	SSOCert             *string  `json:"ssoCert,omitempty"`
	SSOCertNEQ          *string  `json:"ssoCertNEQ,omitempty"`
	SSOCertIn           []string `json:"ssoCertIn,omitempty"`
	SSOCertNotIn        []string `json:"ssoCertNotIn,omitempty"`
	SSOCertGT           *string  `json:"ssoCertGT,omitempty"`
	SSOCertGTE          *string  `json:"ssoCertGTE,omitempty"`
	SSOCertLT           *string  `json:"ssoCertLT,omitempty"`
	SSOCertLTE          *string  `json:"ssoCertLTE,omitempty"`
	SSOCertContains     *string  `json:"ssoCertContains,omitempty"`
	SSOCertHasPrefix    *string  `json:"ssoCertHasPrefix,omitempty"`
	SSOCertHasSuffix    *string  `json:"ssoCertHasSuffix,omitempty"`
	SSOCertEqualFold    *string  `json:"ssoCertEqualFold,omitempty"`
	SSOCertContainsFold *string  `json:"ssoCertContainsFold,omitempty"`

	// "sso_entrypoint" field predicates.
	SSOEntrypoint             *string  `json:"ssoEntrypoint,omitempty"`
	SSOEntrypointNEQ          *string  `json:"ssoEntrypointNEQ,omitempty"`
	SSOEntrypointIn           []string `json:"ssoEntrypointIn,omitempty"`
	SSOEntrypointNotIn        []string `json:"ssoEntrypointNotIn,omitempty"`
	SSOEntrypointGT           *string  `json:"ssoEntrypointGT,omitempty"`
	SSOEntrypointGTE          *string  `json:"ssoEntrypointGTE,omitempty"`
	SSOEntrypointLT           *string  `json:"ssoEntrypointLT,omitempty"`
	SSOEntrypointLTE          *string  `json:"ssoEntrypointLTE,omitempty"`
	SSOEntrypointContains     *string  `json:"ssoEntrypointContains,omitempty"`
	SSOEntrypointHasPrefix    *string  `json:"ssoEntrypointHasPrefix,omitempty"`
	SSOEntrypointHasSuffix    *string  `json:"ssoEntrypointHasSuffix,omitempty"`
	SSOEntrypointEqualFold    *string  `json:"ssoEntrypointEqualFold,omitempty"`
	SSOEntrypointContainsFold *string  `json:"ssoEntrypointContainsFold,omitempty"`

	// "sso_issuer" field predicates.
	SSOIssuer             *string  `json:"ssoIssuer,omitempty"`
	SSOIssuerNEQ          *string  `json:"ssoIssuerNEQ,omitempty"`
	SSOIssuerIn           []string `json:"ssoIssuerIn,omitempty"`
	SSOIssuerNotIn        []string `json:"ssoIssuerNotIn,omitempty"`
	SSOIssuerGT           *string  `json:"ssoIssuerGT,omitempty"`
	SSOIssuerGTE          *string  `json:"ssoIssuerGTE,omitempty"`
	SSOIssuerLT           *string  `json:"ssoIssuerLT,omitempty"`
	SSOIssuerLTE          *string  `json:"ssoIssuerLTE,omitempty"`
	SSOIssuerContains     *string  `json:"ssoIssuerContains,omitempty"`
	SSOIssuerHasPrefix    *string  `json:"ssoIssuerHasPrefix,omitempty"`
	SSOIssuerHasSuffix    *string  `json:"ssoIssuerHasSuffix,omitempty"`
	SSOIssuerEqualFold    *string  `json:"ssoIssuerEqualFold,omitempty"`
	SSOIssuerContainsFold *string  `json:"ssoIssuerContainsFold,omitempty"`

	// "billing_contact" field predicates.
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNEQ          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGT           *string  `json:"billingContactGT,omitempty"`
	BillingContactGTE          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLT           *string  `json:"billingContactLT,omitempty"`
	BillingContactLTE          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`

	// "billing_email" field predicates.
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNEQ          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGT           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGTE          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLT           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLTE          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`

	// "billing_phone" field predicates.
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNEQ          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGT           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGTE          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLT           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLTE          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`

	// "billing_address" field predicates.
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNEQ          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGT           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGTE          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLT           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLTE          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`

	// "tax_identifier" field predicates.
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNEQ          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGT           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGTE          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLT           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLTE          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationSettingsWhereInput) AddPredicates(predicates ...predicate.OrganizationSettings) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationSettingsWhereInput filter on the OrganizationSettingsQuery builder.
func (i *OrganizationSettingsWhereInput) Filter(q *OrganizationSettingsQuery) (*OrganizationSettingsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationSettingsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationSettingsWhereInput is returned in case the OrganizationSettingsWhereInput is empty.
var ErrEmptyOrganizationSettingsWhereInput = errors.New("generated: empty predicate OrganizationSettingsWhereInput")

// P returns a predicate for filtering organizationsettingsslice.
// An error is returned if the input is empty or invalid.
func (i *OrganizationSettingsWhereInput) P() (predicate.OrganizationSettings, error) {
	var predicates []predicate.OrganizationSettings
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organizationsettings.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrganizationSettings, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organizationsettings.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrganizationSettings, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organizationsettings.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organizationsettings.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organizationsettings.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organizationsettings.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organizationsettings.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organizationsettings.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organizationsettings.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organizationsettings.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organizationsettings.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, organizationsettings.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, organizationsettings.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organizationsettings.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organizationsettings.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organizationsettings.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organizationsettings.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organizationsettings.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organizationsettings.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organizationsettings.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organizationsettings.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organizationsettings.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organizationsettings.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organizationsettings.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationsettings.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organizationsettings.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organizationsettings.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organizationsettings.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organizationsettings.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organizationsettings.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organizationsettings.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organizationsettings.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organizationsettings.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organizationsettings.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organizationsettings.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organizationsettings.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organizationsettings.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, organizationsettings.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, organizationsettings.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, organizationsettings.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, organizationsettings.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, organizationsettings.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, organizationsettings.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, organizationsettings.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organizationsettings.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organizationsettings.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organizationsettings.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organizationsettings.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organizationsettings.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organizationsettings.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organizationsettings.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organizationsettings.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, organizationsettings.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, organizationsettings.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, organizationsettings.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organizationsettings.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organizationsettings.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, organizationsettings.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, organizationsettings.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.SSOCert != nil {
		predicates = append(predicates, organizationsettings.SSOCertEQ(*i.SSOCert))
	}
	if i.SSOCertNEQ != nil {
		predicates = append(predicates, organizationsettings.SSOCertNEQ(*i.SSOCertNEQ))
	}
	if len(i.SSOCertIn) > 0 {
		predicates = append(predicates, organizationsettings.SSOCertIn(i.SSOCertIn...))
	}
	if len(i.SSOCertNotIn) > 0 {
		predicates = append(predicates, organizationsettings.SSOCertNotIn(i.SSOCertNotIn...))
	}
	if i.SSOCertGT != nil {
		predicates = append(predicates, organizationsettings.SSOCertGT(*i.SSOCertGT))
	}
	if i.SSOCertGTE != nil {
		predicates = append(predicates, organizationsettings.SSOCertGTE(*i.SSOCertGTE))
	}
	if i.SSOCertLT != nil {
		predicates = append(predicates, organizationsettings.SSOCertLT(*i.SSOCertLT))
	}
	if i.SSOCertLTE != nil {
		predicates = append(predicates, organizationsettings.SSOCertLTE(*i.SSOCertLTE))
	}
	if i.SSOCertContains != nil {
		predicates = append(predicates, organizationsettings.SSOCertContains(*i.SSOCertContains))
	}
	if i.SSOCertHasPrefix != nil {
		predicates = append(predicates, organizationsettings.SSOCertHasPrefix(*i.SSOCertHasPrefix))
	}
	if i.SSOCertHasSuffix != nil {
		predicates = append(predicates, organizationsettings.SSOCertHasSuffix(*i.SSOCertHasSuffix))
	}
	if i.SSOCertEqualFold != nil {
		predicates = append(predicates, organizationsettings.SSOCertEqualFold(*i.SSOCertEqualFold))
	}
	if i.SSOCertContainsFold != nil {
		predicates = append(predicates, organizationsettings.SSOCertContainsFold(*i.SSOCertContainsFold))
	}
	if i.SSOEntrypoint != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointEQ(*i.SSOEntrypoint))
	}
	if i.SSOEntrypointNEQ != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointNEQ(*i.SSOEntrypointNEQ))
	}
	if len(i.SSOEntrypointIn) > 0 {
		predicates = append(predicates, organizationsettings.SSOEntrypointIn(i.SSOEntrypointIn...))
	}
	if len(i.SSOEntrypointNotIn) > 0 {
		predicates = append(predicates, organizationsettings.SSOEntrypointNotIn(i.SSOEntrypointNotIn...))
	}
	if i.SSOEntrypointGT != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointGT(*i.SSOEntrypointGT))
	}
	if i.SSOEntrypointGTE != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointGTE(*i.SSOEntrypointGTE))
	}
	if i.SSOEntrypointLT != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointLT(*i.SSOEntrypointLT))
	}
	if i.SSOEntrypointLTE != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointLTE(*i.SSOEntrypointLTE))
	}
	if i.SSOEntrypointContains != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointContains(*i.SSOEntrypointContains))
	}
	if i.SSOEntrypointHasPrefix != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointHasPrefix(*i.SSOEntrypointHasPrefix))
	}
	if i.SSOEntrypointHasSuffix != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointHasSuffix(*i.SSOEntrypointHasSuffix))
	}
	if i.SSOEntrypointEqualFold != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointEqualFold(*i.SSOEntrypointEqualFold))
	}
	if i.SSOEntrypointContainsFold != nil {
		predicates = append(predicates, organizationsettings.SSOEntrypointContainsFold(*i.SSOEntrypointContainsFold))
	}
	if i.SSOIssuer != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerEQ(*i.SSOIssuer))
	}
	if i.SSOIssuerNEQ != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerNEQ(*i.SSOIssuerNEQ))
	}
	if len(i.SSOIssuerIn) > 0 {
		predicates = append(predicates, organizationsettings.SSOIssuerIn(i.SSOIssuerIn...))
	}
	if len(i.SSOIssuerNotIn) > 0 {
		predicates = append(predicates, organizationsettings.SSOIssuerNotIn(i.SSOIssuerNotIn...))
	}
	if i.SSOIssuerGT != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerGT(*i.SSOIssuerGT))
	}
	if i.SSOIssuerGTE != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerGTE(*i.SSOIssuerGTE))
	}
	if i.SSOIssuerLT != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerLT(*i.SSOIssuerLT))
	}
	if i.SSOIssuerLTE != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerLTE(*i.SSOIssuerLTE))
	}
	if i.SSOIssuerContains != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerContains(*i.SSOIssuerContains))
	}
	if i.SSOIssuerHasPrefix != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerHasPrefix(*i.SSOIssuerHasPrefix))
	}
	if i.SSOIssuerHasSuffix != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerHasSuffix(*i.SSOIssuerHasSuffix))
	}
	if i.SSOIssuerEqualFold != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerEqualFold(*i.SSOIssuerEqualFold))
	}
	if i.SSOIssuerContainsFold != nil {
		predicates = append(predicates, organizationsettings.SSOIssuerContainsFold(*i.SSOIssuerContainsFold))
	}
	if i.BillingContact != nil {
		predicates = append(predicates, organizationsettings.BillingContactEQ(*i.BillingContact))
	}
	if i.BillingContactNEQ != nil {
		predicates = append(predicates, organizationsettings.BillingContactNEQ(*i.BillingContactNEQ))
	}
	if len(i.BillingContactIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingContactIn(i.BillingContactIn...))
	}
	if len(i.BillingContactNotIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingContactNotIn(i.BillingContactNotIn...))
	}
	if i.BillingContactGT != nil {
		predicates = append(predicates, organizationsettings.BillingContactGT(*i.BillingContactGT))
	}
	if i.BillingContactGTE != nil {
		predicates = append(predicates, organizationsettings.BillingContactGTE(*i.BillingContactGTE))
	}
	if i.BillingContactLT != nil {
		predicates = append(predicates, organizationsettings.BillingContactLT(*i.BillingContactLT))
	}
	if i.BillingContactLTE != nil {
		predicates = append(predicates, organizationsettings.BillingContactLTE(*i.BillingContactLTE))
	}
	if i.BillingContactContains != nil {
		predicates = append(predicates, organizationsettings.BillingContactContains(*i.BillingContactContains))
	}
	if i.BillingContactHasPrefix != nil {
		predicates = append(predicates, organizationsettings.BillingContactHasPrefix(*i.BillingContactHasPrefix))
	}
	if i.BillingContactHasSuffix != nil {
		predicates = append(predicates, organizationsettings.BillingContactHasSuffix(*i.BillingContactHasSuffix))
	}
	if i.BillingContactEqualFold != nil {
		predicates = append(predicates, organizationsettings.BillingContactEqualFold(*i.BillingContactEqualFold))
	}
	if i.BillingContactContainsFold != nil {
		predicates = append(predicates, organizationsettings.BillingContactContainsFold(*i.BillingContactContainsFold))
	}
	if i.BillingEmail != nil {
		predicates = append(predicates, organizationsettings.BillingEmailEQ(*i.BillingEmail))
	}
	if i.BillingEmailNEQ != nil {
		predicates = append(predicates, organizationsettings.BillingEmailNEQ(*i.BillingEmailNEQ))
	}
	if len(i.BillingEmailIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingEmailIn(i.BillingEmailIn...))
	}
	if len(i.BillingEmailNotIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingEmailNotIn(i.BillingEmailNotIn...))
	}
	if i.BillingEmailGT != nil {
		predicates = append(predicates, organizationsettings.BillingEmailGT(*i.BillingEmailGT))
	}
	if i.BillingEmailGTE != nil {
		predicates = append(predicates, organizationsettings.BillingEmailGTE(*i.BillingEmailGTE))
	}
	if i.BillingEmailLT != nil {
		predicates = append(predicates, organizationsettings.BillingEmailLT(*i.BillingEmailLT))
	}
	if i.BillingEmailLTE != nil {
		predicates = append(predicates, organizationsettings.BillingEmailLTE(*i.BillingEmailLTE))
	}
	if i.BillingEmailContains != nil {
		predicates = append(predicates, organizationsettings.BillingEmailContains(*i.BillingEmailContains))
	}
	if i.BillingEmailHasPrefix != nil {
		predicates = append(predicates, organizationsettings.BillingEmailHasPrefix(*i.BillingEmailHasPrefix))
	}
	if i.BillingEmailHasSuffix != nil {
		predicates = append(predicates, organizationsettings.BillingEmailHasSuffix(*i.BillingEmailHasSuffix))
	}
	if i.BillingEmailEqualFold != nil {
		predicates = append(predicates, organizationsettings.BillingEmailEqualFold(*i.BillingEmailEqualFold))
	}
	if i.BillingEmailContainsFold != nil {
		predicates = append(predicates, organizationsettings.BillingEmailContainsFold(*i.BillingEmailContainsFold))
	}
	if i.BillingPhone != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneEQ(*i.BillingPhone))
	}
	if i.BillingPhoneNEQ != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneNEQ(*i.BillingPhoneNEQ))
	}
	if len(i.BillingPhoneIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingPhoneIn(i.BillingPhoneIn...))
	}
	if len(i.BillingPhoneNotIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingPhoneNotIn(i.BillingPhoneNotIn...))
	}
	if i.BillingPhoneGT != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneGT(*i.BillingPhoneGT))
	}
	if i.BillingPhoneGTE != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneGTE(*i.BillingPhoneGTE))
	}
	if i.BillingPhoneLT != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneLT(*i.BillingPhoneLT))
	}
	if i.BillingPhoneLTE != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneLTE(*i.BillingPhoneLTE))
	}
	if i.BillingPhoneContains != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneContains(*i.BillingPhoneContains))
	}
	if i.BillingPhoneHasPrefix != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneHasPrefix(*i.BillingPhoneHasPrefix))
	}
	if i.BillingPhoneHasSuffix != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneHasSuffix(*i.BillingPhoneHasSuffix))
	}
	if i.BillingPhoneEqualFold != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneEqualFold(*i.BillingPhoneEqualFold))
	}
	if i.BillingPhoneContainsFold != nil {
		predicates = append(predicates, organizationsettings.BillingPhoneContainsFold(*i.BillingPhoneContainsFold))
	}
	if i.BillingAddress != nil {
		predicates = append(predicates, organizationsettings.BillingAddressEQ(*i.BillingAddress))
	}
	if i.BillingAddressNEQ != nil {
		predicates = append(predicates, organizationsettings.BillingAddressNEQ(*i.BillingAddressNEQ))
	}
	if len(i.BillingAddressIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingAddressIn(i.BillingAddressIn...))
	}
	if len(i.BillingAddressNotIn) > 0 {
		predicates = append(predicates, organizationsettings.BillingAddressNotIn(i.BillingAddressNotIn...))
	}
	if i.BillingAddressGT != nil {
		predicates = append(predicates, organizationsettings.BillingAddressGT(*i.BillingAddressGT))
	}
	if i.BillingAddressGTE != nil {
		predicates = append(predicates, organizationsettings.BillingAddressGTE(*i.BillingAddressGTE))
	}
	if i.BillingAddressLT != nil {
		predicates = append(predicates, organizationsettings.BillingAddressLT(*i.BillingAddressLT))
	}
	if i.BillingAddressLTE != nil {
		predicates = append(predicates, organizationsettings.BillingAddressLTE(*i.BillingAddressLTE))
	}
	if i.BillingAddressContains != nil {
		predicates = append(predicates, organizationsettings.BillingAddressContains(*i.BillingAddressContains))
	}
	if i.BillingAddressHasPrefix != nil {
		predicates = append(predicates, organizationsettings.BillingAddressHasPrefix(*i.BillingAddressHasPrefix))
	}
	if i.BillingAddressHasSuffix != nil {
		predicates = append(predicates, organizationsettings.BillingAddressHasSuffix(*i.BillingAddressHasSuffix))
	}
	if i.BillingAddressEqualFold != nil {
		predicates = append(predicates, organizationsettings.BillingAddressEqualFold(*i.BillingAddressEqualFold))
	}
	if i.BillingAddressContainsFold != nil {
		predicates = append(predicates, organizationsettings.BillingAddressContainsFold(*i.BillingAddressContainsFold))
	}
	if i.TaxIdentifier != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierEQ(*i.TaxIdentifier))
	}
	if i.TaxIdentifierNEQ != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierNEQ(*i.TaxIdentifierNEQ))
	}
	if len(i.TaxIdentifierIn) > 0 {
		predicates = append(predicates, organizationsettings.TaxIdentifierIn(i.TaxIdentifierIn...))
	}
	if len(i.TaxIdentifierNotIn) > 0 {
		predicates = append(predicates, organizationsettings.TaxIdentifierNotIn(i.TaxIdentifierNotIn...))
	}
	if i.TaxIdentifierGT != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierGT(*i.TaxIdentifierGT))
	}
	if i.TaxIdentifierGTE != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierGTE(*i.TaxIdentifierGTE))
	}
	if i.TaxIdentifierLT != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierLT(*i.TaxIdentifierLT))
	}
	if i.TaxIdentifierLTE != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierLTE(*i.TaxIdentifierLTE))
	}
	if i.TaxIdentifierContains != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierContains(*i.TaxIdentifierContains))
	}
	if i.TaxIdentifierHasPrefix != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierHasPrefix(*i.TaxIdentifierHasPrefix))
	}
	if i.TaxIdentifierHasSuffix != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierHasSuffix(*i.TaxIdentifierHasSuffix))
	}
	if i.TaxIdentifierEqualFold != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierEqualFold(*i.TaxIdentifierEqualFold))
	}
	if i.TaxIdentifierContainsFold != nil {
		predicates = append(predicates, organizationsettings.TaxIdentifierContainsFold(*i.TaxIdentifierContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationSettingsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organizationsettings.And(predicates...), nil
	}
}

// PersonalAccessTokenWhereInput represents a where input for filtering PersonalAccessToken queries.
type PersonalAccessTokenWhereInput struct {
	Predicates []predicate.PersonalAccessToken  `json:"-"`
	Not        *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	Or         []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	And        []*PersonalAccessTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "expiration_at" field predicates.
	ExpirationAt      *time.Time  `json:"expirationAt,omitempty"`
	ExpirationAtNEQ   *time.Time  `json:"expirationAtNEQ,omitempty"`
	ExpirationAtIn    []time.Time `json:"expirationAtIn,omitempty"`
	ExpirationAtNotIn []time.Time `json:"expirationAtNotIn,omitempty"`
	ExpirationAtGT    *time.Time  `json:"expirationAtGT,omitempty"`
	ExpirationAtGTE   *time.Time  `json:"expirationAtGTE,omitempty"`
	ExpirationAtLT    *time.Time  `json:"expirationAtLT,omitempty"`
	ExpirationAtLTE   *time.Time  `json:"expirationAtLTE,omitempty"`

	// "last_used_at" field predicates.
	LastUsedAt       *time.Time  `json:"lastUsedAt,omitempty"`
	LastUsedAtNEQ    *time.Time  `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGT     *time.Time  `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGTE    *time.Time  `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLT     *time.Time  `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLTE    *time.Time  `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil bool        `json:"lastUsedAtNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PersonalAccessTokenWhereInput) AddPredicates(predicates ...predicate.PersonalAccessToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PersonalAccessTokenWhereInput filter on the PersonalAccessTokenQuery builder.
func (i *PersonalAccessTokenWhereInput) Filter(q *PersonalAccessTokenQuery) (*PersonalAccessTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPersonalAccessTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPersonalAccessTokenWhereInput is returned in case the PersonalAccessTokenWhereInput is empty.
var ErrEmptyPersonalAccessTokenWhereInput = errors.New("generated: empty predicate PersonalAccessTokenWhereInput")

// P returns a predicate for filtering personalaccesstokens.
// An error is returned if the input is empty or invalid.
func (i *PersonalAccessTokenWhereInput) P() (predicate.PersonalAccessToken, error) {
	var predicates []predicate.PersonalAccessToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, personalaccesstoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PersonalAccessToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, personalaccesstoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PersonalAccessToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, personalaccesstoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, personalaccesstoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, personalaccesstoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, personalaccesstoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, personalaccesstoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, personalaccesstoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, personalaccesstoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, personalaccesstoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, personalaccesstoken.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, personalaccesstoken.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, personalaccesstoken.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, personalaccesstoken.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, personalaccesstoken.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, personalaccesstoken.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, personalaccesstoken.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, personalaccesstoken.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, personalaccesstoken.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, personalaccesstoken.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, personalaccesstoken.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, personalaccesstoken.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.NameContainsFold(*i.NameContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, personalaccesstoken.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, personalaccesstoken.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, personalaccesstoken.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, personalaccesstoken.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, personalaccesstoken.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, personalaccesstoken.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, personalaccesstoken.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Token != nil {
		predicates = append(predicates, personalaccesstoken.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, personalaccesstoken.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, personalaccesstoken.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, personalaccesstoken.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, personalaccesstoken.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, personalaccesstoken.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, personalaccesstoken.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, personalaccesstoken.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, personalaccesstoken.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, personalaccesstoken.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, personalaccesstoken.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, personalaccesstoken.TokenContainsFold(*i.TokenContainsFold))
	}
	if i.ExpirationAt != nil {
		predicates = append(predicates, personalaccesstoken.ExpirationAtEQ(*i.ExpirationAt))
	}
	if i.ExpirationAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.ExpirationAtNEQ(*i.ExpirationAtNEQ))
	}
	if len(i.ExpirationAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.ExpirationAtIn(i.ExpirationAtIn...))
	}
	if len(i.ExpirationAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.ExpirationAtNotIn(i.ExpirationAtNotIn...))
	}
	if i.ExpirationAtGT != nil {
		predicates = append(predicates, personalaccesstoken.ExpirationAtGT(*i.ExpirationAtGT))
	}
	if i.ExpirationAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.ExpirationAtGTE(*i.ExpirationAtGTE))
	}
	if i.ExpirationAtLT != nil {
		predicates = append(predicates, personalaccesstoken.ExpirationAtLT(*i.ExpirationAtLT))
	}
	if i.ExpirationAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.ExpirationAtLTE(*i.ExpirationAtLTE))
	}
	if i.LastUsedAt != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtEQ(*i.LastUsedAt))
	}
	if i.LastUsedAtNEQ != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtNEQ(*i.LastUsedAtNEQ))
	}
	if len(i.LastUsedAtIn) > 0 {
		predicates = append(predicates, personalaccesstoken.LastUsedAtIn(i.LastUsedAtIn...))
	}
	if len(i.LastUsedAtNotIn) > 0 {
		predicates = append(predicates, personalaccesstoken.LastUsedAtNotIn(i.LastUsedAtNotIn...))
	}
	if i.LastUsedAtGT != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtGT(*i.LastUsedAtGT))
	}
	if i.LastUsedAtGTE != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtGTE(*i.LastUsedAtGTE))
	}
	if i.LastUsedAtLT != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtLT(*i.LastUsedAtLT))
	}
	if i.LastUsedAtLTE != nil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtLTE(*i.LastUsedAtLTE))
	}
	if i.LastUsedAtIsNil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtIsNil())
	}
	if i.LastUsedAtNotNil {
		predicates = append(predicates, personalaccesstoken.LastUsedAtNotNil())
	}

	if i.HasUser != nil {
		p := personalaccesstoken.HasUser()
		if !*i.HasUser {
			p = personalaccesstoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, personalaccesstoken.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPersonalAccessTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return personalaccesstoken.And(predicates...), nil
	}
}

// RefreshTokenWhereInput represents a where input for filtering RefreshToken queries.
type RefreshTokenWhereInput struct {
	Predicates []predicate.RefreshToken  `json:"-"`
	Not        *RefreshTokenWhereInput   `json:"not,omitempty"`
	Or         []*RefreshTokenWhereInput `json:"or,omitempty"`
	And        []*RefreshTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "client_id" field predicates.
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNEQ          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGT           *string  `json:"clientIDGT,omitempty"`
	ClientIDGTE          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLT           *string  `json:"clientIDLT,omitempty"`
	ClientIDLTE          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`

	// "nonce" field predicates.
	Nonce             *string  `json:"nonce,omitempty"`
	NonceNEQ          *string  `json:"nonceNEQ,omitempty"`
	NonceIn           []string `json:"nonceIn,omitempty"`
	NonceNotIn        []string `json:"nonceNotIn,omitempty"`
	NonceGT           *string  `json:"nonceGT,omitempty"`
	NonceGTE          *string  `json:"nonceGTE,omitempty"`
	NonceLT           *string  `json:"nonceLT,omitempty"`
	NonceLTE          *string  `json:"nonceLTE,omitempty"`
	NonceContains     *string  `json:"nonceContains,omitempty"`
	NonceHasPrefix    *string  `json:"nonceHasPrefix,omitempty"`
	NonceHasSuffix    *string  `json:"nonceHasSuffix,omitempty"`
	NonceEqualFold    *string  `json:"nonceEqualFold,omitempty"`
	NonceContainsFold *string  `json:"nonceContainsFold,omitempty"`

	// "claims_user_id" field predicates.
	ClaimsUserID             *string  `json:"claimsUserID,omitempty"`
	ClaimsUserIDNEQ          *string  `json:"claimsUserIDNEQ,omitempty"`
	ClaimsUserIDIn           []string `json:"claimsUserIDIn,omitempty"`
	ClaimsUserIDNotIn        []string `json:"claimsUserIDNotIn,omitempty"`
	ClaimsUserIDGT           *string  `json:"claimsUserIDGT,omitempty"`
	ClaimsUserIDGTE          *string  `json:"claimsUserIDGTE,omitempty"`
	ClaimsUserIDLT           *string  `json:"claimsUserIDLT,omitempty"`
	ClaimsUserIDLTE          *string  `json:"claimsUserIDLTE,omitempty"`
	ClaimsUserIDContains     *string  `json:"claimsUserIDContains,omitempty"`
	ClaimsUserIDHasPrefix    *string  `json:"claimsUserIDHasPrefix,omitempty"`
	ClaimsUserIDHasSuffix    *string  `json:"claimsUserIDHasSuffix,omitempty"`
	ClaimsUserIDEqualFold    *string  `json:"claimsUserIDEqualFold,omitempty"`
	ClaimsUserIDContainsFold *string  `json:"claimsUserIDContainsFold,omitempty"`

	// "claims_username" field predicates.
	ClaimsUsername             *string  `json:"claimsUsername,omitempty"`
	ClaimsUsernameNEQ          *string  `json:"claimsUsernameNEQ,omitempty"`
	ClaimsUsernameIn           []string `json:"claimsUsernameIn,omitempty"`
	ClaimsUsernameNotIn        []string `json:"claimsUsernameNotIn,omitempty"`
	ClaimsUsernameGT           *string  `json:"claimsUsernameGT,omitempty"`
	ClaimsUsernameGTE          *string  `json:"claimsUsernameGTE,omitempty"`
	ClaimsUsernameLT           *string  `json:"claimsUsernameLT,omitempty"`
	ClaimsUsernameLTE          *string  `json:"claimsUsernameLTE,omitempty"`
	ClaimsUsernameContains     *string  `json:"claimsUsernameContains,omitempty"`
	ClaimsUsernameHasPrefix    *string  `json:"claimsUsernameHasPrefix,omitempty"`
	ClaimsUsernameHasSuffix    *string  `json:"claimsUsernameHasSuffix,omitempty"`
	ClaimsUsernameEqualFold    *string  `json:"claimsUsernameEqualFold,omitempty"`
	ClaimsUsernameContainsFold *string  `json:"claimsUsernameContainsFold,omitempty"`

	// "claims_email" field predicates.
	ClaimsEmail             *string  `json:"claimsEmail,omitempty"`
	ClaimsEmailNEQ          *string  `json:"claimsEmailNEQ,omitempty"`
	ClaimsEmailIn           []string `json:"claimsEmailIn,omitempty"`
	ClaimsEmailNotIn        []string `json:"claimsEmailNotIn,omitempty"`
	ClaimsEmailGT           *string  `json:"claimsEmailGT,omitempty"`
	ClaimsEmailGTE          *string  `json:"claimsEmailGTE,omitempty"`
	ClaimsEmailLT           *string  `json:"claimsEmailLT,omitempty"`
	ClaimsEmailLTE          *string  `json:"claimsEmailLTE,omitempty"`
	ClaimsEmailContains     *string  `json:"claimsEmailContains,omitempty"`
	ClaimsEmailHasPrefix    *string  `json:"claimsEmailHasPrefix,omitempty"`
	ClaimsEmailHasSuffix    *string  `json:"claimsEmailHasSuffix,omitempty"`
	ClaimsEmailEqualFold    *string  `json:"claimsEmailEqualFold,omitempty"`
	ClaimsEmailContainsFold *string  `json:"claimsEmailContainsFold,omitempty"`

	// "claims_email_verified" field predicates.
	ClaimsEmailVerified    *bool `json:"claimsEmailVerified,omitempty"`
	ClaimsEmailVerifiedNEQ *bool `json:"claimsEmailVerifiedNEQ,omitempty"`

	// "claims_preferred_username" field predicates.
	ClaimsPreferredUsername             *string  `json:"claimsPreferredUsername,omitempty"`
	ClaimsPreferredUsernameNEQ          *string  `json:"claimsPreferredUsernameNEQ,omitempty"`
	ClaimsPreferredUsernameIn           []string `json:"claimsPreferredUsernameIn,omitempty"`
	ClaimsPreferredUsernameNotIn        []string `json:"claimsPreferredUsernameNotIn,omitempty"`
	ClaimsPreferredUsernameGT           *string  `json:"claimsPreferredUsernameGT,omitempty"`
	ClaimsPreferredUsernameGTE          *string  `json:"claimsPreferredUsernameGTE,omitempty"`
	ClaimsPreferredUsernameLT           *string  `json:"claimsPreferredUsernameLT,omitempty"`
	ClaimsPreferredUsernameLTE          *string  `json:"claimsPreferredUsernameLTE,omitempty"`
	ClaimsPreferredUsernameContains     *string  `json:"claimsPreferredUsernameContains,omitempty"`
	ClaimsPreferredUsernameHasPrefix    *string  `json:"claimsPreferredUsernameHasPrefix,omitempty"`
	ClaimsPreferredUsernameHasSuffix    *string  `json:"claimsPreferredUsernameHasSuffix,omitempty"`
	ClaimsPreferredUsernameEqualFold    *string  `json:"claimsPreferredUsernameEqualFold,omitempty"`
	ClaimsPreferredUsernameContainsFold *string  `json:"claimsPreferredUsernameContainsFold,omitempty"`

	// "connector_id" field predicates.
	ConnectorID             *string  `json:"connectorID,omitempty"`
	ConnectorIDNEQ          *string  `json:"connectorIDNEQ,omitempty"`
	ConnectorIDIn           []string `json:"connectorIDIn,omitempty"`
	ConnectorIDNotIn        []string `json:"connectorIDNotIn,omitempty"`
	ConnectorIDGT           *string  `json:"connectorIDGT,omitempty"`
	ConnectorIDGTE          *string  `json:"connectorIDGTE,omitempty"`
	ConnectorIDLT           *string  `json:"connectorIDLT,omitempty"`
	ConnectorIDLTE          *string  `json:"connectorIDLTE,omitempty"`
	ConnectorIDContains     *string  `json:"connectorIDContains,omitempty"`
	ConnectorIDHasPrefix    *string  `json:"connectorIDHasPrefix,omitempty"`
	ConnectorIDHasSuffix    *string  `json:"connectorIDHasSuffix,omitempty"`
	ConnectorIDEqualFold    *string  `json:"connectorIDEqualFold,omitempty"`
	ConnectorIDContainsFold *string  `json:"connectorIDContainsFold,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "obsolete_token" field predicates.
	ObsoleteToken             *string  `json:"obsoleteToken,omitempty"`
	ObsoleteTokenNEQ          *string  `json:"obsoleteTokenNEQ,omitempty"`
	ObsoleteTokenIn           []string `json:"obsoleteTokenIn,omitempty"`
	ObsoleteTokenNotIn        []string `json:"obsoleteTokenNotIn,omitempty"`
	ObsoleteTokenGT           *string  `json:"obsoleteTokenGT,omitempty"`
	ObsoleteTokenGTE          *string  `json:"obsoleteTokenGTE,omitempty"`
	ObsoleteTokenLT           *string  `json:"obsoleteTokenLT,omitempty"`
	ObsoleteTokenLTE          *string  `json:"obsoleteTokenLTE,omitempty"`
	ObsoleteTokenContains     *string  `json:"obsoleteTokenContains,omitempty"`
	ObsoleteTokenHasPrefix    *string  `json:"obsoleteTokenHasPrefix,omitempty"`
	ObsoleteTokenHasSuffix    *string  `json:"obsoleteTokenHasSuffix,omitempty"`
	ObsoleteTokenEqualFold    *string  `json:"obsoleteTokenEqualFold,omitempty"`
	ObsoleteTokenContainsFold *string  `json:"obsoleteTokenContainsFold,omitempty"`

	// "last_used" field predicates.
	LastUsed      *time.Time  `json:"lastUsed,omitempty"`
	LastUsedNEQ   *time.Time  `json:"lastUsedNEQ,omitempty"`
	LastUsedIn    []time.Time `json:"lastUsedIn,omitempty"`
	LastUsedNotIn []time.Time `json:"lastUsedNotIn,omitempty"`
	LastUsedGT    *time.Time  `json:"lastUsedGT,omitempty"`
	LastUsedGTE   *time.Time  `json:"lastUsedGTE,omitempty"`
	LastUsedLT    *time.Time  `json:"lastUsedLT,omitempty"`
	LastUsedLTE   *time.Time  `json:"lastUsedLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RefreshTokenWhereInput) AddPredicates(predicates ...predicate.RefreshToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RefreshTokenWhereInput filter on the RefreshTokenQuery builder.
func (i *RefreshTokenWhereInput) Filter(q *RefreshTokenQuery) (*RefreshTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRefreshTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRefreshTokenWhereInput is returned in case the RefreshTokenWhereInput is empty.
var ErrEmptyRefreshTokenWhereInput = errors.New("generated: empty predicate RefreshTokenWhereInput")

// P returns a predicate for filtering refreshtokens.
// An error is returned if the input is empty or invalid.
func (i *RefreshTokenWhereInput) P() (predicate.RefreshToken, error) {
	var predicates []predicate.RefreshToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, refreshtoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RefreshToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, refreshtoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RefreshToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, refreshtoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, refreshtoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, refreshtoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, refreshtoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, refreshtoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, refreshtoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, refreshtoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, refreshtoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, refreshtoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, refreshtoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, refreshtoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.ClientID != nil {
		predicates = append(predicates, refreshtoken.ClientIDEQ(*i.ClientID))
	}
	if i.ClientIDNEQ != nil {
		predicates = append(predicates, refreshtoken.ClientIDNEQ(*i.ClientIDNEQ))
	}
	if len(i.ClientIDIn) > 0 {
		predicates = append(predicates, refreshtoken.ClientIDIn(i.ClientIDIn...))
	}
	if len(i.ClientIDNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ClientIDNotIn(i.ClientIDNotIn...))
	}
	if i.ClientIDGT != nil {
		predicates = append(predicates, refreshtoken.ClientIDGT(*i.ClientIDGT))
	}
	if i.ClientIDGTE != nil {
		predicates = append(predicates, refreshtoken.ClientIDGTE(*i.ClientIDGTE))
	}
	if i.ClientIDLT != nil {
		predicates = append(predicates, refreshtoken.ClientIDLT(*i.ClientIDLT))
	}
	if i.ClientIDLTE != nil {
		predicates = append(predicates, refreshtoken.ClientIDLTE(*i.ClientIDLTE))
	}
	if i.ClientIDContains != nil {
		predicates = append(predicates, refreshtoken.ClientIDContains(*i.ClientIDContains))
	}
	if i.ClientIDHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ClientIDHasPrefix(*i.ClientIDHasPrefix))
	}
	if i.ClientIDHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ClientIDHasSuffix(*i.ClientIDHasSuffix))
	}
	if i.ClientIDEqualFold != nil {
		predicates = append(predicates, refreshtoken.ClientIDEqualFold(*i.ClientIDEqualFold))
	}
	if i.ClientIDContainsFold != nil {
		predicates = append(predicates, refreshtoken.ClientIDContainsFold(*i.ClientIDContainsFold))
	}
	if i.Nonce != nil {
		predicates = append(predicates, refreshtoken.NonceEQ(*i.Nonce))
	}
	if i.NonceNEQ != nil {
		predicates = append(predicates, refreshtoken.NonceNEQ(*i.NonceNEQ))
	}
	if len(i.NonceIn) > 0 {
		predicates = append(predicates, refreshtoken.NonceIn(i.NonceIn...))
	}
	if len(i.NonceNotIn) > 0 {
		predicates = append(predicates, refreshtoken.NonceNotIn(i.NonceNotIn...))
	}
	if i.NonceGT != nil {
		predicates = append(predicates, refreshtoken.NonceGT(*i.NonceGT))
	}
	if i.NonceGTE != nil {
		predicates = append(predicates, refreshtoken.NonceGTE(*i.NonceGTE))
	}
	if i.NonceLT != nil {
		predicates = append(predicates, refreshtoken.NonceLT(*i.NonceLT))
	}
	if i.NonceLTE != nil {
		predicates = append(predicates, refreshtoken.NonceLTE(*i.NonceLTE))
	}
	if i.NonceContains != nil {
		predicates = append(predicates, refreshtoken.NonceContains(*i.NonceContains))
	}
	if i.NonceHasPrefix != nil {
		predicates = append(predicates, refreshtoken.NonceHasPrefix(*i.NonceHasPrefix))
	}
	if i.NonceHasSuffix != nil {
		predicates = append(predicates, refreshtoken.NonceHasSuffix(*i.NonceHasSuffix))
	}
	if i.NonceEqualFold != nil {
		predicates = append(predicates, refreshtoken.NonceEqualFold(*i.NonceEqualFold))
	}
	if i.NonceContainsFold != nil {
		predicates = append(predicates, refreshtoken.NonceContainsFold(*i.NonceContainsFold))
	}
	if i.ClaimsUserID != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDEQ(*i.ClaimsUserID))
	}
	if i.ClaimsUserIDNEQ != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDNEQ(*i.ClaimsUserIDNEQ))
	}
	if len(i.ClaimsUserIDIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsUserIDIn(i.ClaimsUserIDIn...))
	}
	if len(i.ClaimsUserIDNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsUserIDNotIn(i.ClaimsUserIDNotIn...))
	}
	if i.ClaimsUserIDGT != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDGT(*i.ClaimsUserIDGT))
	}
	if i.ClaimsUserIDGTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDGTE(*i.ClaimsUserIDGTE))
	}
	if i.ClaimsUserIDLT != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDLT(*i.ClaimsUserIDLT))
	}
	if i.ClaimsUserIDLTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDLTE(*i.ClaimsUserIDLTE))
	}
	if i.ClaimsUserIDContains != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDContains(*i.ClaimsUserIDContains))
	}
	if i.ClaimsUserIDHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDHasPrefix(*i.ClaimsUserIDHasPrefix))
	}
	if i.ClaimsUserIDHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDHasSuffix(*i.ClaimsUserIDHasSuffix))
	}
	if i.ClaimsUserIDEqualFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDEqualFold(*i.ClaimsUserIDEqualFold))
	}
	if i.ClaimsUserIDContainsFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsUserIDContainsFold(*i.ClaimsUserIDContainsFold))
	}
	if i.ClaimsUsername != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameEQ(*i.ClaimsUsername))
	}
	if i.ClaimsUsernameNEQ != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameNEQ(*i.ClaimsUsernameNEQ))
	}
	if len(i.ClaimsUsernameIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsUsernameIn(i.ClaimsUsernameIn...))
	}
	if len(i.ClaimsUsernameNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsUsernameNotIn(i.ClaimsUsernameNotIn...))
	}
	if i.ClaimsUsernameGT != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameGT(*i.ClaimsUsernameGT))
	}
	if i.ClaimsUsernameGTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameGTE(*i.ClaimsUsernameGTE))
	}
	if i.ClaimsUsernameLT != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameLT(*i.ClaimsUsernameLT))
	}
	if i.ClaimsUsernameLTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameLTE(*i.ClaimsUsernameLTE))
	}
	if i.ClaimsUsernameContains != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameContains(*i.ClaimsUsernameContains))
	}
	if i.ClaimsUsernameHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameHasPrefix(*i.ClaimsUsernameHasPrefix))
	}
	if i.ClaimsUsernameHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameHasSuffix(*i.ClaimsUsernameHasSuffix))
	}
	if i.ClaimsUsernameEqualFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameEqualFold(*i.ClaimsUsernameEqualFold))
	}
	if i.ClaimsUsernameContainsFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsUsernameContainsFold(*i.ClaimsUsernameContainsFold))
	}
	if i.ClaimsEmail != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailEQ(*i.ClaimsEmail))
	}
	if i.ClaimsEmailNEQ != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailNEQ(*i.ClaimsEmailNEQ))
	}
	if len(i.ClaimsEmailIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsEmailIn(i.ClaimsEmailIn...))
	}
	if len(i.ClaimsEmailNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsEmailNotIn(i.ClaimsEmailNotIn...))
	}
	if i.ClaimsEmailGT != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailGT(*i.ClaimsEmailGT))
	}
	if i.ClaimsEmailGTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailGTE(*i.ClaimsEmailGTE))
	}
	if i.ClaimsEmailLT != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailLT(*i.ClaimsEmailLT))
	}
	if i.ClaimsEmailLTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailLTE(*i.ClaimsEmailLTE))
	}
	if i.ClaimsEmailContains != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailContains(*i.ClaimsEmailContains))
	}
	if i.ClaimsEmailHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailHasPrefix(*i.ClaimsEmailHasPrefix))
	}
	if i.ClaimsEmailHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailHasSuffix(*i.ClaimsEmailHasSuffix))
	}
	if i.ClaimsEmailEqualFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailEqualFold(*i.ClaimsEmailEqualFold))
	}
	if i.ClaimsEmailContainsFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailContainsFold(*i.ClaimsEmailContainsFold))
	}
	if i.ClaimsEmailVerified != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailVerifiedEQ(*i.ClaimsEmailVerified))
	}
	if i.ClaimsEmailVerifiedNEQ != nil {
		predicates = append(predicates, refreshtoken.ClaimsEmailVerifiedNEQ(*i.ClaimsEmailVerifiedNEQ))
	}
	if i.ClaimsPreferredUsername != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameEQ(*i.ClaimsPreferredUsername))
	}
	if i.ClaimsPreferredUsernameNEQ != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameNEQ(*i.ClaimsPreferredUsernameNEQ))
	}
	if len(i.ClaimsPreferredUsernameIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameIn(i.ClaimsPreferredUsernameIn...))
	}
	if len(i.ClaimsPreferredUsernameNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameNotIn(i.ClaimsPreferredUsernameNotIn...))
	}
	if i.ClaimsPreferredUsernameGT != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameGT(*i.ClaimsPreferredUsernameGT))
	}
	if i.ClaimsPreferredUsernameGTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameGTE(*i.ClaimsPreferredUsernameGTE))
	}
	if i.ClaimsPreferredUsernameLT != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameLT(*i.ClaimsPreferredUsernameLT))
	}
	if i.ClaimsPreferredUsernameLTE != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameLTE(*i.ClaimsPreferredUsernameLTE))
	}
	if i.ClaimsPreferredUsernameContains != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameContains(*i.ClaimsPreferredUsernameContains))
	}
	if i.ClaimsPreferredUsernameHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameHasPrefix(*i.ClaimsPreferredUsernameHasPrefix))
	}
	if i.ClaimsPreferredUsernameHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameHasSuffix(*i.ClaimsPreferredUsernameHasSuffix))
	}
	if i.ClaimsPreferredUsernameEqualFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameEqualFold(*i.ClaimsPreferredUsernameEqualFold))
	}
	if i.ClaimsPreferredUsernameContainsFold != nil {
		predicates = append(predicates, refreshtoken.ClaimsPreferredUsernameContainsFold(*i.ClaimsPreferredUsernameContainsFold))
	}
	if i.ConnectorID != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDEQ(*i.ConnectorID))
	}
	if i.ConnectorIDNEQ != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDNEQ(*i.ConnectorIDNEQ))
	}
	if len(i.ConnectorIDIn) > 0 {
		predicates = append(predicates, refreshtoken.ConnectorIDIn(i.ConnectorIDIn...))
	}
	if len(i.ConnectorIDNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ConnectorIDNotIn(i.ConnectorIDNotIn...))
	}
	if i.ConnectorIDGT != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDGT(*i.ConnectorIDGT))
	}
	if i.ConnectorIDGTE != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDGTE(*i.ConnectorIDGTE))
	}
	if i.ConnectorIDLT != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDLT(*i.ConnectorIDLT))
	}
	if i.ConnectorIDLTE != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDLTE(*i.ConnectorIDLTE))
	}
	if i.ConnectorIDContains != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDContains(*i.ConnectorIDContains))
	}
	if i.ConnectorIDHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDHasPrefix(*i.ConnectorIDHasPrefix))
	}
	if i.ConnectorIDHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDHasSuffix(*i.ConnectorIDHasSuffix))
	}
	if i.ConnectorIDEqualFold != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDEqualFold(*i.ConnectorIDEqualFold))
	}
	if i.ConnectorIDContainsFold != nil {
		predicates = append(predicates, refreshtoken.ConnectorIDContainsFold(*i.ConnectorIDContainsFold))
	}
	if i.Token != nil {
		predicates = append(predicates, refreshtoken.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, refreshtoken.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, refreshtoken.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, refreshtoken.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, refreshtoken.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, refreshtoken.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, refreshtoken.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, refreshtoken.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, refreshtoken.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, refreshtoken.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, refreshtoken.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, refreshtoken.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, refreshtoken.TokenContainsFold(*i.TokenContainsFold))
	}
	if i.ObsoleteToken != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenEQ(*i.ObsoleteToken))
	}
	if i.ObsoleteTokenNEQ != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenNEQ(*i.ObsoleteTokenNEQ))
	}
	if len(i.ObsoleteTokenIn) > 0 {
		predicates = append(predicates, refreshtoken.ObsoleteTokenIn(i.ObsoleteTokenIn...))
	}
	if len(i.ObsoleteTokenNotIn) > 0 {
		predicates = append(predicates, refreshtoken.ObsoleteTokenNotIn(i.ObsoleteTokenNotIn...))
	}
	if i.ObsoleteTokenGT != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenGT(*i.ObsoleteTokenGT))
	}
	if i.ObsoleteTokenGTE != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenGTE(*i.ObsoleteTokenGTE))
	}
	if i.ObsoleteTokenLT != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenLT(*i.ObsoleteTokenLT))
	}
	if i.ObsoleteTokenLTE != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenLTE(*i.ObsoleteTokenLTE))
	}
	if i.ObsoleteTokenContains != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenContains(*i.ObsoleteTokenContains))
	}
	if i.ObsoleteTokenHasPrefix != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenHasPrefix(*i.ObsoleteTokenHasPrefix))
	}
	if i.ObsoleteTokenHasSuffix != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenHasSuffix(*i.ObsoleteTokenHasSuffix))
	}
	if i.ObsoleteTokenEqualFold != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenEqualFold(*i.ObsoleteTokenEqualFold))
	}
	if i.ObsoleteTokenContainsFold != nil {
		predicates = append(predicates, refreshtoken.ObsoleteTokenContainsFold(*i.ObsoleteTokenContainsFold))
	}
	if i.LastUsed != nil {
		predicates = append(predicates, refreshtoken.LastUsedEQ(*i.LastUsed))
	}
	if i.LastUsedNEQ != nil {
		predicates = append(predicates, refreshtoken.LastUsedNEQ(*i.LastUsedNEQ))
	}
	if len(i.LastUsedIn) > 0 {
		predicates = append(predicates, refreshtoken.LastUsedIn(i.LastUsedIn...))
	}
	if len(i.LastUsedNotIn) > 0 {
		predicates = append(predicates, refreshtoken.LastUsedNotIn(i.LastUsedNotIn...))
	}
	if i.LastUsedGT != nil {
		predicates = append(predicates, refreshtoken.LastUsedGT(*i.LastUsedGT))
	}
	if i.LastUsedGTE != nil {
		predicates = append(predicates, refreshtoken.LastUsedGTE(*i.LastUsedGTE))
	}
	if i.LastUsedLT != nil {
		predicates = append(predicates, refreshtoken.LastUsedLT(*i.LastUsedLT))
	}
	if i.LastUsedLTE != nil {
		predicates = append(predicates, refreshtoken.LastUsedLTE(*i.LastUsedLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRefreshTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return refreshtoken.And(predicates...), nil
	}
}

// SessionWhereInput represents a where input for filtering Session queries.
type SessionWhereInput struct {
	Predicates []predicate.Session  `json:"-"`
	Not        *SessionWhereInput   `json:"not,omitempty"`
	Or         []*SessionWhereInput `json:"or,omitempty"`
	And        []*SessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "type" field predicates.
	Type      *session.Type  `json:"type,omitempty"`
	TypeNEQ   *session.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []session.Type `json:"typeIn,omitempty"`
	TypeNotIn []session.Type `json:"typeNotIn,omitempty"`

	// "disabled" field predicates.
	Disabled    *bool `json:"disabled,omitempty"`
	DisabledNEQ *bool `json:"disabledNEQ,omitempty"`

	// "token" field predicates.
	Token             *string  `json:"token,omitempty"`
	TokenNEQ          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGT           *string  `json:"tokenGT,omitempty"`
	TokenGTE          *string  `json:"tokenGTE,omitempty"`
	TokenLT           *string  `json:"tokenLT,omitempty"`
	TokenLTE          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`

	// "user_agent" field predicates.
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNEQ          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGT           *string  `json:"userAgentGT,omitempty"`
	UserAgentGTE          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLT           *string  `json:"userAgentLT,omitempty"`
	UserAgentLTE          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentIsNil        bool     `json:"userAgentIsNil,omitempty"`
	UserAgentNotNil       bool     `json:"userAgentNotNil,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`

	// "ips" field predicates.
	Ips             *string  `json:"ips,omitempty"`
	IpsNEQ          *string  `json:"ipsNEQ,omitempty"`
	IpsIn           []string `json:"ipsIn,omitempty"`
	IpsNotIn        []string `json:"ipsNotIn,omitempty"`
	IpsGT           *string  `json:"ipsGT,omitempty"`
	IpsGTE          *string  `json:"ipsGTE,omitempty"`
	IpsLT           *string  `json:"ipsLT,omitempty"`
	IpsLTE          *string  `json:"ipsLTE,omitempty"`
	IpsContains     *string  `json:"ipsContains,omitempty"`
	IpsHasPrefix    *string  `json:"ipsHasPrefix,omitempty"`
	IpsHasSuffix    *string  `json:"ipsHasSuffix,omitempty"`
	IpsEqualFold    *string  `json:"ipsEqualFold,omitempty"`
	IpsContainsFold *string  `json:"ipsContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SessionWhereInput) AddPredicates(predicates ...predicate.Session) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SessionWhereInput filter on the SessionQuery builder.
func (i *SessionWhereInput) Filter(q *SessionQuery) (*SessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySessionWhereInput is returned in case the SessionWhereInput is empty.
var ErrEmptySessionWhereInput = errors.New("generated: empty predicate SessionWhereInput")

// P returns a predicate for filtering sessions.
// An error is returned if the input is empty or invalid.
func (i *SessionWhereInput) P() (predicate.Session, error) {
	var predicates []predicate.Session
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, session.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Session, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, session.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Session, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, session.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, session.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, session.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, session.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, session.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, session.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, session.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, session.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, session.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, session.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, session.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, session.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, session.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, session.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, session.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, session.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, session.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, session.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, session.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, session.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, session.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, session.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, session.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, session.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, session.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, session.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, session.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, session.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, session.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, session.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, session.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, session.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, session.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, session.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, session.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, session.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, session.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, session.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, session.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, session.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, session.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, session.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, session.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, session.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, session.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, session.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, session.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, session.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, session.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, session.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, session.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, session.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, session.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, session.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, session.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, session.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, session.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, session.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, session.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, session.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, session.TypeNotIn(i.TypeNotIn...))
	}
	if i.Disabled != nil {
		predicates = append(predicates, session.DisabledEQ(*i.Disabled))
	}
	if i.DisabledNEQ != nil {
		predicates = append(predicates, session.DisabledNEQ(*i.DisabledNEQ))
	}
	if i.Token != nil {
		predicates = append(predicates, session.TokenEQ(*i.Token))
	}
	if i.TokenNEQ != nil {
		predicates = append(predicates, session.TokenNEQ(*i.TokenNEQ))
	}
	if len(i.TokenIn) > 0 {
		predicates = append(predicates, session.TokenIn(i.TokenIn...))
	}
	if len(i.TokenNotIn) > 0 {
		predicates = append(predicates, session.TokenNotIn(i.TokenNotIn...))
	}
	if i.TokenGT != nil {
		predicates = append(predicates, session.TokenGT(*i.TokenGT))
	}
	if i.TokenGTE != nil {
		predicates = append(predicates, session.TokenGTE(*i.TokenGTE))
	}
	if i.TokenLT != nil {
		predicates = append(predicates, session.TokenLT(*i.TokenLT))
	}
	if i.TokenLTE != nil {
		predicates = append(predicates, session.TokenLTE(*i.TokenLTE))
	}
	if i.TokenContains != nil {
		predicates = append(predicates, session.TokenContains(*i.TokenContains))
	}
	if i.TokenHasPrefix != nil {
		predicates = append(predicates, session.TokenHasPrefix(*i.TokenHasPrefix))
	}
	if i.TokenHasSuffix != nil {
		predicates = append(predicates, session.TokenHasSuffix(*i.TokenHasSuffix))
	}
	if i.TokenEqualFold != nil {
		predicates = append(predicates, session.TokenEqualFold(*i.TokenEqualFold))
	}
	if i.TokenContainsFold != nil {
		predicates = append(predicates, session.TokenContainsFold(*i.TokenContainsFold))
	}
	if i.UserAgent != nil {
		predicates = append(predicates, session.UserAgentEQ(*i.UserAgent))
	}
	if i.UserAgentNEQ != nil {
		predicates = append(predicates, session.UserAgentNEQ(*i.UserAgentNEQ))
	}
	if len(i.UserAgentIn) > 0 {
		predicates = append(predicates, session.UserAgentIn(i.UserAgentIn...))
	}
	if len(i.UserAgentNotIn) > 0 {
		predicates = append(predicates, session.UserAgentNotIn(i.UserAgentNotIn...))
	}
	if i.UserAgentGT != nil {
		predicates = append(predicates, session.UserAgentGT(*i.UserAgentGT))
	}
	if i.UserAgentGTE != nil {
		predicates = append(predicates, session.UserAgentGTE(*i.UserAgentGTE))
	}
	if i.UserAgentLT != nil {
		predicates = append(predicates, session.UserAgentLT(*i.UserAgentLT))
	}
	if i.UserAgentLTE != nil {
		predicates = append(predicates, session.UserAgentLTE(*i.UserAgentLTE))
	}
	if i.UserAgentContains != nil {
		predicates = append(predicates, session.UserAgentContains(*i.UserAgentContains))
	}
	if i.UserAgentHasPrefix != nil {
		predicates = append(predicates, session.UserAgentHasPrefix(*i.UserAgentHasPrefix))
	}
	if i.UserAgentHasSuffix != nil {
		predicates = append(predicates, session.UserAgentHasSuffix(*i.UserAgentHasSuffix))
	}
	if i.UserAgentIsNil {
		predicates = append(predicates, session.UserAgentIsNil())
	}
	if i.UserAgentNotNil {
		predicates = append(predicates, session.UserAgentNotNil())
	}
	if i.UserAgentEqualFold != nil {
		predicates = append(predicates, session.UserAgentEqualFold(*i.UserAgentEqualFold))
	}
	if i.UserAgentContainsFold != nil {
		predicates = append(predicates, session.UserAgentContainsFold(*i.UserAgentContainsFold))
	}
	if i.Ips != nil {
		predicates = append(predicates, session.IpsEQ(*i.Ips))
	}
	if i.IpsNEQ != nil {
		predicates = append(predicates, session.IpsNEQ(*i.IpsNEQ))
	}
	if len(i.IpsIn) > 0 {
		predicates = append(predicates, session.IpsIn(i.IpsIn...))
	}
	if len(i.IpsNotIn) > 0 {
		predicates = append(predicates, session.IpsNotIn(i.IpsNotIn...))
	}
	if i.IpsGT != nil {
		predicates = append(predicates, session.IpsGT(*i.IpsGT))
	}
	if i.IpsGTE != nil {
		predicates = append(predicates, session.IpsGTE(*i.IpsGTE))
	}
	if i.IpsLT != nil {
		predicates = append(predicates, session.IpsLT(*i.IpsLT))
	}
	if i.IpsLTE != nil {
		predicates = append(predicates, session.IpsLTE(*i.IpsLTE))
	}
	if i.IpsContains != nil {
		predicates = append(predicates, session.IpsContains(*i.IpsContains))
	}
	if i.IpsHasPrefix != nil {
		predicates = append(predicates, session.IpsHasPrefix(*i.IpsHasPrefix))
	}
	if i.IpsHasSuffix != nil {
		predicates = append(predicates, session.IpsHasSuffix(*i.IpsHasSuffix))
	}
	if i.IpsEqualFold != nil {
		predicates = append(predicates, session.IpsEqualFold(*i.IpsEqualFold))
	}
	if i.IpsContainsFold != nil {
		predicates = append(predicates, session.IpsContainsFold(*i.IpsContainsFold))
	}

	if i.HasUsers != nil {
		p := session.HasUsers()
		if !*i.HasUsers {
			p = session.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, session.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return session.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNEQ          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGT           *string  `json:"createdByGT,omitempty"`
	CreatedByGTE          *string  `json:"createdByGTE,omitempty"`
	CreatedByLT           *string  `json:"createdByLT,omitempty"`
	CreatedByLTE          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        bool     `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       bool     `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNEQ          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGT           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGTE          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLT           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLTE          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        bool     `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       bool     `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "locked" field predicates.
	Locked    *bool `json:"locked,omitempty"`
	LockedNEQ *bool `json:"lockedNEQ,omitempty"`

	// "avatar_remote_url" field predicates.
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNEQ          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGT           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGTE          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLT           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLTE          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        bool     `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       bool     `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`

	// "avatar_local_file" field predicates.
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNEQ          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGT           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGTE          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLT           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLTE          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        bool     `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       bool     `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`

	// "avatar_updated_at" field predicates.
	AvatarUpdatedAt       *time.Time  `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNEQ    *time.Time  `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGT     *time.Time  `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGTE    *time.Time  `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLT     *time.Time  `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLTE    *time.Time  `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil bool        `json:"avatarUpdatedAtNotNil,omitempty"`

	// "silenced_at" field predicates.
	SilencedAt       *time.Time  `json:"silencedAt,omitempty"`
	SilencedAtNEQ    *time.Time  `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGT     *time.Time  `json:"silencedAtGT,omitempty"`
	SilencedAtGTE    *time.Time  `json:"silencedAtGTE,omitempty"`
	SilencedAtLT     *time.Time  `json:"silencedAtLT,omitempty"`
	SilencedAtLTE    *time.Time  `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil bool        `json:"silencedAtNotNil,omitempty"`

	// "suspended_at" field predicates.
	SuspendedAt       *time.Time  `json:"suspendedAt,omitempty"`
	SuspendedAtNEQ    *time.Time  `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGT     *time.Time  `json:"suspendedAtGT,omitempty"`
	SuspendedAtGTE    *time.Time  `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLT     *time.Time  `json:"suspendedAtLT,omitempty"`
	SuspendedAtLTE    *time.Time  `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil bool        `json:"suspendedAtNotNil,omitempty"`

	// "recovery_code" field predicates.
	RecoveryCode             *string  `json:"recoveryCode,omitempty"`
	RecoveryCodeNEQ          *string  `json:"recoveryCodeNEQ,omitempty"`
	RecoveryCodeIn           []string `json:"recoveryCodeIn,omitempty"`
	RecoveryCodeNotIn        []string `json:"recoveryCodeNotIn,omitempty"`
	RecoveryCodeGT           *string  `json:"recoveryCodeGT,omitempty"`
	RecoveryCodeGTE          *string  `json:"recoveryCodeGTE,omitempty"`
	RecoveryCodeLT           *string  `json:"recoveryCodeLT,omitempty"`
	RecoveryCodeLTE          *string  `json:"recoveryCodeLTE,omitempty"`
	RecoveryCodeContains     *string  `json:"recoveryCodeContains,omitempty"`
	RecoveryCodeHasPrefix    *string  `json:"recoveryCodeHasPrefix,omitempty"`
	RecoveryCodeHasSuffix    *string  `json:"recoveryCodeHasSuffix,omitempty"`
	RecoveryCodeIsNil        bool     `json:"recoveryCodeIsNil,omitempty"`
	RecoveryCodeNotNil       bool     `json:"recoveryCodeNotNil,omitempty"`
	RecoveryCodeEqualFold    *string  `json:"recoveryCodeEqualFold,omitempty"`
	RecoveryCodeContainsFold *string  `json:"recoveryCodeContainsFold,omitempty"`

	// "organizations" edge predicates.
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`

	// "sessions" edge predicates.
	HasSessions     *bool                `json:"hasSessions,omitempty"`
	HasSessionsWith []*SessionWhereInput `json:"hasSessionsWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "personal_access_tokens" edge predicates.
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("generated: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, user.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, user.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, user.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, user.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, user.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, user.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, user.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, user.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, user.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, user.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedByContains != nil {
		predicates = append(predicates, user.CreatedByContains(*i.CreatedByContains))
	}
	if i.CreatedByHasPrefix != nil {
		predicates = append(predicates, user.CreatedByHasPrefix(*i.CreatedByHasPrefix))
	}
	if i.CreatedByHasSuffix != nil {
		predicates = append(predicates, user.CreatedByHasSuffix(*i.CreatedByHasSuffix))
	}
	if i.CreatedByIsNil {
		predicates = append(predicates, user.CreatedByIsNil())
	}
	if i.CreatedByNotNil {
		predicates = append(predicates, user.CreatedByNotNil())
	}
	if i.CreatedByEqualFold != nil {
		predicates = append(predicates, user.CreatedByEqualFold(*i.CreatedByEqualFold))
	}
	if i.CreatedByContainsFold != nil {
		predicates = append(predicates, user.CreatedByContainsFold(*i.CreatedByContainsFold))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, user.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, user.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, user.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, user.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, user.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, user.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, user.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, user.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByContains != nil {
		predicates = append(predicates, user.UpdatedByContains(*i.UpdatedByContains))
	}
	if i.UpdatedByHasPrefix != nil {
		predicates = append(predicates, user.UpdatedByHasPrefix(*i.UpdatedByHasPrefix))
	}
	if i.UpdatedByHasSuffix != nil {
		predicates = append(predicates, user.UpdatedByHasSuffix(*i.UpdatedByHasSuffix))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, user.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, user.UpdatedByNotNil())
	}
	if i.UpdatedByEqualFold != nil {
		predicates = append(predicates, user.UpdatedByEqualFold(*i.UpdatedByEqualFold))
	}
	if i.UpdatedByContainsFold != nil {
		predicates = append(predicates, user.UpdatedByContainsFold(*i.UpdatedByContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, user.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, user.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, user.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, user.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, user.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, user.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, user.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, user.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, user.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, user.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, user.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, user.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, user.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Locked != nil {
		predicates = append(predicates, user.LockedEQ(*i.Locked))
	}
	if i.LockedNEQ != nil {
		predicates = append(predicates, user.LockedNEQ(*i.LockedNEQ))
	}
	if i.AvatarRemoteURL != nil {
		predicates = append(predicates, user.AvatarRemoteURLEQ(*i.AvatarRemoteURL))
	}
	if i.AvatarRemoteURLNEQ != nil {
		predicates = append(predicates, user.AvatarRemoteURLNEQ(*i.AvatarRemoteURLNEQ))
	}
	if len(i.AvatarRemoteURLIn) > 0 {
		predicates = append(predicates, user.AvatarRemoteURLIn(i.AvatarRemoteURLIn...))
	}
	if len(i.AvatarRemoteURLNotIn) > 0 {
		predicates = append(predicates, user.AvatarRemoteURLNotIn(i.AvatarRemoteURLNotIn...))
	}
	if i.AvatarRemoteURLGT != nil {
		predicates = append(predicates, user.AvatarRemoteURLGT(*i.AvatarRemoteURLGT))
	}
	if i.AvatarRemoteURLGTE != nil {
		predicates = append(predicates, user.AvatarRemoteURLGTE(*i.AvatarRemoteURLGTE))
	}
	if i.AvatarRemoteURLLT != nil {
		predicates = append(predicates, user.AvatarRemoteURLLT(*i.AvatarRemoteURLLT))
	}
	if i.AvatarRemoteURLLTE != nil {
		predicates = append(predicates, user.AvatarRemoteURLLTE(*i.AvatarRemoteURLLTE))
	}
	if i.AvatarRemoteURLContains != nil {
		predicates = append(predicates, user.AvatarRemoteURLContains(*i.AvatarRemoteURLContains))
	}
	if i.AvatarRemoteURLHasPrefix != nil {
		predicates = append(predicates, user.AvatarRemoteURLHasPrefix(*i.AvatarRemoteURLHasPrefix))
	}
	if i.AvatarRemoteURLHasSuffix != nil {
		predicates = append(predicates, user.AvatarRemoteURLHasSuffix(*i.AvatarRemoteURLHasSuffix))
	}
	if i.AvatarRemoteURLIsNil {
		predicates = append(predicates, user.AvatarRemoteURLIsNil())
	}
	if i.AvatarRemoteURLNotNil {
		predicates = append(predicates, user.AvatarRemoteURLNotNil())
	}
	if i.AvatarRemoteURLEqualFold != nil {
		predicates = append(predicates, user.AvatarRemoteURLEqualFold(*i.AvatarRemoteURLEqualFold))
	}
	if i.AvatarRemoteURLContainsFold != nil {
		predicates = append(predicates, user.AvatarRemoteURLContainsFold(*i.AvatarRemoteURLContainsFold))
	}
	if i.AvatarLocalFile != nil {
		predicates = append(predicates, user.AvatarLocalFileEQ(*i.AvatarLocalFile))
	}
	if i.AvatarLocalFileNEQ != nil {
		predicates = append(predicates, user.AvatarLocalFileNEQ(*i.AvatarLocalFileNEQ))
	}
	if len(i.AvatarLocalFileIn) > 0 {
		predicates = append(predicates, user.AvatarLocalFileIn(i.AvatarLocalFileIn...))
	}
	if len(i.AvatarLocalFileNotIn) > 0 {
		predicates = append(predicates, user.AvatarLocalFileNotIn(i.AvatarLocalFileNotIn...))
	}
	if i.AvatarLocalFileGT != nil {
		predicates = append(predicates, user.AvatarLocalFileGT(*i.AvatarLocalFileGT))
	}
	if i.AvatarLocalFileGTE != nil {
		predicates = append(predicates, user.AvatarLocalFileGTE(*i.AvatarLocalFileGTE))
	}
	if i.AvatarLocalFileLT != nil {
		predicates = append(predicates, user.AvatarLocalFileLT(*i.AvatarLocalFileLT))
	}
	if i.AvatarLocalFileLTE != nil {
		predicates = append(predicates, user.AvatarLocalFileLTE(*i.AvatarLocalFileLTE))
	}
	if i.AvatarLocalFileContains != nil {
		predicates = append(predicates, user.AvatarLocalFileContains(*i.AvatarLocalFileContains))
	}
	if i.AvatarLocalFileHasPrefix != nil {
		predicates = append(predicates, user.AvatarLocalFileHasPrefix(*i.AvatarLocalFileHasPrefix))
	}
	if i.AvatarLocalFileHasSuffix != nil {
		predicates = append(predicates, user.AvatarLocalFileHasSuffix(*i.AvatarLocalFileHasSuffix))
	}
	if i.AvatarLocalFileIsNil {
		predicates = append(predicates, user.AvatarLocalFileIsNil())
	}
	if i.AvatarLocalFileNotNil {
		predicates = append(predicates, user.AvatarLocalFileNotNil())
	}
	if i.AvatarLocalFileEqualFold != nil {
		predicates = append(predicates, user.AvatarLocalFileEqualFold(*i.AvatarLocalFileEqualFold))
	}
	if i.AvatarLocalFileContainsFold != nil {
		predicates = append(predicates, user.AvatarLocalFileContainsFold(*i.AvatarLocalFileContainsFold))
	}
	if i.AvatarUpdatedAt != nil {
		predicates = append(predicates, user.AvatarUpdatedAtEQ(*i.AvatarUpdatedAt))
	}
	if i.AvatarUpdatedAtNEQ != nil {
		predicates = append(predicates, user.AvatarUpdatedAtNEQ(*i.AvatarUpdatedAtNEQ))
	}
	if len(i.AvatarUpdatedAtIn) > 0 {
		predicates = append(predicates, user.AvatarUpdatedAtIn(i.AvatarUpdatedAtIn...))
	}
	if len(i.AvatarUpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.AvatarUpdatedAtNotIn(i.AvatarUpdatedAtNotIn...))
	}
	if i.AvatarUpdatedAtGT != nil {
		predicates = append(predicates, user.AvatarUpdatedAtGT(*i.AvatarUpdatedAtGT))
	}
	if i.AvatarUpdatedAtGTE != nil {
		predicates = append(predicates, user.AvatarUpdatedAtGTE(*i.AvatarUpdatedAtGTE))
	}
	if i.AvatarUpdatedAtLT != nil {
		predicates = append(predicates, user.AvatarUpdatedAtLT(*i.AvatarUpdatedAtLT))
	}
	if i.AvatarUpdatedAtLTE != nil {
		predicates = append(predicates, user.AvatarUpdatedAtLTE(*i.AvatarUpdatedAtLTE))
	}
	if i.AvatarUpdatedAtIsNil {
		predicates = append(predicates, user.AvatarUpdatedAtIsNil())
	}
	if i.AvatarUpdatedAtNotNil {
		predicates = append(predicates, user.AvatarUpdatedAtNotNil())
	}
	if i.SilencedAt != nil {
		predicates = append(predicates, user.SilencedAtEQ(*i.SilencedAt))
	}
	if i.SilencedAtNEQ != nil {
		predicates = append(predicates, user.SilencedAtNEQ(*i.SilencedAtNEQ))
	}
	if len(i.SilencedAtIn) > 0 {
		predicates = append(predicates, user.SilencedAtIn(i.SilencedAtIn...))
	}
	if len(i.SilencedAtNotIn) > 0 {
		predicates = append(predicates, user.SilencedAtNotIn(i.SilencedAtNotIn...))
	}
	if i.SilencedAtGT != nil {
		predicates = append(predicates, user.SilencedAtGT(*i.SilencedAtGT))
	}
	if i.SilencedAtGTE != nil {
		predicates = append(predicates, user.SilencedAtGTE(*i.SilencedAtGTE))
	}
	if i.SilencedAtLT != nil {
		predicates = append(predicates, user.SilencedAtLT(*i.SilencedAtLT))
	}
	if i.SilencedAtLTE != nil {
		predicates = append(predicates, user.SilencedAtLTE(*i.SilencedAtLTE))
	}
	if i.SilencedAtIsNil {
		predicates = append(predicates, user.SilencedAtIsNil())
	}
	if i.SilencedAtNotNil {
		predicates = append(predicates, user.SilencedAtNotNil())
	}
	if i.SuspendedAt != nil {
		predicates = append(predicates, user.SuspendedAtEQ(*i.SuspendedAt))
	}
	if i.SuspendedAtNEQ != nil {
		predicates = append(predicates, user.SuspendedAtNEQ(*i.SuspendedAtNEQ))
	}
	if len(i.SuspendedAtIn) > 0 {
		predicates = append(predicates, user.SuspendedAtIn(i.SuspendedAtIn...))
	}
	if len(i.SuspendedAtNotIn) > 0 {
		predicates = append(predicates, user.SuspendedAtNotIn(i.SuspendedAtNotIn...))
	}
	if i.SuspendedAtGT != nil {
		predicates = append(predicates, user.SuspendedAtGT(*i.SuspendedAtGT))
	}
	if i.SuspendedAtGTE != nil {
		predicates = append(predicates, user.SuspendedAtGTE(*i.SuspendedAtGTE))
	}
	if i.SuspendedAtLT != nil {
		predicates = append(predicates, user.SuspendedAtLT(*i.SuspendedAtLT))
	}
	if i.SuspendedAtLTE != nil {
		predicates = append(predicates, user.SuspendedAtLTE(*i.SuspendedAtLTE))
	}
	if i.SuspendedAtIsNil {
		predicates = append(predicates, user.SuspendedAtIsNil())
	}
	if i.SuspendedAtNotNil {
		predicates = append(predicates, user.SuspendedAtNotNil())
	}
	if i.RecoveryCode != nil {
		predicates = append(predicates, user.RecoveryCodeEQ(*i.RecoveryCode))
	}
	if i.RecoveryCodeNEQ != nil {
		predicates = append(predicates, user.RecoveryCodeNEQ(*i.RecoveryCodeNEQ))
	}
	if len(i.RecoveryCodeIn) > 0 {
		predicates = append(predicates, user.RecoveryCodeIn(i.RecoveryCodeIn...))
	}
	if len(i.RecoveryCodeNotIn) > 0 {
		predicates = append(predicates, user.RecoveryCodeNotIn(i.RecoveryCodeNotIn...))
	}
	if i.RecoveryCodeGT != nil {
		predicates = append(predicates, user.RecoveryCodeGT(*i.RecoveryCodeGT))
	}
	if i.RecoveryCodeGTE != nil {
		predicates = append(predicates, user.RecoveryCodeGTE(*i.RecoveryCodeGTE))
	}
	if i.RecoveryCodeLT != nil {
		predicates = append(predicates, user.RecoveryCodeLT(*i.RecoveryCodeLT))
	}
	if i.RecoveryCodeLTE != nil {
		predicates = append(predicates, user.RecoveryCodeLTE(*i.RecoveryCodeLTE))
	}
	if i.RecoveryCodeContains != nil {
		predicates = append(predicates, user.RecoveryCodeContains(*i.RecoveryCodeContains))
	}
	if i.RecoveryCodeHasPrefix != nil {
		predicates = append(predicates, user.RecoveryCodeHasPrefix(*i.RecoveryCodeHasPrefix))
	}
	if i.RecoveryCodeHasSuffix != nil {
		predicates = append(predicates, user.RecoveryCodeHasSuffix(*i.RecoveryCodeHasSuffix))
	}
	if i.RecoveryCodeIsNil {
		predicates = append(predicates, user.RecoveryCodeIsNil())
	}
	if i.RecoveryCodeNotNil {
		predicates = append(predicates, user.RecoveryCodeNotNil())
	}
	if i.RecoveryCodeEqualFold != nil {
		predicates = append(predicates, user.RecoveryCodeEqualFold(*i.RecoveryCodeEqualFold))
	}
	if i.RecoveryCodeContainsFold != nil {
		predicates = append(predicates, user.RecoveryCodeContainsFold(*i.RecoveryCodeContainsFold))
	}

	if i.HasOrganizations != nil {
		p := user.HasOrganizations()
		if !*i.HasOrganizations {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrganizationsWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOrganizationsWith))
		for _, w := range i.HasOrganizationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrganizationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasOrganizationsWith(with...))
	}
	if i.HasSessions != nil {
		p := user.HasSessions()
		if !*i.HasSessions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionsWith) > 0 {
		with := make([]predicate.Session, 0, len(i.HasSessionsWith))
		for _, w := range i.HasSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSessionsWith(with...))
	}
	if i.HasGroups != nil {
		p := user.HasGroups()
		if !*i.HasGroups {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasGroupsWith(with...))
	}
	if i.HasPersonalAccessTokens != nil {
		p := user.HasPersonalAccessTokens()
		if !*i.HasPersonalAccessTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPersonalAccessTokensWith) > 0 {
		with := make([]predicate.PersonalAccessToken, 0, len(i.HasPersonalAccessTokensWith))
		for _, w := range i.HasPersonalAccessTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPersonalAccessTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPersonalAccessTokensWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
