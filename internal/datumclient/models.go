// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package datumclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/datumforge/datum/internal/ent/generated/groupsettings"
	"github.com/datumforge/datum/internal/ent/generated/session"
	"github.com/datumforge/datum/internal/nanox"
)

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	Name        string     `json:"name"`
	Description *string    `json:"description,omitempty"`
	LogoURL     string     `json:"logoURL"`
	SettingID   nanox.ID   `json:"settingID"`
	UserIDs     []nanox.ID `json:"userIDs,omitempty"`
	OwnerID     *nanox.ID  `json:"ownerID,omitempty"`
}

// CreateGroupSettingsInput is used for create GroupSettings object.
// Input was generated by ent.
type CreateGroupSettingsInput struct {
	CreatedAt  *time.Time                `json:"createdAt,omitempty"`
	UpdatedAt  *time.Time                `json:"updatedAt,omitempty"`
	CreatedBy  *string                   `json:"createdBy,omitempty"`
	UpdatedBy  *string                   `json:"updatedBy,omitempty"`
	Visibility *groupsettings.Visibility `json:"visibility,omitempty"`
	JoinPolicy *groupsettings.JoinPolicy `json:"joinPolicy,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	CreatedBy   *string    `json:"createdBy,omitempty"`
	UpdatedBy   *string    `json:"updatedBy,omitempty"`
	Name        string     `json:"name"`
	Kind        string     `json:"kind"`
	Description *string    `json:"description,omitempty"`
	SecretName  string     `json:"secretName"`
	OwnerID     *nanox.ID  `json:"ownerID,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Name      string     `json:"name"`
	// An optional description of the Organization
	Description    *string    `json:"description,omitempty"`
	ParentID       *nanox.ID  `json:"parentID,omitempty"`
	UserIDs        []nanox.ID `json:"userIDs,omitempty"`
	GroupIDs       []nanox.ID `json:"groupIDs,omitempty"`
	IntegrationIDs []nanox.ID `json:"integrationIDs,omitempty"`
}

// CreateSessionInput is used for create Session object.
// Input was generated by ent.
type CreateSessionInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token *string `json:"token,omitempty"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips     string    `json:"ips"`
	UsersID *nanox.ID `json:"usersID,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Email     string     `json:"email"`
	FirstName string     `json:"firstName"`
	LastName  string     `json:"lastName"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// The time the user was silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// local Actor password recovery code generated during account creation
	RecoveryCode    *string    `json:"recoveryCode,omitempty"`
	OrganizationIDs []nanox.ID `json:"organizationIDs,omitempty"`
	SessionIDs      []nanox.ID `json:"sessionIDs,omitempty"`
	GroupIDs        []nanox.ID `json:"groupIDs,omitempty"`
}

type Group struct {
	ID          nanox.ID      `json:"id"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
	CreatedBy   *string       `json:"createdBy,omitempty"`
	UpdatedBy   *string       `json:"updatedBy,omitempty"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
	LogoURL     string        `json:"logoURL"`
	Setting     GroupSettings `json:"setting"`
	Users       []*User       `json:"users,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (Group) IsNode() {}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID nanox.ID `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

type GroupSettings struct {
	ID         nanox.ID                 `json:"id"`
	CreatedAt  time.Time                `json:"createdAt"`
	UpdatedAt  time.Time                `json:"updatedAt"`
	CreatedBy  *string                  `json:"createdBy,omitempty"`
	UpdatedBy  *string                  `json:"updatedBy,omitempty"`
	Visibility groupsettings.Visibility `json:"visibility"`
	JoinPolicy groupsettings.JoinPolicy `json:"joinPolicy"`
}

func (GroupSettings) IsNode() {}

// A connection to a list of items.
type GroupSettingsConnection struct {
	// A list of edges.
	Edges []*GroupSettingsEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingsEdge struct {
	// The item at the end of the edge.
	Node *GroupSettings `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupSettingsWhereInput is used for filtering GroupSettings objects.
// Input was generated by ent.
type GroupSettingsWhereInput struct {
	Not *GroupSettingsWhereInput   `json:"not,omitempty"`
	And []*GroupSettingsWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingsWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *nanox.ID  `json:"id,omitempty"`
	IDNeq   *nanox.ID  `json:"idNEQ,omitempty"`
	IDIn    []nanox.ID `json:"idIn,omitempty"`
	IDNotIn []nanox.ID `json:"idNotIn,omitempty"`
	IDGt    *nanox.ID  `json:"idGT,omitempty"`
	IDGte   *nanox.ID  `json:"idGTE,omitempty"`
	IDLt    *nanox.ID  `json:"idLT,omitempty"`
	IDLte   *nanox.ID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *groupsettings.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *groupsettings.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []groupsettings.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []groupsettings.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *groupsettings.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *groupsettings.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []groupsettings.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []groupsettings.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *nanox.ID  `json:"id,omitempty"`
	IDNeq   *nanox.ID  `json:"idNEQ,omitempty"`
	IDIn    []nanox.ID `json:"idIn,omitempty"`
	IDNotIn []nanox.ID `json:"idNotIn,omitempty"`
	IDGt    *nanox.ID  `json:"idGT,omitempty"`
	IDGte   *nanox.ID  `json:"idGTE,omitempty"`
	IDLt    *nanox.ID  `json:"idLT,omitempty"`
	IDLte   *nanox.ID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// setting edge predicates
	HasSetting     *bool                      `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingsWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Integration struct {
	ID          nanox.ID      `json:"id"`
	CreatedAt   time.Time     `json:"createdAt"`
	UpdatedAt   time.Time     `json:"updatedAt"`
	CreatedBy   *string       `json:"createdBy,omitempty"`
	UpdatedBy   *string       `json:"updatedBy,omitempty"`
	Name        string        `json:"name"`
	Kind        string        `json:"kind"`
	Description *string       `json:"description,omitempty"`
	SecretName  string        `json:"secretName"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (Integration) IsNode() {}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID nanox.ID `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *nanox.ID  `json:"id,omitempty"`
	IDNeq   *nanox.ID  `json:"idNEQ,omitempty"`
	IDIn    []nanox.ID `json:"idIn,omitempty"`
	IDNotIn []nanox.ID `json:"idNotIn,omitempty"`
	IDGt    *nanox.ID  `json:"idGT,omitempty"`
	IDGte   *nanox.ID  `json:"idGTE,omitempty"`
	IDLt    *nanox.ID  `json:"idLT,omitempty"`
	IDLte   *nanox.ID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Organization struct {
	ID        nanox.ID  `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	Name      string    `json:"name"`
	// An optional description of the Organization
	Description  *string                `json:"description,omitempty"`
	Parent       *Organization          `json:"parent,omitempty"`
	Children     OrganizationConnection `json:"children"`
	Users        []*User                `json:"users,omitempty"`
	Groups       []*Group               `json:"groups,omitempty"`
	Integrations []*Integration         `json:"integrations,omitempty"`
}

func (Organization) IsNode() {}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID nanox.ID `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *nanox.ID  `json:"id,omitempty"`
	IDNeq   *nanox.ID  `json:"idNEQ,omitempty"`
	IDIn    []nanox.ID `json:"idIn,omitempty"`
	IDNotIn []nanox.ID `json:"idNotIn,omitempty"`
	IDGt    *nanox.ID  `json:"idGT,omitempty"`
	IDGte   *nanox.ID  `json:"idGTE,omitempty"`
	IDLt    *nanox.ID  `json:"idLT,omitempty"`
	IDLte   *nanox.ID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type Session struct {
	ID        nanox.ID  `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	// Sessions can derrive from the local (password auth), oauth, or app_password
	Type session.Type `json:"type"`
	// The session may be disabled by the user or by automatic security policy
	Disabled bool `json:"disabled"`
	// random 32 bytes encoded as base64
	Token string `json:"token"`
	// The last known user-agent
	UserAgent *string `json:"userAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips string `json:"ips"`
	// Sessions belong to users
	Users *User `json:"users,omitempty"`
}

func (Session) IsNode() {}

// A connection to a list of items.
type SessionConnection struct {
	// A list of edges.
	Edges []*SessionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSession mutation
type SessionCreatePayload struct {
	// Created session
	Session Session `json:"session"`
}

// Return response for deleteSession mutation
type SessionDeletePayload struct {
	// Deleted session ID
	DeletedID nanox.ID `json:"deletedID"`
}

// An edge in a connection.
type SessionEdge struct {
	// The item at the end of the edge.
	Node *Session `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateSession mutation
type SessionUpdatePayload struct {
	// Updated session
	Session Session `json:"session"`
}

// SessionWhereInput is used for filtering Session objects.
// Input was generated by ent.
type SessionWhereInput struct {
	Not *SessionWhereInput   `json:"not,omitempty"`
	And []*SessionWhereInput `json:"and,omitempty"`
	Or  []*SessionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *nanox.ID  `json:"id,omitempty"`
	IDNeq   *nanox.ID  `json:"idNEQ,omitempty"`
	IDIn    []nanox.ID `json:"idIn,omitempty"`
	IDNotIn []nanox.ID `json:"idNotIn,omitempty"`
	IDGt    *nanox.ID  `json:"idGT,omitempty"`
	IDGte   *nanox.ID  `json:"idGTE,omitempty"`
	IDLt    *nanox.ID  `json:"idLT,omitempty"`
	IDLte   *nanox.ID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// type field predicates
	Type      *session.Type  `json:"type,omitempty"`
	TypeNeq   *session.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []session.Type `json:"typeIn,omitempty"`
	TypeNotIn []session.Type `json:"typeNotIn,omitempty"`
	// disabled field predicates
	Disabled    *bool `json:"disabled,omitempty"`
	DisabledNeq *bool `json:"disabledNEQ,omitempty"`
	// token field predicates
	Token             *string  `json:"token,omitempty"`
	TokenNeq          *string  `json:"tokenNEQ,omitempty"`
	TokenIn           []string `json:"tokenIn,omitempty"`
	TokenNotIn        []string `json:"tokenNotIn,omitempty"`
	TokenGt           *string  `json:"tokenGT,omitempty"`
	TokenGte          *string  `json:"tokenGTE,omitempty"`
	TokenLt           *string  `json:"tokenLT,omitempty"`
	TokenLte          *string  `json:"tokenLTE,omitempty"`
	TokenContains     *string  `json:"tokenContains,omitempty"`
	TokenHasPrefix    *string  `json:"tokenHasPrefix,omitempty"`
	TokenHasSuffix    *string  `json:"tokenHasSuffix,omitempty"`
	TokenEqualFold    *string  `json:"tokenEqualFold,omitempty"`
	TokenContainsFold *string  `json:"tokenContainsFold,omitempty"`
	// user_agent field predicates
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNeq          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGt           *string  `json:"userAgentGT,omitempty"`
	UserAgentGte          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLt           *string  `json:"userAgentLT,omitempty"`
	UserAgentLte          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentIsNil        *bool    `json:"userAgentIsNil,omitempty"`
	UserAgentNotNil       *bool    `json:"userAgentNotNil,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`
	// ips field predicates
	Ips             *string  `json:"ips,omitempty"`
	IpsNeq          *string  `json:"ipsNEQ,omitempty"`
	IpsIn           []string `json:"ipsIn,omitempty"`
	IpsNotIn        []string `json:"ipsNotIn,omitempty"`
	IpsGt           *string  `json:"ipsGT,omitempty"`
	IpsGte          *string  `json:"ipsGTE,omitempty"`
	IpsLt           *string  `json:"ipsLT,omitempty"`
	IpsLte          *string  `json:"ipsLTE,omitempty"`
	IpsContains     *string  `json:"ipsContains,omitempty"`
	IpsHasPrefix    *string  `json:"ipsHasPrefix,omitempty"`
	IpsHasSuffix    *string  `json:"ipsHasSuffix,omitempty"`
	IpsEqualFold    *string  `json:"ipsEqualFold,omitempty"`
	IpsContainsFold *string  `json:"ipsContainsFold,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	Description    *string    `json:"description,omitempty"`
	LogoURL        *string    `json:"logoURL,omitempty"`
	SettingID      *nanox.ID  `json:"settingID,omitempty"`
	AddUserIDs     []nanox.ID `json:"addUserIDs,omitempty"`
	RemoveUserIDs  []nanox.ID `json:"removeUserIDs,omitempty"`
	ClearUsers     *bool      `json:"clearUsers,omitempty"`
	OwnerID        *nanox.ID  `json:"ownerID,omitempty"`
	ClearOwner     *bool      `json:"clearOwner,omitempty"`
}

// UpdateGroupSettingsInput is used for update GroupSettings object.
// Input was generated by ent.
type UpdateGroupSettingsInput struct {
	UpdatedAt      *time.Time                `json:"updatedAt,omitempty"`
	CreatedBy      *string                   `json:"createdBy,omitempty"`
	ClearCreatedBy *bool                     `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string                   `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool                     `json:"clearUpdatedBy,omitempty"`
	Visibility     *groupsettings.Visibility `json:"visibility,omitempty"`
	JoinPolicy     *groupsettings.JoinPolicy `json:"joinPolicy,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
	CreatedBy        *string    `json:"createdBy,omitempty"`
	ClearCreatedBy   *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy        *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy   *bool      `json:"clearUpdatedBy,omitempty"`
	Name             *string    `json:"name,omitempty"`
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	OwnerID          *nanox.ID  `json:"ownerID,omitempty"`
	ClearOwner       *bool      `json:"clearOwner,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Name           *string    `json:"name,omitempty"`
	// An optional description of the Organization
	Description          *string    `json:"description,omitempty"`
	ClearDescription     *bool      `json:"clearDescription,omitempty"`
	AddUserIDs           []nanox.ID `json:"addUserIDs,omitempty"`
	RemoveUserIDs        []nanox.ID `json:"removeUserIDs,omitempty"`
	ClearUsers           *bool      `json:"clearUsers,omitempty"`
	AddGroupIDs          []nanox.ID `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs       []nanox.ID `json:"removeGroupIDs,omitempty"`
	ClearGroups          *bool      `json:"clearGroups,omitempty"`
	AddIntegrationIDs    []nanox.ID `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []nanox.ID `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool      `json:"clearIntegrations,omitempty"`
}

// UpdateSessionInput is used for update Session object.
// Input was generated by ent.
type UpdateSessionInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	// The session may be disabled by the user or by automatic security policy
	Disabled *bool `json:"disabled,omitempty"`
	// The last known user-agent
	UserAgent      *string `json:"userAgent,omitempty"`
	ClearUserAgent *bool   `json:"clearUserAgent,omitempty"`
	// All IPs that have been associated with this session. Reverse-chronological order. The current IP is the first item in the slice
	Ips        *string   `json:"ips,omitempty"`
	UsersID    *nanox.ID `json:"usersID,omitempty"`
	ClearUsers *bool     `json:"clearUsers,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
	CreatedBy      *string    `json:"createdBy,omitempty"`
	ClearCreatedBy *bool      `json:"clearCreatedBy,omitempty"`
	UpdatedBy      *string    `json:"updatedBy,omitempty"`
	ClearUpdatedBy *bool      `json:"clearUpdatedBy,omitempty"`
	Email          *string    `json:"email,omitempty"`
	FirstName      *string    `json:"firstName,omitempty"`
	LastName       *string    `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile      *string `json:"avatarLocalFile,omitempty"`
	ClearAvatarLocalFile *bool   `json:"clearAvatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// The time the user was silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// local Actor password recovery code generated during account creation
	RecoveryCode          *string    `json:"recoveryCode,omitempty"`
	ClearRecoveryCode     *bool      `json:"clearRecoveryCode,omitempty"`
	AddOrganizationIDs    []nanox.ID `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []nanox.ID `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations    *bool      `json:"clearOrganizations,omitempty"`
	AddSessionIDs         []nanox.ID `json:"addSessionIDs,omitempty"`
	RemoveSessionIDs      []nanox.ID `json:"removeSessionIDs,omitempty"`
	ClearSessions         *bool      `json:"clearSessions,omitempty"`
	AddGroupIDs           []nanox.ID `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs        []nanox.ID `json:"removeGroupIDs,omitempty"`
	ClearGroups           *bool      `json:"clearGroups,omitempty"`
}

type User struct {
	ID        nanox.ID  `json:"id"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedBy *string   `json:"createdBy,omitempty"`
	UpdatedBy *string   `json:"updatedBy,omitempty"`
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// The time the user was silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt   *time.Time      `json:"suspendedAt,omitempty"`
	Organizations []*Organization `json:"organizations,omitempty"`
	Sessions      []*Session      `json:"sessions,omitempty"`
	Groups        []*Group        `json:"groups,omitempty"`
}

func (User) IsNode() {}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID nanox.ID `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *nanox.ID  `json:"id,omitempty"`
	IDNeq   *nanox.ID  `json:"idNEQ,omitempty"`
	IDIn    []nanox.ID `json:"idIn,omitempty"`
	IDNotIn []nanox.ID `json:"idNotIn,omitempty"`
	IDGt    *nanox.ID  `json:"idGT,omitempty"`
	IDGte   *nanox.ID  `json:"idGTE,omitempty"`
	IDLt    *nanox.ID  `json:"idLT,omitempty"`
	IDLte   *nanox.ID  `json:"idLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// sessions edge predicates
	HasSessions     *bool                `json:"hasSessions,omitempty"`
	HasSessionsWith []*SessionWhereInput `json:"hasSessionsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
}

type Service struct {
	Sdl *string `json:"sdl,omitempty"`
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldName GroupOrderField = "name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldName IntegrationOrderField = "name"
	IntegrationOrderFieldKind IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldName OrganizationOrderField = "name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
